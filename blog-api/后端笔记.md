# 1.后端笔记
## 1.1 关于Controller层
### 1.1.1 AguoResult对象作用
​	所有的controller的return的类型一定要是AguoResult对象，该对象有以下的属性：

- Boolean success
    - 成功为true 失败为false
- Integer code
    - 状态码 成功时200，但是失败不一定，失败的状态码要手动赋值，所以平时出现的错误代码其实就是这个状态码
- String msg
    - 错误的文字描述信息
- Object data
    - 这里是放data数据的，一般是集合类
> 注意,AguoResult对象不可以使用new!，而是通过类名AGuoResult.success/failed来调用。
> 我们可以将这个对象的构造方法私有化    
### 1.1.2 controller使用AguoResult
​	controller不能直接使用AGuoResult的任何变量和方法，这个结果对象只是给业务层Service使用的！

## 1.2 统一异常处理

​	对于预知的异常，我们肯定都已经通过异常处理，异常捕获完成了。但是对于未知的异常，我们需要统一的处理。

```java
package com.aguo.blogapi.handle;

import com.aguo.blogapi.vo.AGuoResult;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

/**
 * @Author: aguo
 * @DateTime: 2022/4/25 17:29
 * @Description: 所有意外异常处理类
 */
//对所有加了@Controller注解的方法进行前拦截处理，其实是AOP的实现,出现后调用以下方法。

@ControllerAdvice
@ResponseBody
public class AllExceptionHandler {
    //进行异常处理，处理Exception类型的异常
    @ExceptionHandler(value = Exception.class)
    public AGuoResult doException(Exception e) {
        e.printStackTrace();
        return AGuoResult.failed(-999,"系统异常");
    }
}

```

## 1.3 dos目录

存放的是在数据库中不存在的，但是前端又需要的对象。

vo对象是数据库中存在的，但需要entity对象聚合，或者更换数据类型。

## 1.4 登录注册

### 1.4.1 登录

高内聚，低耦合，userservice就只是负责user表相关操作，因此在loginController不应该使用userService类，因为每个人有每个人做自己专业事情。

### 1.4.2 JwtToken加密

```java
package com.aguo.blogapi.untils;

import io.jsonwebtoken.Jwt;
import io.jsonwebtoken.JwtBuilder;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;

public class JWTUtils {

    private static final String SECRET_KEY = "1534774766AGuo";

    public static String createToken(Long userId){
        Map<String,Object> claims = new HashMap<>();
        claims.put("userId",userId);
        JwtBuilder jwtBuilder = Jwts.builder()
                .signWith(SignatureAlgorithm.HS256, SECRET_KEY) // 签发算法，秘钥为SECRET_KEY
                .setClaims(claims) // body数据，要唯一，自行设置
                .setIssuedAt(new Date()) // 设置签发时间
                .setExpiration(new Date(System.currentTimeMillis() + 24 * 60 * 60 * 1000L));// 一天的有效时间
        String token = jwtBuilder.compact();
        return token;
    }

    public static Map<String, Object> checkToken(String token){
        try {
            Jwt parse = Jwts.parser().setSigningKey(SECRET_KEY).parse(token);
            return (Map<String, Object>) parse.getBody();
        }catch (Exception e){
            e.printStackTrace();
        }
        return null;

    }

}
```

登录成功后，token将会返回给前端，前端要对token保存并放在storage中存放token，

==注意：==因为前端只获取到了token，但是没有获取到user的信息，因此需要写接口：获取当前用户信息的接口，也就是userController中的currentUser方法

### 1.4.3 整合redis

```properties
#配置redis
spring.redis.port=6379
spring.redis.host=192.168.198.142
```

```java
@Autowired
private RedisTemplate redisTemplate;
```

```java
//放token
redisTemplate.opsForValue().set("TOKEN_"+token, JSON.toJSONString(sysUser),1L, TimeUnit.DAYS);
//取
//        查redis中的token，如果查出结果直接返回，不需要查数据库，牛逼
        String userJson = (String) redisTemplate.opsForValue().get("TOKEN_"+token);
        if (!StringUtils.isEmpty(userJson)){
            resultMap.put("success",true);
            resultMap.put("code",200);
            resultMap.put("msg","Token合法");
            resultMap.put("sysUser",JSON.parseObject(userJson, SysUser.class));
            return resultMap;
        }
```



### 1.4.4 验证token

loginService中的verifyToken方法

~~~java
    @Override
    public Map<String, Object> verifyToken(String token) {
        HashMap<String, Object> resultMap = new HashMap<>();
        //        token非空校验，
        if (StringUtils.isEmpty(token)) {
            resultMap.put("success", false);
            resultMap.put("code", ErrorCode.NO_LOGIN.getCode());
            resultMap.put("msg", ErrorCode.NO_LOGIN.getMsg());
            return resultMap;
        }
//         Jwt验证token,token是否合法，是否过期
        if (JWTUtils.checkToken(token) == null) {
            resultMap.put("success", false);
            resultMap.put("code", ErrorCode.TOKEN_TIMEOUT.getCode());
            resultMap.put("msg", ErrorCode.TOKEN_TIMEOUT.getMsg());
            return resultMap;
        }

//        查redis中的token，如果查出结果直接返回，不需要查数据库，牛逼
        String userJson = (String) redisTemplate.opsForValue().get("TOKEN_" + token);
        if (!StringUtils.isEmpty(userJson)) {
            resultMap.put("success", true);
            resultMap.put("code", 200);
//            resultMap.put("msg","Token合法");
            resultMap.put("sysUser", JSON.parseObject(userJson, SysUser.class));
            return resultMap;
        }
        resultMap.put("success", false);
        resultMap.put("code", ErrorCode.TOKEN_CACHE_FAILURE.getCode());
        resultMap.put("msg", ErrorCode.TOKEN_CACHE_FAILURE.getMsg());
        return resultMap;
    }
~~~

## 1.5 ThreadLocal

如果前端只给了token，那么后端怎么方便的获取用户信息呢？

任意Service，任意Controller都能方便的获取用户信息？

## 1.6 文章多维

如果一个实体当中，一对多，或者一对一一个实体，如果另外一个实现不需要，那我们可以通过is字段，来控制实现字段需不需要。即，==【按需引入】==

【例】文章实体，一个文章中包含，本身id，文章标题，文章描述，作者id，内容id，分类id。除了本身id之外，有其他id，其他id在文章实体中是以id形式存在，但是在文章Vo对象当中，是以其他id对应的vo对象存在的，但是其他的Vo对象不一定需要。

比如

- 前端只需要文章标题，文章描述，==不需要文章内容==
  - 此时 文章内容在业务层注入设置为false即可。

代码例子：

```java
//可以看到形参有4个是布尔类型，这样就可以实现【按需引入】
private List<ArticleVo> copyList(List<Article> article,boolean isTag, boolean isAuthor,boolean isBoby,boolean isCategory) {
    List<ArticleVo> list = new ArrayList<>();
    for (Article articlevar : article) {
        list.add(copy(articlevar,isTag,isAuthor,isBoby,isCategory));
    }
    return list;
}
```

## 1.7 线程池的使用

对于一些可以异步的操作，我们可以引入线程池，让线程池中的线程执行一个特定的任务，而不影响主线程的使用。

> 线程池的配置

```java
@Configuration
@EnableAsync //开启多线程
public class ThreadPoolConf {
    @Bean("taskExecutor") //线程池名称
    public Executor taskExecutor(){
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        //设置核心线程数
        executor.setCorePoolSize(5);
        //设置最大线程数
        executor.setMaxPoolSize(20);
        //设置活跃线程数
        executor.setKeepAliveSeconds(60);
        //配置队列的大小
        executor.setQueueCapacity(Integer.MAX_VALUE);
        //设置线程前缀名称
        executor.setThreadNamePrefix("阿果线程池");
        //当关闭停止spring容器时，如果线程池仍然有任务，那么不会中断尚未完成的任务
        executor.setWaitForTasksToCompleteOnShutdown(true);
        //初始化线程池
        executor.initialize();
        return executor;
    }
}
```



> 线程池的使用

1. 

```java
@Service
public class ThreadService {
    @Async("taskExecutor") //1.对方法名加注解，并表示所使用到的线程池
    public void increaseArticleViewCount(ArticleMapper articleMapper, Article article){
        articleMapper.increaseArticleViewCountById(article.getId());
    }
}
```

2. 1

```java
任意地方：threadService.increaseArticleViewCount(...) 即可直接异步使用
```

## 1.8 entity对象、Vo对象、param对象

数据实体对象映射规则：

| entity对象      | Vo对象                                     |
| --------------- | ------------------------------------------ |
| Long id         | Long id （强推为String类型，避免精度丢失） |
| Long createDate | String createDate                          |
| Long UserId     | UserVo userVo                              |

> param对象纯粹是为了接收前端的数据

注意，param对象在controller当中要加@requestParam注解，以便解析前端的json字符串对象。

==除了ID用Long类型接收以外，其他的所有类型都用String类型接收，或者其他Param对象==，但是Id强推String类型，避免精度丢失的处理操作

### 1.8.1 copylist和copy

> entity与vo对象的映射方法！

copyList只是负责遍历。

重点放在copy方法，copy方法有以下注意点：

- 按需注入
  - 因为Vo对象中的所有属性前端不一定需要，因此copy方法的形参中应该有Boolean类型的值，表示某个值是否需要注入到Vo对象当中。

- otherID与other对象映射
  - entity对象聚合其他对象是ID的形式，但在Vo对象就是其他对象的形式，需在copy方法中通过SQL查询或者其他方式对Vo对象的子对象填充
- BeanUtilBeanUtils.copyProperties(）使用的注意
  - Long与String类型无法完成映射，需要手动的在copy方法中完成Long到String的映射
  - 日期格式映射，因为数据库中的时间一般是Bigint或者TimeStamp类型，这个工具类也不能完成，因此需要转为指定的日期字符串的格式来注入到Vo当中
- 

## 1.9 Aop

名词解释：

**切面**（Aspect）：切面编程的完整定义模块，比如日志切面，包含了何时、对谁、如何等等所有的内容。
**连接点**（Join point）：能够植入切面的部分，比如方法前后，抛出异常时都可以是连接点，spring只支持方法连接点
**通知**（Advice）：要对切面添加的功能代码，比如 安全，事物，日志等功能代码。类型：before/after/around/after-returning/after-throwing
**切入点**（Pointcut）：针对哪些连接点植入通知，也就是指定具体的拦截地点。可以通过spEL指定连接点
**引入**（Introduction）：对目标类添加新方法及属性
**目标对象**（Target object）：被切面切的对象。真正的业务逻辑，完全不知道存在切面
**代理**（proxy）：实现AOP的一种原理
**织入**（Weaving）：把切面应用到目标对象来创建新的代理对象的过程。有3种方式，spring采用的是运行时。 

### 1.9.1 前提设置

> 自定义注解

```java
package com.aguo.blogapi.common.aop;
import java.lang.annotation.*;
//Target ElementType.METHOD：表示注解到方法
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface LogAnnotation {
    String module() default "";
    String operation() default "";
}
```

> 使得注解生效



```java
@Component
@Aspect //定义通知 （就是需要添加的功能代码 ）和切点（连接点，切入的目标方法）的关系
@Slf4j
public class LogAspect {

//    标识这个注解为切入点，那么之后但凡被这个注解标识的方法那么就会被作为切入点，只用来启动这个自己写的注解，方法体应为空
    @Pointcut("@annotation(com.aguo.blogapi.common.aop.LogAnnotation)")
    public void pointcut(){}
    
    //定义通知，这里是环绕通知，即方法的前后都能捕获.
    @Around("pointcut()") //对什么已声明的注解进行环绕，这里是环绕pointcut()方法，等价于环绕的是pointcut()启用的自定义注解LogAnnotation所注解的其他方法。说人话就是，等价于LogAnnotation标号什么方法，什么方法就被增强！
    public Object logAround(ProceedingJoinPoint joinPoint) throws Throwable {
        // 目标方法执行前
        long beginTime = System.currentTimeMillis();
		其他...
            
        //执行目标方法
        Object result = joinPoint.proceed();
        
        //目前方法执行后
        long endTime = System.currentTimeMillis();
		其他..
         比如调用自定义的记录日志：
         recordLog(joinPoint,endTime-beginTime);
      
        reuturn result;
    }
```







### 1.9.2 使用注解，指定切入点

如在controller类中使用：

```java
@PostMapping("")
    //加上此注解，表示要记录这个方法的日志，aop方式
    @LogAnnotation(module = "文章",operation = "获取所有文章")
    public AGuoResult listArticle(@RequestBody PageParams pageParams){
        return articleService.listArticle(pageParams);
    }
```

## 1.10 七牛云

1.创建好七牛云的服务器空间

![image-20220501222528615](https://i0.hdslb.com/bfs/album/4dfe6ba8e77517c9b24cfd5dc6b0befbcaacc288.png)

2. java引入依赖

   ```xml
   <!--        七牛云-->
   <dependency>
       <groupId>com.qiniu</groupId>
       <artifactId>qiniu-java-sdk</artifactId>
   <version>[7.7.0, 7.10.99]</version>
   ```

3. 编写QinniuUtil类

   ```java
   @Component
   public class QiniuUtils {
   
       public static final String url = "http://rb7fp6j8y.hn-bkt.clouddn.com/"; //最后一个别忘记 ’/‘
   
       @Value("${qiniu.accessKey}")
       private String accessKey;
       @Value("${qiniu.accessSecretKey}")
       private String accessSecretKey;
   
       public boolean upload(MultipartFile file, String fileName) {
           //构造一个带指定 Region 对象的配置类
           Configuration cfg = new Configuration(Region.huanan());
           //...其他参数参考类注释
           UploadManager uploadManager = new UploadManager(cfg);
           //...生成上传凭证，然后准备上传
           String bucket = "aguoblog";
           //默认不指定key的情况下，以文件内容的hash值作为文件名
           try {
               byte[] uploadBytes = file.getBytes();
               Auth auth = Auth.create(accessKey, accessSecretKey);
               String upToken = auth.uploadToken(bucket);
               Response response = uploadManager.put(uploadBytes, fileName, upToken);
               //解析上传成功的结果
               DefaultPutRet putRet = JSON.parseObject(response.bodyString(), DefaultPutRet.class);
               return true;
           } catch (Exception ex) {
               ex.printStackTrace();
           }
           return false;
       }
   }
   ```

4. application.properties配置

   密钥在七牛云的个人中心找

   ```properties
   # 七牛云配置
   # 上传文件总的最大值
   spring.servlet.multipart.max-request-size=5MB
   # 单个文件的最大值
   spring.servlet.multipart.max-file-size=2MB
   qiniu.accessKey=...PedHxq97C6xSz...
   qiniu.accessSecretKey=...yem3gLCFN...
   qiniu.bucket=aguoblog #对象库的库名
   ```

5. 编写UploadController.class

   前端就可以通过http://.../upload，上传二进制文件（图片)

   ```java
   @RestController
   @RequestMapping("upload")
   public class UploadController {
       @Autowired
       private QiniuUtils qiniuUtils;
       @PostMapping
       public AGuoResult upload(@RequestParam("image") MultipartFile file){
           // 获得原始文件名 aa.png  → aa.png
           String originalFilename = file.getOriginalFilename();
           // 生成新的文件名，避免重复
           // UUID.png
           StringBuilder newFileName =  new StringBuilder(String.valueOf(UUID.randomUUID()));
           newFileName.append(".").append(StringUtils.substringAfterLast(originalFilename, "."));
           // 文件上传到哪里呢？？？
           boolean upload = qiniuUtils.upload(file,newFileName.toString());
           if (upload){
               return AGuoResult.success(QiniuUtils.url+newFileName.toString());
           }
           return AGuoResult.failed(ErrorCode.FILE_UPLOAD_ERROR.getCode(), ErrorCode.FILE_UPLOAD_ERROR.getMsg());
       }
   }
   ```

##  1.11 雪花算法的ID精度丢失问题

   在VO对象中的LongId需要加注解，避免精度丢失：

   【例】entity对象的id为 1231541861658311(Long) 当转为Vo对象时候精度将会变成==**1231541861658300**==，导致精度丢失。

   丢失的原因是BeanUtils.copyProperties（）方法导致的。

   > 办法

​	在Vo对象的id之上加注解即可，==治本方法，就是把Vo对象中的ID统统改为String类型==

```java
@Data
public class ArticleVo {
    @JsonSerialize(using = ToStringSerializer.class)
    private Long id;
}
```

## 1.12 Controller参数类型问题

如果controller的形参类型是基本数据类型（int）而不是包装类型（Integer）那么将出大问题，通过反射机制的getMethod方法将会得不到Method对象。

原因分析：getMethod(methodName, parameterTypes)，其中parameterTypes中，如果controller的形参是int类型，而反射机制得到的却是Integer类型。但是controller形参实际上是int类型，那么通过getMethod方法将会报方法找不到异常！

## 1.12 Controller-processor使用

就是让你自己在application.yml自定义的属性不报警告

1.引入依赖

```xml
<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-configuration-processor</artifactId>
            <optional>true</optional>
        </dependency>
```

2.在需要的类加注解 

prefix 是application.yml自定义属性的大前缀

```java
@ConfigurationProperties(prefix = "qiniu")
public class QiniuUtil {
    
}
```

> 注意：类中的属性不能static修饰，因为这样的话这个属性在类加载的时候就生成了，那么就不会注入application.yaml文件中的值了

3.application.yml示例

```yaml
qiniu:
    accessKey: hWg3eH6y0pmo20RibHPedH...
    accessSecretKey: Uc-qUGZ8NbulZdZC...
    bucket: aguoblog
    url: http://rb7hn....-bkt.clouddn.com/
```







