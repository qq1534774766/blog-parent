-- MySQL dump 10.13  Distrib 8.0.22, for Win64 (x86_64)
--
-- Host: 127.0.0.1    Database: blog
-- ------------------------------------------------------
-- Server version	8.0.22

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `aguo_admin`
--

DROP TABLE IF EXISTS `aguo_admin`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `aguo_admin` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `username` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `aguo_admin`
--

LOCK TABLES `aguo_admin` WRITE;
/*!40000 ALTER TABLE `aguo_admin` DISABLE KEYS */;
INSERT INTO `aguo_admin` VALUES (1,'admin','$2a$10$RZECQ90DjOT/t1mhnXsl5.XSuZWc0Sa1XduPxj2rb4yaSYcje3nWW'),(2,'aguo','$2a$10$RZECQ90DjOT/t1mhnXsl5.XSuZWc0Sa1XduPxj2rb4yaSYcje3nWW');
/*!40000 ALTER TABLE `aguo_admin` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `aguo_admin_permission`
--

DROP TABLE IF EXISTS `aguo_admin_permission`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `aguo_admin_permission` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `admin_id` bigint NOT NULL,
  `permission_id` bigint NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `aguo_admin_permission`
--

LOCK TABLES `aguo_admin_permission` WRITE;
/*!40000 ALTER TABLE `aguo_admin_permission` DISABLE KEYS */;
INSERT INTO `aguo_admin_permission` VALUES (1,1,1),(2,2,1);
/*!40000 ALTER TABLE `aguo_admin_permission` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `aguo_article`
--

DROP TABLE IF EXISTS `aguo_article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `aguo_article` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `comment_counts` int DEFAULT NULL COMMENT '评论数量',
  `create_date` bigint DEFAULT NULL COMMENT '创建时间',
  `summary` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '简介',
  `title` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '标题',
  `view_counts` int DEFAULT NULL COMMENT '浏览数量',
  `weight` int NOT NULL COMMENT '是否置顶',
  `author_id` bigint DEFAULT NULL COMMENT '作者id',
  `body_id` bigint DEFAULT NULL COMMENT '内容id',
  `category_id` int DEFAULT NULL COMMENT '类别id',
  PRIMARY KEY (`id`) USING BTREE,
  KEY `index_view_counts` (`view_counts`,`title`)
) ENGINE=InnoDB AUTO_INCREMENT=1405916999732707359 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `aguo_article`
--

LOCK TABLES `aguo_article` WRITE;
/*!40000 ALTER TABLE `aguo_article` DISABLE KEYS */;
INSERT INTO `aguo_article` VALUES (1,1,1621947720727,'通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\r\n\r\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。','springboot介绍以及入门案例',264,1,1,1,2),(9,0,1613947720727,'Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。','Vue.js 到底是什么',10,1,1,20,2),(10,0,1523947720727,'本节将介绍如何在项目中使用 Element。','Element相关',17,1,1,21,2),(1405916999732707330,0,1624031708047,'springboot入门案例','SpringBoot入门案例',127,1,1,1405916999854342146,2),(1405916999732707347,0,1651653165068,'springboot入门案例1','SpringBoot入门案例',4,0,1,1521769787794284545,2),(1405916999732707353,0,1651665797032,'Java常用设计模式，更多模式待补充...','Java常用设计模式',4,0,1,1521822769621684226,2);
/*!40000 ALTER TABLE `aguo_article` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `aguo_article_body`
--

DROP TABLE IF EXISTS `aguo_article_body`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `aguo_article_body` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci,
  `content_html` longtext CHARACTER SET utf8 COLLATE utf8_general_ci,
  `article_id` bigint NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  KEY `article_id` (`article_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1521839344751874051 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `aguo_article_body`
--

LOCK TABLES `aguo_article_body` WRITE;
/*!40000 ALTER TABLE `aguo_article_body` DISABLE KEYS */;
INSERT INTO `aguo_article_body` VALUES (1,'# 1. Spring Boot介绍\r\n\r\n## 1.1 简介\r\n\r\n在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？\r\n\r\n在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？\r\n\r\n那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！\r\n\r\nSpring Boot让我们的Spring应用变的更轻量化。\r\n\r\n我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。\r\n\r\n通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\r\n\r\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。\r\n\r\n**总结一下Spring Boot的主要优点：**\r\n\r\n1. 为所有Spring开发者更快的入门\r\n2. 开箱即用，提供各种默认配置来简化项目配置\r\n3. 内嵌式容器简化Web项目\r\n4. 没有冗余代码生成和XML配置的要求\r\n5. 统一的依赖管理\r\n6. 自动装配，更易使用，更易扩展\r\n\r\n## 1.2 使用版本说明\r\n\r\nSpringboot版本：使用最新的2.5.0版本\r\n\r\n教程参考了官方文档进行制作，权威。\r\n\r\n其他依赖版本：\r\n\r\n	1. Maven  需求：3.5+\r\n\r\n   	2. JDK 需求  8+\r\n   	3. Spring Framework 5.3.7以上版本\r\n   	4. Tomcat 9.0\r\n   	5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\r\n\r\n# 2. 快速入门\r\n\r\n快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。\r\n\r\n教程使用的Idea版本：2019.3\r\n\r\n## 2.1 创建基础项目\r\n\r\n**第一步：** 创建maven项目\r\n\r\npom.xml :\r\n\r\n~~~xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <groupId>com.xiaopizhu</groupId>\r\n    <artifactId>helloSpringBoot</artifactId>\r\n    <version>1.0-SNAPSHOT</version>\r\n	<!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突-->\r\n    <parent>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-parent</artifactId>\r\n        <version>2.5.0</version>\r\n    </parent>\r\n</project>\r\n~~~\r\n\r\n注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。\r\n\r\n此时的工程结构为：\r\n\r\n![image-20210523173241557](img/image-20210523173241557.png)\r\n\r\n**第二步：** 添加web依赖\r\n\r\n~~~xml\r\n<dependencies>\r\n    <dependency>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-web</artifactId>\r\n    </dependency>\r\n</dependencies>\r\n~~~\r\n\r\n添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。\r\n\r\n**第三步：** 编写启动类\r\n\r\n~~~java\r\npackage com.xiaopizhu.springboot;\r\n\r\nimport org.springframework.boot.SpringApplication;\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\n\r\n@SpringBootApplication\r\npublic class HelloApp {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(HelloApp.class,args);\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。\r\n\r\n**第四步：** 运行启动类的main方法\r\n\r\n![image-20210523173712142](img/image-20210523173712142.png)\r\n\r\n看到如上配置，证明启动成功，tomcat端口号默认为8080。\r\n\r\n**第五步：**  如果想要修改端口号，可以在resources目录下新建application.properties\r\n\r\n~~~properties\r\nserver.port=8082\r\n~~~\r\n\r\n**第六步：** 重新运行\r\n\r\n![image-20210523174011613](img/image-20210523174011613.png)\r\n\r\n此时的项目结构为：\r\n\r\n![image-20210523174032053](img/image-20210523174032053.png)\r\n\r\n**src/main/java :**  编写java代码，注意启动类需要放在项目的根包下。\r\n\r\n**src/main/resources:**  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。\r\n\r\n**src/test/java:**  测试代码\r\n\r\n## 2.2 编写一个Http接口\r\n\r\n**第一步：**创建`HelloController`类，内容如下：\r\n\r\n~~~java\r\npackage com.xiaopizhu.springboot.controller;\r\n\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\n@RestController\r\n@RequestMapping(\"hello\")\r\npublic class HelloController {\r\n\r\n    @GetMapping(\"boot\")\r\n    public String hello(){\r\n        return \"hello spring boot\";\r\n    }\r\n\r\n}\r\n\r\n~~~\r\n\r\n**注意包名，必须在启动类所在的包名下。**\r\n\r\n**第二步：**重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\r\n\r\n得到结果：hello spring boot\r\n\r\n## 2.3 编写单元测试用例\r\n\r\n**第一步：**添加spring boot测试依赖\r\n\r\n~~~xml\r\n		<dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-test</artifactId>\r\n            <scope>test</scope>\r\n        </dependency>\r\n~~~\r\n\r\n**第二步：**在src/test 下，编写测试用例\r\n\r\n~~~java\r\npackage com.xiaopizhu.springboot.controller;\r\n\r\nimport org.junit.jupiter.api.BeforeAll;\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport org.springframework.http.MediaType;\r\nimport org.springframework.test.web.servlet.MockMvc;\r\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\r\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\r\n\r\nimport static org.hamcrest.Matchers.equalTo;\r\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\r\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\r\n\r\n@SpringBootTest\r\npublic class TestHelloController {\r\n\r\n    private MockMvc mockMvc;\r\n\r\n    @BeforeEach\r\n    public void beforeEach(){\r\n        mockMvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\r\n    }\r\n    @Test\r\n    public void testHello() throws Exception {\r\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/hello/boot\")\r\n                .accept(MediaType.APPLICATION_JSON))\r\n                .andExpect(status().isOk())\r\n                .andExpect(content().string(equalTo(\"hello spring boot\")));\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n上面的测试用例，是构建一个空的`WebApplicationContext`，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。\r\n\r\n## 2.4 打包为jar运行\r\n\r\n**第一步：**添加打包(maven构建springboot)插件\r\n\r\n~~~xml\r\n  <build>\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>org.springframework.boot</groupId>\r\n                <artifactId>spring-boot-maven-plugin</artifactId>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n~~~\r\n\r\n在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar\r\n\r\n![image-20210523181737720](img/image-20210523181737720.png)\r\n\r\n**第二步：**打开cmd：找到jar对应的目录\r\n\r\n输入命令\r\n\r\n~~~shell\r\njava -jar helloSpringBoot-1.0-SNAPSHOT.jar\r\n~~~\r\n\r\n![image-20210523182426404](img/image-20210523182426404.png)\r\n\r\n**第三步：**测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\r\n\r\n得到结果：hello spring boot\r\n\r\n## 2.5 查看jar包内容\r\n\r\n~~~shell\r\njar tvf helloSpringBoot-1.0-SNAPSHOT.jar\r\n~~~\r\n\r\n# 3. 小结\r\n\r\n1. 通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。\r\n2. 通过修改配置文件，更改端口号\r\n3. 编写了测试用例\r\n4. 打包jar包运行\r\n\r\n','<h2>2018-01-04</h2>\n<pre><code class=\"lang-\"># 使用vue的Webpack模板生成脚手架\n</code></pre>\n<h2>2018-01-05</h2>\n<pre><code class=\"lang-\"># 引入ElementUI\n\n# babel-plugin-component自定义主题\n# 首页\n# 登陆页\n# 注册页面\n# 日志页\n</code></pre>\n<h2>2018-01-07</h2>\n<pre><code class=\"lang-\"># 调整底部栏始终固定在底部\n# 日志页 添加时间轴\n# 首页的文章列表\n</code></pre>\n<h2>2018-01-08</h2>\n<pre><code class=\"lang-\"># 使用组件-博客作者tab页 \n# 添加第三方图标\n</code></pre>\n<h2>2018-01-09</h2>\n<pre><code class=\"lang-\"># 调整顶部导航栏：激活文字颜色，click点击\n# 组件-最新文章tab页\n\n# 最新文章、最热文章使用相同组件\n# 底部栏设计\n# 页面与两边边距改为100\n</code></pre>\n<h2>2018-01-10</h2>\n<pre><code class=\"lang-\"># 写博客 引入mavonEditor编辑器\n# 顶部导航栏都放入一个Menu中\n# 写文章页面\n#　mavonEditor局部引入\n\n#　页面的中间区域固定宽度，自动居中\n# 发布和取消\n# 发布dialog\n\n</code></pre>\n<h2>2018-01-11</h2>\n<pre><code class=\"lang-\"># 文章组件用守卫来改变body背景色\n# 调整登陆和注册页面，使其居中\n\n#子页面调整根元素为div\n#文章详情页\n\n</code></pre>\n<h2>2018-01-12</h2>\n<pre><code class=\"lang-\"># 文章详情页  内容  评论等\n\n</code></pre>\n<h2>2018-01-13</h2>\n<pre><code class=\"lang-\">## 重新调整页面结构	\n#顶部和底部 抽成  BaseHeader BaseFooter 组件\n#BlogView为单独页，以前是Home的子路由\n\n</code></pre>\n<h2>2018-01-15</h2>\n<pre><code class=\"lang-\"># 文章分类去掉子级\n# 将首页的文章列表抽成 ArticleItem组件\n# 增加文章的评论展示\n# 增加文章分类、标签页\n\n</code></pre>\n<h2>2018-01-15  2</h2>\n<pre><code class=\"lang-\"># 回到顶部去掉过渡动画（影响顶部导航栏）\n# 顶部导航栏 增加登录后菜单\n# 首页增加 最热标签\n# 增加 文章分类 标签的详情页\n# 将文章详情页、 文章分类标签页 改为Home的子路由（以前单独页）\n# Home组件增加路由判断：更正导航栏的状态、条件显示底部栏\n\n</code></pre>\n<h2>2018-01-16</h2>\n<pre><code class=\"lang-\"># 将写文章的顶部Header合并到BaseHeader中\n# 图片都放到了static目录下\n\n</code></pre>\n<h2>2018-01-24</h2>\n<pre><code class=\"lang-\"># 将自定义的theme放到assets下\n# 加入axios\n# 加入vuex\n# 实现登录\n# 实现退出\n\n</code></pre>\n<h2>2018-01-25</h2>\n<pre><code class=\"lang-\"># 实现注册逻辑\n# 写文章功能实现\n# 写文章时支持插入图片\n\n</code></pre>\n<h2>2018-01-26</h2>\n<pre><code class=\"lang-\"># 引入lodash工具类\n# 优化写文章的工具栏：滚动时固定顶部\n# 写文章 后台获取文章分类和标签\n\n# 首页的文章列表\n\n</code></pre>\n<h2>2018-01-27</h2>\n<pre><code class=\"lang-\"># 修改首页文章列表的样式\n# 首页加载文章功能\n# 文章查看功能\n# 文章分类和标签功能列表\n\n</code></pre>\n<h2>2018-01-28</h2>\n<pre><code class=\"lang-\"># 文章分类和标签详情\n\n</code></pre>\n<h2>2018-01-29</h2>\n<pre><code class=\"lang-\"># 文章分类和标签的文章数\n# 首页最热文章\n# 首页最新文章\n# 首页最热标签\n\n</code></pre>\n<h2>2018-01-30</h2>\n<pre><code class=\"lang-\"># BaseHeader放回views中\n# 修改Axios后置拦截，全局处理错误\n# 将登录 退出 和头像 放到一起\n\n</code></pre>\n',1),(20,'Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。\n\n如果你想在深入学习 Vue 之前对它有更多了解，我们制作了一个视频，带您了解其核心概念和一个示例工程。\n如果你已经是有经验的前端开发者，想知道 Vue 与其它库/框架有哪些区别，请查看对比其它框架。\n\n# 起步\n\n> 官方指南假设你已了解关于 HTML、CSS 和 JavaScript 的中级知识。如果你刚开始学习前端开发，将框架作为你的第一步可能不是最好的主意——掌握好基础知识再来吧！之前有其它框架的使用经验会有帮助，但这不是必需的。\n\n尝试 Vue.js 最简单的方法是使用 JSFiddle 上的 Hello World 例子。你可以在浏览器新标签页中打开它，跟着例子学习一些基础用法。或者你也可以创建一个 .html 文件，然后通过如下方式引入 Vue：\n\n```javascript\n<script src=\"https://cdn.jsdelivr.net/npm/vue\"></script>\n\n```\n安装教程给出了更多安装 Vue 的方式。请注意我们不推荐新手直接使用 vue-cli，尤其是在你还不熟悉基于 Node.js 的构建工具时。\n\n# 声明式渲染\nVue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统：\n```javascript\n<div id=\"app\">\n  {{ message }}\n</div>\n\n```\n```javascript\nvar app = new Vue({\n  el: \'#app\',\n  data: {\n    message: \'Hello Vue!\'\n  }\n})\n\n```\n我们已经成功创建了第一个 Vue 应用！看起来这跟渲染一个字符串模板非常类似，但是 Vue 在背后做了大量工作。现在数据和 DOM 已经被建立了关联，所有东西都是响应式的。我们要怎么确认呢？打开你的浏览器的 JavaScript 控制台 (就在这个页面打开)，并修改 app.message 的值，你将看到上例相应地更新。\n\n除了文本插值，我们还可以像这样来绑定元素特性：\n\n\n\n\n\n\n','<p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>\n<p>如果你想在深入学习 Vue 之前对它有更多了解，我们制作了一个视频，带您了解其核心概念和一个示例工程。<br />\n如果你已经是有经验的前端开发者，想知道 Vue 与其它库/框架有哪些区别，请查看对比其它框架。</p>\n<h1>起步</h1>\n<blockquote>\n<p>官方指南假设你已了解关于 HTML、CSS 和 JavaScript 的中级知识。如果你刚开始学习前端开发，将框架作为你的第一步可能不是最好的主意——掌握好基础知识再来吧！之前有其它框架的使用经验会有帮助，但这不是必需的。</p>\n</blockquote>\n<p>尝试 Vue.js 最简单的方法是使用 JSFiddle 上的 Hello World 例子。你可以在浏览器新标签页中打开它，跟着例子学习一些基础用法。或者你也可以创建一个 .html 文件，然后通过如下方式引入 Vue：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">&lt;script src=<span class=\"hljs-string\">\"https://cdn.jsdelivr.net/npm/vue\"</span>&gt;<span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n\n</code></div></pre>\n<p>安装教程给出了更多安装 Vue 的方式。请注意我们不推荐新手直接使用 vue-cli，尤其是在你还不熟悉基于 Node.js 的构建工具时。</p>\n<h1>声明式渲染</h1>\n<p>Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">&lt;div id=<span class=\"hljs-string\">\"app\"</span>&gt;\n  {{ message }}\n&lt;<span class=\"hljs-regexp\">/div&gt;\n\n</span></code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">var</span> app = <span class=\"hljs-keyword\">new</span> Vue({\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">\'#app\'</span>,\n  <span class=\"hljs-attr\">data</span>: {\n    <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">\'Hello Vue!\'</span>\n  }\n})\n\n</code></div></pre>\n<p>我们已经成功创建了第一个 Vue 应用！看起来这跟渲染一个字符串模板非常类似，但是 Vue 在背后做了大量工作。现在数据和 DOM 已经被建立了关联，所有东西都是响应式的。我们要怎么确认呢？打开你的浏览器的 JavaScript 控制台 (就在这个页面打开)，并修改 app.message 的值，你将看到上例相应地更新。</p>\n<p>除了文本插值，我们还可以像这样来绑定元素特性：</p>\n',9),(21,'## 快速上手\n\n本节将介绍如何在项目中使用 Element。\n\n### 使用 Starter Kit\n我们提供了通用的项目模板，你可以直接使用。对于 Laravel 用户，我们也准备了相应的模板，同样可以直接下载使用。\n\n如果不希望使用我们提供的模板，请继续阅读。\n\n### 使用 vue-cli\n\n我们还可以使用 vue-cli 初始化项目，命令如下：\n\n```language\n> npm i -g vue-cli\n> mkdir my-project && cd my-project\n> vue init webpack\n> npm i && npm i element-ui\n```\n\n### 引入 Element\n你可以引入整个 Element，或是根据需要仅引入部分组件。我们先介绍如何引入完整的 Element。\n\n#### 完整引入\n在 main.js 中写入以下内容：\n```javascript\nimport Vue from \'vue\'\nimport ElementUI from \'element-ui\'\nimport \'element-ui/lib/theme-chalk/index.css\'\nimport App from \'./App.vue\'\n\nVue.use(ElementUI)\n\nnew Vue({\n  el: \'#app\',\n  render: h => h(App)\n})\n\n```\n以上代码便完成了 Element 的引入。需要注意的是，样式文件需要单独引入。\n\n#### 按需引入\n借助 babel-plugin-component，我们可以只引入需要的组件，以达到减小项目体积的目的。\n\n首先，安装 babel-plugin-component：\n\n','<h2>快速上手</h2>\n<p>本节将介绍如何在项目中使用 Element。</p>\n<h3>使用 Starter Kit</h3>\n<p>我们提供了通用的项目模板，你可以直接使用。对于 Laravel 用户，我们也准备了相应的模板，同样可以直接下载使用。</p>\n<p>如果不希望使用我们提供的模板，请继续阅读。</p>\n<h3>使用 vue-cli</h3>\n<p>我们还可以使用 vue-cli 初始化项目，命令如下：</p>\n<pre><code class=\"lang-language\">&gt; npm i -g vue-cli\n&gt; mkdir my-project &amp;&amp; cd my-project\n&gt; vue init webpack\n&gt; npm i &amp;&amp; npm i element-ui\n</code></pre>\n<h3>引入 Element</h3>\n<p>你可以引入整个 Element，或是根据需要仅引入部分组件。我们先介绍如何引入完整的 Element。</p>\n<h4>完整引入</h4>\n<p>在 main.js 中写入以下内容：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'vue\'</span>\n<span class=\"hljs-keyword\">import</span> ElementUI <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'element-ui\'</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">\'element-ui/lib/theme-chalk/index.css\'</span>\n<span class=\"hljs-keyword\">import</span> App <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'./App.vue\'</span>\n\nVue.use(ElementUI)\n\n<span class=\"hljs-keyword\">new</span> Vue({\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">\'#app\'</span>,\n  <span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">h</span> =&gt;</span> h(App)\n})\n\n</code></div></pre>\n<p>以上代码便完成了 Element 的引入。需要注意的是，样式文件需要单独引入。</p>\n<h4>按需引入</h4>\n<p>借助 babel-plugin-component，我们可以只引入需要的组件，以达到减小项目体积的目的。</p>\n<p>首先，安装 babel-plugin-component：</p>\n',10),(1405564731351162882,'666666666666','<p>666666666666</p>\n',1405564731300831233),(1405909844828909569,'# 1. Spring Boot介绍\n\n## 1.1 简介\n\n在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？\n\n在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？\n\n那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！\n\nSpring Boot让我们的Spring应用变的更轻量化。\n\n我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。\n\n通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\n\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。\n\n**总结一下Spring Boot的主要优点：**\n\n1. 为所有Spring开发者更快的入门\n2. 开箱即用，提供各种默认配置来简化项目配置\n3. 内嵌式容器简化Web项目\n4. 没有冗余代码生成和XML配置的要求\n5. 统一的依赖管理\n6. 自动装配，更易使用，更易扩展\n\n## 1.2 使用版本说明\n\nSpringboot版本：使用最新的2.5.0版本\n\n教程参考了官方文档进行制作，权威。\n\n其他依赖版本：\n\n	1. Maven  需求：3.5+\n\n   	2. JDK 需求  8+\n   	3. Spring Framework 5.3.7以上版本\n   	4. Tomcat 9.0\n   	5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n\n# 2. 快速入门\n\n快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。\n\n教程使用的Idea版本：2019.3\n\n## 2.1 创建基础项目\n\n**第一步：** 创建maven项目\n\npom.xml :\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.xiaopizhu</groupId>\n    <artifactId>helloSpringBoot</artifactId>\n    <version>1.0-SNAPSHOT</version>\n	<!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突-->\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.0</version>\n    </parent>\n</project>\n~~~\n\n注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。\n\n此时的工程结构为：\n\n![image20210523173241557.png](https://static.mszlu.com/6fc39758-0db2-431d-9f94-a705aa2c7e59.png)\n\n**第二步：** 添加web依赖\n\n~~~xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n~~~\n\n添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。\n\n**第三步：** 编写启动类\n\n~~~java\npackage com.xiaopizhu.springboot;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloApp {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n~~~\n\n@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。\n\n**第四步：** 运行启动类的main方法\n\n![image-20210523173712142](img/image-20210523173712142.png)\n\n看到如上配置，证明启动成功，tomcat端口号默认为8080。\n\n**第五步：**  如果想要修改端口号，可以在resources目录下新建application.properties\n\n~~~properties\nserver.port=8082\n~~~\n\n**第六步：** 重新运行\n\n![image-20210523174011613](img/image-20210523174011613.png)\n\n此时的项目结构为：\n\n![image-20210523174032053](img/image-20210523174032053.png)\n\n**src/main/java :**  编写java代码，注意启动类需要放在项目的根包下。\n\n**src/main/resources:**  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。\n\n**src/test/java:**  测试代码\n\n## 2.2 编写一个Http接口\n\n**第一步：**  创建`HelloController`类，内容如下：\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"hello\")\npublic class HelloController {\n\n    @GetMapping(\"boot\")\n    public String hello(){\n        return \"hello spring boot\";\n    }\n\n}\n\n~~~\n\n**注意包名，必须在启动类所在的包名下。**\n\n**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.3 编写单元测试用例\n\n**第一步： ** 添加spring boot测试依赖\n\n~~~xml\n		<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n~~~\n\n**第二步：** 在src/test 下，编写测试用例\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.http.MediaType;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@SpringBootTest\npublic class TestHelloController {\n\n    private MockMvc mockMvc;\n\n    @BeforeEach\n    public void beforeEach(){\n        mockMvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\n    }\n    @Test\n    public void testHello() throws Exception {\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/hello/boot\")\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(\"hello spring boot\")));\n    }\n}\n\n~~~\n\n上面的测试用例，是构建一个空的`WebApplicationContext`，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。\n\n## 2.4 打包为jar运行\n\n**第一步：** 添加打包(maven构建springboot)插件\n\n~~~xml\n  <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n~~~\n\n在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar\n\n![image-20210523181737720](img/image-20210523181737720.png)\n\n**第二步： ** 打开cmd：找到jar对应的目录\n\n输入命令\n\n~~~shell\njava -jar helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n![image-20210523182426404](img/image-20210523182426404.png)\n\n**第三步：**  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.5 查看jar包内容\n\n~~~shell\njar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n# 3. 小结\n\n1. 通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。\n2. 通过修改配置文件，更改端口号\n3. 编写了测试用例\n4. 打包jar包运行\n\n','<h1><a id=\"1_Spring_Boot_0\"></a>1. Spring Boot介绍</h1>\n<h2><a id=\"11__2\"></a>1.1 简介</h2>\n<p>在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？</p>\n<p>在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？</p>\n<p>那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！</p>\n<p>Spring Boot让我们的Spring应用变的更轻量化。</p>\n<p>我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。</p>\n<p>通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过<code>java -jar</code>命令就可以运行起来。</p>\n<p>这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。</p>\n<p><strong>总结一下Spring Boot的主要优点：</strong></p>\n<ol>\n<li>为所有Spring开发者更快的入门</li>\n<li>开箱即用，提供各种默认配置来简化项目配置</li>\n<li>内嵌式容器简化Web项目</li>\n<li>没有冗余代码生成和XML配置的要求</li>\n<li>统一的依赖管理</li>\n<li>自动装配，更易使用，更易扩展</li>\n</ol>\n<h2><a id=\"12__27\"></a>1.2 使用版本说明</h2>\n<p>Springboot版本：使用最新的2.5.0版本</p>\n<p>教程参考了官方文档进行制作，权威。</p>\n<p>其他依赖版本：</p>\n<pre><code>1. Maven  需求：3.5+\n\n2. JDK 需求  8+\n3. Spring Framework 5.3.7以上版本\n4. Tomcat 9.0\n5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n</code></pre>\n<h1><a id=\"2__42\"></a>2. 快速入门</h1>\n<p>快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。</p>\n<p>教程使用的Idea版本：2019.3</p>\n<h2><a id=\"21__48\"></a>2.1 创建基础项目</h2>\n<p><strong>第一步：</strong> 创建maven项目</p>\n<p>pom.xml :</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span>\n         <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n         <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.xiaopizhu<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>helloSpringBoot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.5.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span>\n</code></div></pre>\n<p>注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。</p>\n<p>此时的工程结构为：</p>\n<p><img src=\"https://static.mszlu.com/6fc39758-0db2-431d-9f94-a705aa2c7e59.png\" alt=\"image20210523173241557.png\" /></p>\n<p><strong>第二步：</strong> 添加web依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n</code></div></pre>\n<p>添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。</p>\n<p><strong>第三步：</strong> 编写启动类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloApp</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n</code></div></pre>\n<p>@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。</p>\n<p><strong>第四步：</strong> 运行启动类的main方法</p>\n<p><img src=\"img/image-20210523173712142.png\" alt=\"image-20210523173712142\" /></p>\n<p>看到如上配置，证明启动成功，tomcat端口号默认为8080。</p>\n<p><strong>第五步：</strong>  如果想要修改端口号，可以在resources目录下新建application.properties</p>\n<pre><code class=\"lang-properties\">server.port=8082\n</code></pre>\n<p><strong>第六步：</strong> 重新运行</p>\n<p><img src=\"img/image-20210523174011613.png\" alt=\"image-20210523174011613\" /></p>\n<p>此时的项目结构为：</p>\n<p><img src=\"img/image-20210523174032053.png\" alt=\"image-20210523174032053\" /></p>\n<p><strong>src/main/java :</strong>  编写java代码，注意启动类需要放在项目的根包下。</p>\n<p><strong>src/main/resources:</strong>  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。</p>\n<p><strong>src/test/java:</strong>  测试代码</p>\n<h2><a id=\"22_Http_138\"></a>2.2 编写一个Http接口</h2>\n<p><strong>第一步：</strong>  创建<code>HelloController</code>类，内容如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RestController;\n\n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"hello\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloController</span> </span>{\n\n    <span class=\"hljs-meta\">@GetMapping</span>(<span class=\"hljs-string\">\"boot\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">hello</span><span class=\"hljs-params\">()</span></span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello spring boot\"</span>;\n    }\n\n}\n\n</code></div></pre>\n<p><strong>注意包名，必须在启动类所在的包名下。</strong></p>\n<p>**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"23__168\"></a>2.3 编写单元测试用例</h2>\n<p>**第一步： ** 添加spring boot测试依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<p><strong>第二步：</strong> 在src/test 下，编写测试用例</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeAll;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeEach;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.Test;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.test.context.SpringBootTest;\n<span class=\"hljs-keyword\">import</span> org.springframework.http.MediaType;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.MockMvc;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.hamcrest.Matchers.equalTo;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n<span class=\"hljs-meta\">@SpringBootTest</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestHelloController</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> MockMvc mockMvc;\n\n    <span class=\"hljs-meta\">@BeforeEach</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">beforeEach</span><span class=\"hljs-params\">()</span></span>{\n        mockMvc = MockMvcBuilders.standaloneSetup(<span class=\"hljs-keyword\">new</span> HelloController()).build();\n    }\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testHello</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        mockMvc.perform(MockMvcRequestBuilders.get(<span class=\"hljs-string\">\"/hello/boot\"</span>)\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(<span class=\"hljs-string\">\"hello spring boot\"</span>)));\n    }\n}\n\n</code></div></pre>\n<p>上面的测试用例，是构建一个空的<code>WebApplicationContext</code>，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。</p>\n<h2><a id=\"24_jar_220\"></a>2.4 打包为jar运行</h2>\n<p><strong>第一步：</strong> 添加打包(maven构建springboot)插件</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n</code></div></pre>\n<p>在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar</p>\n<p><img src=\"img/image-20210523181737720.png\" alt=\"image-20210523181737720\" /></p>\n<p>**第二步： ** 打开cmd：找到jar对应的目录</p>\n<p>输入命令</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">java -jar helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<p><img src=\"img/image-20210523182426404.png\" alt=\"image-20210523182426404\" /></p>\n<p><strong>第三步：</strong>  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"25_jar_253\"></a>2.5 查看jar包内容</h2>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">jar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<h1><a id=\"3__259\"></a>3. 小结</h1>\n<ol>\n<li>通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。</li>\n<li>通过修改配置文件，更改端口号</li>\n<li>编写了测试用例</li>\n<li>打包jar包运行</li>\n</ol>\n',1405909844724051969),(1405916999854342146,'# 1. Spring Boot介绍\n\n## 1.1 简介\n\n在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？\n\n在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？\n\n那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！\n\nSpring Boot让我们的Spring应用变的更轻量化。\n\n我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。\n\n通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\n\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。\n\n**总结一下Spring Boot的主要优点：**\n\n1. 为所有Spring开发者更快的入门\n2. 开箱即用，提供各种默认配置来简化项目配置\n3. 内嵌式容器简化Web项目\n4. 没有冗余代码生成和XML配置的要求\n5. 统一的依赖管理\n6. 自动装配，更易使用，更易扩展\n\n## 1.2 使用版本说明\n\nSpringboot版本：使用最新的2.5.0版本\n\n教程参考了官方文档进行制作，权威。\n\n其他依赖版本：\n\n	1. Maven  需求：3.5+\n\n   	2. JDK 需求  8+\n   	3. Spring Framework 5.3.7以上版本\n   	4. Tomcat 9.0\n   	5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n\n# 2. 快速入门\n\n快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。\n\n教程使用的Idea版本：2019.3\n\n## 2.1 创建基础项目\n\n**第一步：** 创建maven项目\n\npom.xml :\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.xiaopizhu</groupId>\n    <artifactId>helloSpringBoot</artifactId>\n    <version>1.0-SNAPSHOT</version>\n	<!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突-->\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.0</version>\n    </parent>\n</project>\n~~~\n\n注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。\n\n此时的工程结构为：\n\n![image20210523173241557.png](https://static.mszlu.com/a7302c88-e106-46ad-9713-dc9a6d523957.png)\n\n**第二步：** 添加web依赖\n\n~~~xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n~~~\n\n添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。\n\n**第三步：** 编写启动类\n\n~~~java\npackage com.xiaopizhu.springboot;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloApp {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n~~~\n\n@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。\n\n**第四步：** 运行启动类的main方法\n\n![image20210523173712142.png](https://static.mszlu.com/dc17b43e-08df-46b0-bb7a-eb73044de7da.png)\n\n看到如上配置，证明启动成功，tomcat端口号默认为8080。\n\n**第五步：**  如果想要修改端口号，可以在resources目录下新建application.properties\n\n~~~properties\nserver.port=8082\n~~~\n\n**第六步：** 重新运行\n\n![image20210523174011613.png](https://static.mszlu.com/318e4b7e-95d2-4e43-a18f-279ea6ff9495.png)\n\n此时的项目结构为：\n\n![image20210523174032053.png](https://static.mszlu.com/756e4ae0-c4c7-43a5-9b5d-bc7ce974a942.png)\n\n**src/main/java :**  编写java代码，注意启动类需要放在项目的根包下。\n\n**src/main/resources:**  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。\n\n**src/test/java:**  测试代码\n\n## 2.2 编写一个Http接口\n\n**第一步：**  创建`HelloController`类，内容如下：\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"hello\")\npublic class HelloController {\n\n    @GetMapping(\"boot\")\n    public String hello(){\n        return \"hello spring boot\";\n    }\n\n}\n\n~~~\n\n**注意包名，必须在启动类所在的包名下。**\n\n**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.3 编写单元测试用例\n\n**第一步： ** 添加spring boot测试依赖\n\n~~~xml\n		<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n~~~\n\n**第二步：** 在src/test 下，编写测试用例\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.http.MediaType;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@SpringBootTest\npublic class TestHelloController {\n\n    private MockMvc mockMvc;\n\n    @BeforeEach\n    public void beforeEach(){\n        mockMvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\n    }\n    @Test\n    public void testHello() throws Exception {\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/hello/boot\")\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(\"hello spring boot\")));\n    }\n}\n\n~~~\n\n上面的测试用例，是构建一个空的`WebApplicationContext`，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。\n\n## 2.4 打包为jar运行\n\n**第一步：** 添加打包(maven构建springboot)插件\n\n~~~xml\n  <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n~~~\n\n在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar\n\n![image20210523181737720.png](https://static.mszlu.com/45aa0db2-598f-4564-964c-a2d889dfbafe.png)\n\n**第二步： ** 打开cmd：找到jar对应的目录\n\n输入命令\n\n~~~shell\njava -jar helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n![image20210523182426404.png](https://static.mszlu.com/74376f77-b8eb-4c2c-a4cc-d3bfe24901e3.png)\n\n**第三步：**  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.5 查看jar包内容\n\n~~~shell\njar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n# 3. 小结\n\n1. 通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。\n2. 通过修改配置文件，更改端口号\n3. 编写了测试用例\n4. 打包jar包运行\n\n','<h1><a id=\"1_Spring_Boot_0\"></a>1. Spring Boot介绍</h1>\n<h2><a id=\"11__2\"></a>1.1 简介</h2>\n<p>在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？</p>\n<p>在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？</p>\n<p>那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！</p>\n<p>Spring Boot让我们的Spring应用变的更轻量化。</p>\n<p>我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。</p>\n<p>通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过<code>java -jar</code>命令就可以运行起来。</p>\n<p>这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。</p>\n<p><strong>总结一下Spring Boot的主要优点：</strong></p>\n<ol>\n<li>为所有Spring开发者更快的入门</li>\n<li>开箱即用，提供各种默认配置来简化项目配置</li>\n<li>内嵌式容器简化Web项目</li>\n<li>没有冗余代码生成和XML配置的要求</li>\n<li>统一的依赖管理</li>\n<li>自动装配，更易使用，更易扩展</li>\n</ol>\n<h2><a id=\"12__27\"></a>1.2 使用版本说明</h2>\n<p>Springboot版本：使用最新的2.5.0版本</p>\n<p>教程参考了官方文档进行制作，权威。</p>\n<p>其他依赖版本：</p>\n<pre><code>1. Maven  需求：3.5+\n\n2. JDK 需求  8+\n3. Spring Framework 5.3.7以上版本\n4. Tomcat 9.0\n5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n</code></pre>\n<h1><a id=\"2__42\"></a>2. 快速入门</h1>\n<p>快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。</p>\n<p>教程使用的Idea版本：2019.3</p>\n<h2><a id=\"21__48\"></a>2.1 创建基础项目</h2>\n<p><strong>第一步：</strong> 创建maven项目</p>\n<p>pom.xml :</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span>\n         <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n         <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.xiaopizhu<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>helloSpringBoot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.5.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span>\n</code></div></pre>\n<p>注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。</p>\n<p>此时的工程结构为：</p>\n<p><img src=\"https://static.mszlu.com/a7302c88-e106-46ad-9713-dc9a6d523957.png\" alt=\"image20210523173241557.png\" /></p>\n<p><strong>第二步：</strong> 添加web依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n</code></div></pre>\n<p>添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。</p>\n<p><strong>第三步：</strong> 编写启动类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloApp</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n</code></div></pre>\n<p>@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。</p>\n<p><strong>第四步：</strong> 运行启动类的main方法</p>\n<p><img src=\"https://static.mszlu.com/dc17b43e-08df-46b0-bb7a-eb73044de7da.png\" alt=\"image20210523173712142.png\" /></p>\n<p>看到如上配置，证明启动成功，tomcat端口号默认为8080。</p>\n<p><strong>第五步：</strong>  如果想要修改端口号，可以在resources目录下新建application.properties</p>\n<pre><code class=\"lang-properties\">server.port=8082\n</code></pre>\n<p><strong>第六步：</strong> 重新运行</p>\n<p><img src=\"https://static.mszlu.com/318e4b7e-95d2-4e43-a18f-279ea6ff9495.png\" alt=\"image20210523174011613.png\" /></p>\n<p>此时的项目结构为：</p>\n<p><img src=\"https://static.mszlu.com/756e4ae0-c4c7-43a5-9b5d-bc7ce974a942.png\" alt=\"image20210523174032053.png\" /></p>\n<p><strong>src/main/java :</strong>  编写java代码，注意启动类需要放在项目的根包下。</p>\n<p><strong>src/main/resources:</strong>  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。</p>\n<p><strong>src/test/java:</strong>  测试代码</p>\n<h2><a id=\"22_Http_138\"></a>2.2 编写一个Http接口</h2>\n<p><strong>第一步：</strong>  创建<code>HelloController</code>类，内容如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RestController;\n\n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"hello\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloController</span> </span>{\n\n    <span class=\"hljs-meta\">@GetMapping</span>(<span class=\"hljs-string\">\"boot\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">hello</span><span class=\"hljs-params\">()</span></span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello spring boot\"</span>;\n    }\n\n}\n\n</code></div></pre>\n<p><strong>注意包名，必须在启动类所在的包名下。</strong></p>\n<p>**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"23__168\"></a>2.3 编写单元测试用例</h2>\n<p>**第一步： ** 添加spring boot测试依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<p><strong>第二步：</strong> 在src/test 下，编写测试用例</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeAll;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeEach;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.Test;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.test.context.SpringBootTest;\n<span class=\"hljs-keyword\">import</span> org.springframework.http.MediaType;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.MockMvc;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.hamcrest.Matchers.equalTo;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n<span class=\"hljs-meta\">@SpringBootTest</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestHelloController</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> MockMvc mockMvc;\n\n    <span class=\"hljs-meta\">@BeforeEach</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">beforeEach</span><span class=\"hljs-params\">()</span></span>{\n        mockMvc = MockMvcBuilders.standaloneSetup(<span class=\"hljs-keyword\">new</span> HelloController()).build();\n    }\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testHello</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        mockMvc.perform(MockMvcRequestBuilders.get(<span class=\"hljs-string\">\"/hello/boot\"</span>)\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(<span class=\"hljs-string\">\"hello spring boot\"</span>)));\n    }\n}\n\n</code></div></pre>\n<p>上面的测试用例，是构建一个空的<code>WebApplicationContext</code>，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。</p>\n<h2><a id=\"24_jar_220\"></a>2.4 打包为jar运行</h2>\n<p><strong>第一步：</strong> 添加打包(maven构建springboot)插件</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n</code></div></pre>\n<p>在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar</p>\n<p><img src=\"https://static.mszlu.com/45aa0db2-598f-4564-964c-a2d889dfbafe.png\" alt=\"image20210523181737720.png\" /></p>\n<p>**第二步： ** 打开cmd：找到jar对应的目录</p>\n<p>输入命令</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">java -jar helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<p><img src=\"https://static.mszlu.com/74376f77-b8eb-4c2c-a4cc-d3bfe24901e3.png\" alt=\"image20210523182426404.png\" /></p>\n<p><strong>第三步：</strong>  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"25_jar_253\"></a>2.5 查看jar包内容</h2>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">jar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<h1><a id=\"3__259\"></a>3. 小结</h1>\n<ol>\n<li>通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。</li>\n<li>通过修改配置文件，更改端口号</li>\n<li>编写了测试用例</li>\n<li>打包jar包运行</li>\n</ol>\n',1405916999732707330),(1520666874749591554,'# Aguo是大帅锅\n# 春莹是大镁铝','<h1><a id=\"Aguo_0\"></a>Aguo是大帅锅</h1>\n<h1><a id=\"_1\"></a>春莹是大镁铝</h1>\n',1405916999732707331),(1520670952124760065,'1','<p>1</p>\n',1405916999732707332),(1520671011784540161,'1','<p>1</p>\n',1405916999732707333),(1520671371022483458,'1','<p>1</p>\n',1405916999732707334),(1520673757912776705,'1','<p>1</p>\n',1405916999732707335),(1520673840867721217,'1','<p>1</p>\n',1405916999732707336),(1521016788960604161,'22','<p>22</p>\n',1405916999732707337),(1521016959748468739,'44','<p>44</p>\n',1405916999732707338),(1521531789232214019,'999999999999999999','<p>999999999999999999</p>\n',1405916999732707339),(1521532209774104577,'1','<p>1</p>\n',1405916999732707340),(1521547800316608513,'qqqqqqqqqqq','<p>qqqqqqqqqqq</p>\n',1405916999732707341),(1521548406699798530,'``','<p>``</p>\n',1405916999732707342),(1521548809281654786,'!','<p>!</p>\n',1405916999732707343),(1521549624197144579,'## aaa','<h2><a id=\"aaa_0\"></a>aaa</h2>\n',1405916999732707344),(1521553654126358530,'a','<p>a</p>\n',1405916999732707345),(1521557831288283138,'#3333','<p>#3333</p>\n',1405916999732707346),(1521769787794284545,'# 1. Spring Boot介绍\n\n## 1.1 简介\n\n在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？\n\n在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？\n\n那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！\n\nSpring Boot让我们的Spring应用变的更轻量化。\n\n我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。\n\n通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\n\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。\n\n**总结一下Spring Boot的主要优点：**\n\n1. 为所有Spring开发者更快的入门\n2. 开箱即用，提供各种默认配置来简化项目配置\n3. 内嵌式容器简化Web项目\n4. 没有冗余代码生成和XML配置的要求\n5. 统一的依赖管理\n6. 自动装配，更易使用，更易扩展\n\n## 1.2 使用版本说明\n\nSpringboot版本：使用最新的2.5.0版本\n\n教程参考了官方文档进行制作，权威。\n\n其他依赖版本：\n\n	1. Maven  需求：3.5+\n\n   	2. JDK 需求  8+\n   	3. Spring Framework 5.3.7以上版本\n   	4. Tomcat 9.0\n   	5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n\n# 2. 快速入门\n\n快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。\n\n教程使用的Idea版本：2019.3\n\n## 2.1 创建基础项目\n\n**第一步：** 创建maven项目\n\npom.xml :\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.xiaopizhu</groupId>\n    <artifactId>helloSpringBoot</artifactId>\n    <version>1.0-SNAPSHOT</version>\n	<!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突-->\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.0</version>\n    </parent>\n</project>\n~~~\n\n注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。\n\n此时的工程结构为：\n\n![image20210523173241557.png](https://static.mszlu.com/a7302c88-e106-46ad-9713-dc9a6d523957.png)\n\n**第二步：** 添加web依赖\n\n~~~xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n~~~\n\n添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。\n\n**第三步：** 编写启动类\n\n~~~java\npackage com.xiaopizhu.springboot;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloApp {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n~~~\n\n@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。\n\n**第四步：** 运行启动类的main方法\n\n![image20210523173712142.png](https://static.mszlu.com/dc17b43e-08df-46b0-bb7a-eb73044de7da.png)\n\n看到如上配置，证明启动成功，tomcat端口号默认为8080。\n\n**第五步：**  如果想要修改端口号，可以在resources目录下新建application.properties\n\n~~~properties\nserver.port=8082\n~~~\n\n**第六步：** 重新运行\n\n![image20210523174011613.png](https://static.mszlu.com/318e4b7e-95d2-4e43-a18f-279ea6ff9495.png)\n\n此时的项目结构为：\n\n![image20210523174032053.png](https://static.mszlu.com/756e4ae0-c4c7-43a5-9b5d-bc7ce974a942.png)\n\n**src/main/java :**  编写java代码，注意启动类需要放在项目的根包下。\n\n**src/main/resources:**  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。\n\n**src/test/java:**  测试代码\n\n## 2.2 编写一个Http接口\n\n**第一步：**  创建`HelloController`类，内容如下：\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"hello\")\npublic class HelloController {\n\n    @GetMapping(\"boot\")\n    public String hello(){\n        return \"hello spring boot\";\n    }\n\n}\n\n~~~\n\n**注意包名，必须在启动类所在的包名下。**\n\n**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.3 编写单元测试用例\n\n**第一步： ** 添加spring boot测试依赖\n\n~~~xml\n		<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n~~~\n\n**第二步：** 在src/test 下，编写测试用例\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.http.MediaType;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@SpringBootTest\npublic class TestHelloController {\n\n    private MockMvc mockMvc;\n\n    @BeforeEach\n    public void beforeEach(){\n        mockMvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\n    }\n    @Test\n    public void testHello() throws Exception {\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/hello/boot\")\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(\"hello spring boot\")));\n    }\n}\n\n~~~\n\n上面的测试用例，是构建一个空的`WebApplicationContext`，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。\n\n## 2.4 打包为jar运行\n\n**第一步：** 添加打包(maven构建springboot)插件\n\n~~~xml\n  <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n~~~\n\n在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar\n\n![image20210523181737720.png](https://static.mszlu.com/45aa0db2-598f-4564-964c-a2d889dfbafe.png)\n\n**第二步： ** 打开cmd：找到jar对应的目录\n\n输入命令\n\n~~~shell\njava -jar helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n![image20210523182426404.png](https://static.mszlu.com/74376f77-b8eb-4c2c-a4cc-d3bfe24901e3.png)\n\n**第三步：**  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.5 查看jar包内容\n\n~~~shell\njar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n# 3. 小结\n\n1. 通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。\n2. 通过修改配置文件，更改端口号\n3. 编写了测试用例\n4. 打包jar包运行\n\n','<h1><a id=\"1_Spring_Boot_0\"></a>1. Spring Boot介绍</h1>\n<h2><a id=\"11__2\"></a>1.1 简介</h2>\n<p>在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？</p>\n<p>在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？</p>\n<p>那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！</p>\n<p>Spring Boot让我们的Spring应用变的更轻量化。</p>\n<p>我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。</p>\n<p>通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过<code>java -jar</code>命令就可以运行起来。</p>\n<p>这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。</p>\n<p><strong>总结一下Spring Boot的主要优点：</strong></p>\n<ol>\n<li>为所有Spring开发者更快的入门</li>\n<li>开箱即用，提供各种默认配置来简化项目配置</li>\n<li>内嵌式容器简化Web项目</li>\n<li>没有冗余代码生成和XML配置的要求</li>\n<li>统一的依赖管理</li>\n<li>自动装配，更易使用，更易扩展</li>\n</ol>\n<h2><a id=\"12__27\"></a>1.2 使用版本说明</h2>\n<p>Springboot版本：使用最新的2.5.0版本</p>\n<p>教程参考了官方文档进行制作，权威。</p>\n<p>其他依赖版本：</p>\n<pre><code>1. Maven  需求：3.5+\n\n2. JDK 需求  8+\n3. Spring Framework 5.3.7以上版本\n4. Tomcat 9.0\n5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n</code></pre>\n<h1><a id=\"2__42\"></a>2. 快速入门</h1>\n<p>快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。</p>\n<p>教程使用的Idea版本：2019.3</p>\n<h2><a id=\"21__48\"></a>2.1 创建基础项目</h2>\n<p><strong>第一步：</strong> 创建maven项目</p>\n<p>pom.xml :</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span>\n         <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n         <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.xiaopizhu<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>helloSpringBoot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.5.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span>\n</code></div></pre>\n<p>注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。</p>\n<p>此时的工程结构为：</p>\n<p><img src=\"https://static.mszlu.com/a7302c88-e106-46ad-9713-dc9a6d523957.png\" alt=\"image20210523173241557.png\" /></p>\n<p><strong>第二步：</strong> 添加web依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n</code></div></pre>\n<p>添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。</p>\n<p><strong>第三步：</strong> 编写启动类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloApp</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n</code></div></pre>\n<p>@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。</p>\n<p><strong>第四步：</strong> 运行启动类的main方法</p>\n<p><img src=\"https://static.mszlu.com/dc17b43e-08df-46b0-bb7a-eb73044de7da.png\" alt=\"image20210523173712142.png\" /></p>\n<p>看到如上配置，证明启动成功，tomcat端口号默认为8080。</p>\n<p><strong>第五步：</strong>  如果想要修改端口号，可以在resources目录下新建application.properties</p>\n<pre><code class=\"lang-properties\">server.port=8082\n</code></pre>\n<p><strong>第六步：</strong> 重新运行</p>\n<p><img src=\"https://static.mszlu.com/318e4b7e-95d2-4e43-a18f-279ea6ff9495.png\" alt=\"image20210523174011613.png\" /></p>\n<p>此时的项目结构为：</p>\n<p><img src=\"https://static.mszlu.com/756e4ae0-c4c7-43a5-9b5d-bc7ce974a942.png\" alt=\"image20210523174032053.png\" /></p>\n<p><strong>src/main/java :</strong>  编写java代码，注意启动类需要放在项目的根包下。</p>\n<p><strong>src/main/resources:</strong>  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。</p>\n<p><strong>src/test/java:</strong>  测试代码</p>\n<h2><a id=\"22_Http_138\"></a>2.2 编写一个Http接口</h2>\n<p><strong>第一步：</strong>  创建<code>HelloController</code>类，内容如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RestController;\n\n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"hello\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloController</span> </span>{\n\n    <span class=\"hljs-meta\">@GetMapping</span>(<span class=\"hljs-string\">\"boot\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">hello</span><span class=\"hljs-params\">()</span></span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello spring boot\"</span>;\n    }\n\n}\n\n</code></div></pre>\n<p><strong>注意包名，必须在启动类所在的包名下。</strong></p>\n<p>**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"23__168\"></a>2.3 编写单元测试用例</h2>\n<p>**第一步： ** 添加spring boot测试依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<p><strong>第二步：</strong> 在src/test 下，编写测试用例</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeAll;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeEach;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.Test;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.test.context.SpringBootTest;\n<span class=\"hljs-keyword\">import</span> org.springframework.http.MediaType;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.MockMvc;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.hamcrest.Matchers.equalTo;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n<span class=\"hljs-meta\">@SpringBootTest</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestHelloController</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> MockMvc mockMvc;\n\n    <span class=\"hljs-meta\">@BeforeEach</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">beforeEach</span><span class=\"hljs-params\">()</span></span>{\n        mockMvc = MockMvcBuilders.standaloneSetup(<span class=\"hljs-keyword\">new</span> HelloController()).build();\n    }\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testHello</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        mockMvc.perform(MockMvcRequestBuilders.get(<span class=\"hljs-string\">\"/hello/boot\"</span>)\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(<span class=\"hljs-string\">\"hello spring boot\"</span>)));\n    }\n}\n\n</code></div></pre>\n<p>上面的测试用例，是构建一个空的<code>WebApplicationContext</code>，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。</p>\n<h2><a id=\"24_jar_220\"></a>2.4 打包为jar运行</h2>\n<p><strong>第一步：</strong> 添加打包(maven构建springboot)插件</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n</code></div></pre>\n<p>在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar</p>\n<p><img src=\"https://static.mszlu.com/45aa0db2-598f-4564-964c-a2d889dfbafe.png\" alt=\"image20210523181737720.png\" /></p>\n<p>**第二步： ** 打开cmd：找到jar对应的目录</p>\n<p>输入命令</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">java -jar helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<p><img src=\"https://static.mszlu.com/74376f77-b8eb-4c2c-a4cc-d3bfe24901e3.png\" alt=\"image20210523182426404.png\" /></p>\n<p><strong>第三步：</strong>  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"25_jar_253\"></a>2.5 查看jar包内容</h2>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">jar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<h1><a id=\"3__259\"></a>3. 小结</h1>\n<ol>\n<li>通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。</li>\n<li>通过修改配置文件，更改端口号</li>\n<li>编写了测试用例</li>\n<li>打包jar包运行</li>\n</ol>\n',1405916999732707347),(1521773321726119938,'# 1. Spring Boot介绍\n\n## 1.1 简介\n\n在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？\n\n在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？\n\n那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！\n\nSpring Boot让我们的Spring应用变的更轻量化。\n\n我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。\n\n通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\n\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。\n\n**总结一下Spring Boot的主要优点：**\n\n1. 为所有Spring开发者更快的入门\n2. 开箱即用，提供各种默认配置来简化项目配置\n3. 内嵌式容器简化Web项目\n4. 没有冗余代码生成和XML配置的要求\n5. 统一的依赖管理\n6. 自动装配，更易使用，更易扩展\n\n## 1.2 使用版本说明\n\nSpringboot版本：使用最新的2.5.0版本\n\n教程参考了官方文档进行制作，权威。\n\n其他依赖版本：\n\n	1. Maven  需求：3.5+\n\n   	2. JDK 需求  8+\n   	3. Spring Framework 5.3.7以上版本\n   	4. Tomcat 9.0\n   	5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n\n# 2. 快速入门\n\n快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。\n\n教程使用的Idea版本：2019.3\n\n## 2.1 创建基础项目\n\n**第一步：** 创建maven项目\n\npom.xml :\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.xiaopizhu</groupId>\n    <artifactId>helloSpringBoot</artifactId>\n    <version>1.0-SNAPSHOT</version>\n	<!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突-->\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.0</version>\n    </parent>\n</project>\n~~~\n\n注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。\n\n此时的工程结构为：\n\n![image20210523173241557.png](https://static.mszlu.com/a7302c88-e106-46ad-9713-dc9a6d523957.png)\n\n**第二步：** 添加web依赖\n\n~~~xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n~~~\n\n添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。\n\n**第三步：** 编写启动类\n\n~~~java\npackage com.xiaopizhu.springboot;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloApp {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n~~~\n\n@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。\n\n**第四步：** 运行启动类的main方法\n\n![image20210523173712142.png](https://static.mszlu.com/dc17b43e-08df-46b0-bb7a-eb73044de7da.png)\n\n看到如上配置，证明启动成功，tomcat端口号默认为8080。\n\n**第五步：**  如果想要修改端口号，可以在resources目录下新建application.properties\n\n~~~properties\nserver.port=8082\n~~~\n\n**第六步：** 重新运行\n\n![image20210523174011613.png](https://static.mszlu.com/318e4b7e-95d2-4e43-a18f-279ea6ff9495.png)\n\n此时的项目结构为：\n\n![image20210523174032053.png](https://static.mszlu.com/756e4ae0-c4c7-43a5-9b5d-bc7ce974a942.png)\n\n**src/main/java :**  编写java代码，注意启动类需要放在项目的根包下。\n\n**src/main/resources:**  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。\n\n**src/test/java:**  测试代码\n\n## 2.2 编写一个Http接口\n\n**第一步：**  创建`HelloController`类，内容如下：\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"hello\")\npublic class HelloController {\n\n    @GetMapping(\"boot\")\n    public String hello(){\n        return \"hello spring boot\";\n    }\n\n}\n\n~~~\n\n**注意包名，必须在启动类所在的包名下。**\n\n**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.3 编写单元测试用例\n\n**第一步： ** 添加spring boot测试依赖\n\n~~~xml\n		<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n~~~\n\n**第二步：** 在src/test 下，编写测试用例\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.http.MediaType;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@SpringBootTest\npublic class TestHelloController {\n\n    private MockMvc mockMvc;\n\n    @BeforeEach\n    public void beforeEach(){\n        mockMvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\n    }\n    @Test\n    public void testHello() throws Exception {\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/hello/boot\")\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(\"hello spring boot\")));\n    }\n}\n\n~~~\n\n上面的测试用例，是构建一个空的`WebApplicationContext`，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。\n\n## 2.4 打包为jar运行\n\n**第一步：** 添加打包(maven构建springboot)插件\n\n~~~xml\n  <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n~~~\n\n在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar\n\n![image20210523181737720.png](https://static.mszlu.com/45aa0db2-598f-4564-964c-a2d889dfbafe.png)\n\n**第二步： ** 打开cmd：找到jar对应的目录\n\n输入命令\n\n~~~shell\njava -jar helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n![image20210523182426404.png](https://static.mszlu.com/74376f77-b8eb-4c2c-a4cc-d3bfe24901e3.png)\n\n**第三步：**  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.5 查看jar包内容\n\n~~~shell\njar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n# 3. 小结\n\n1. 通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。\n2. 通过修改配置文件，更改端口号\n3. 编写了测试用例\n4. 打包jar包运行\n\n','<h1><a id=\"1_Spring_Boot_0\"></a>1. Spring Boot介绍</h1>\n<h2><a id=\"11__2\"></a>1.1 简介</h2>\n<p>在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？</p>\n<p>在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？</p>\n<p>那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！</p>\n<p>Spring Boot让我们的Spring应用变的更轻量化。</p>\n<p>我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。</p>\n<p>通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过<code>java -jar</code>命令就可以运行起来。</p>\n<p>这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。</p>\n<p><strong>总结一下Spring Boot的主要优点：</strong></p>\n<ol>\n<li>为所有Spring开发者更快的入门</li>\n<li>开箱即用，提供各种默认配置来简化项目配置</li>\n<li>内嵌式容器简化Web项目</li>\n<li>没有冗余代码生成和XML配置的要求</li>\n<li>统一的依赖管理</li>\n<li>自动装配，更易使用，更易扩展</li>\n</ol>\n<h2><a id=\"12__27\"></a>1.2 使用版本说明</h2>\n<p>Springboot版本：使用最新的2.5.0版本</p>\n<p>教程参考了官方文档进行制作，权威。</p>\n<p>其他依赖版本：</p>\n<pre><code>1. Maven  需求：3.5+\n\n2. JDK 需求  8+\n3. Spring Framework 5.3.7以上版本\n4. Tomcat 9.0\n5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n</code></pre>\n<h1><a id=\"2__42\"></a>2. 快速入门</h1>\n<p>快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。</p>\n<p>教程使用的Idea版本：2019.3</p>\n<h2><a id=\"21__48\"></a>2.1 创建基础项目</h2>\n<p><strong>第一步：</strong> 创建maven项目</p>\n<p>pom.xml :</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span>\n         <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n         <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.xiaopizhu<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>helloSpringBoot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.5.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span>\n</code></div></pre>\n<p>注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。</p>\n<p>此时的工程结构为：</p>\n<p><img src=\"https://static.mszlu.com/a7302c88-e106-46ad-9713-dc9a6d523957.png\" alt=\"image20210523173241557.png\" /></p>\n<p><strong>第二步：</strong> 添加web依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n</code></div></pre>\n<p>添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。</p>\n<p><strong>第三步：</strong> 编写启动类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloApp</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n</code></div></pre>\n<p>@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。</p>\n<p><strong>第四步：</strong> 运行启动类的main方法</p>\n<p><img src=\"https://static.mszlu.com/dc17b43e-08df-46b0-bb7a-eb73044de7da.png\" alt=\"image20210523173712142.png\" /></p>\n<p>看到如上配置，证明启动成功，tomcat端口号默认为8080。</p>\n<p><strong>第五步：</strong>  如果想要修改端口号，可以在resources目录下新建application.properties</p>\n<pre><code class=\"lang-properties\">server.port=8082\n</code></pre>\n<p><strong>第六步：</strong> 重新运行</p>\n<p><img src=\"https://static.mszlu.com/318e4b7e-95d2-4e43-a18f-279ea6ff9495.png\" alt=\"image20210523174011613.png\" /></p>\n<p>此时的项目结构为：</p>\n<p><img src=\"https://static.mszlu.com/756e4ae0-c4c7-43a5-9b5d-bc7ce974a942.png\" alt=\"image20210523174032053.png\" /></p>\n<p><strong>src/main/java :</strong>  编写java代码，注意启动类需要放在项目的根包下。</p>\n<p><strong>src/main/resources:</strong>  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。</p>\n<p><strong>src/test/java:</strong>  测试代码</p>\n<h2><a id=\"22_Http_138\"></a>2.2 编写一个Http接口</h2>\n<p><strong>第一步：</strong>  创建<code>HelloController</code>类，内容如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RestController;\n\n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"hello\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloController</span> </span>{\n\n    <span class=\"hljs-meta\">@GetMapping</span>(<span class=\"hljs-string\">\"boot\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">hello</span><span class=\"hljs-params\">()</span></span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello spring boot\"</span>;\n    }\n\n}\n\n</code></div></pre>\n<p><strong>注意包名，必须在启动类所在的包名下。</strong></p>\n<p>**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"23__168\"></a>2.3 编写单元测试用例</h2>\n<p>**第一步： ** 添加spring boot测试依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<p><strong>第二步：</strong> 在src/test 下，编写测试用例</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeAll;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeEach;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.Test;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.test.context.SpringBootTest;\n<span class=\"hljs-keyword\">import</span> org.springframework.http.MediaType;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.MockMvc;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.hamcrest.Matchers.equalTo;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n<span class=\"hljs-meta\">@SpringBootTest</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestHelloController</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> MockMvc mockMvc;\n\n    <span class=\"hljs-meta\">@BeforeEach</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">beforeEach</span><span class=\"hljs-params\">()</span></span>{\n        mockMvc = MockMvcBuilders.standaloneSetup(<span class=\"hljs-keyword\">new</span> HelloController()).build();\n    }\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testHello</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        mockMvc.perform(MockMvcRequestBuilders.get(<span class=\"hljs-string\">\"/hello/boot\"</span>)\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(<span class=\"hljs-string\">\"hello spring boot\"</span>)));\n    }\n}\n\n</code></div></pre>\n<p>上面的测试用例，是构建一个空的<code>WebApplicationContext</code>，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。</p>\n<h2><a id=\"24_jar_220\"></a>2.4 打包为jar运行</h2>\n<p><strong>第一步：</strong> 添加打包(maven构建springboot)插件</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n</code></div></pre>\n<p>在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar</p>\n<p><img src=\"https://static.mszlu.com/45aa0db2-598f-4564-964c-a2d889dfbafe.png\" alt=\"image20210523181737720.png\" /></p>\n<p>**第二步： ** 打开cmd：找到jar对应的目录</p>\n<p>输入命令</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">java -jar helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<p><img src=\"https://static.mszlu.com/74376f77-b8eb-4c2c-a4cc-d3bfe24901e3.png\" alt=\"image20210523182426404.png\" /></p>\n<p><strong>第三步：</strong>  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"25_jar_253\"></a>2.5 查看jar包内容</h2>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">jar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<h1><a id=\"3__259\"></a>3. 小结</h1>\n<ol>\n<li>通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。</li>\n<li>通过修改配置文件，更改端口号</li>\n<li>编写了测试用例</li>\n<li>打包jar包运行</li>\n</ol>\n',1405916999732707348),(1521774019956101121,'# 1. Spring Boot介绍\n\n## 1.1 简介\n\n在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？\n\n在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？\n\n那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！\n\nSpring Boot让我们的Spring应用变的更轻量化。\n\n我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。\n\n通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\n\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。\n\n**总结一下Spring Boot的主要优点：**\n\n1. 为所有Spring开发者更快的入门\n2. 开箱即用，提供各种默认配置来简化项目配置\n3. 内嵌式容器简化Web项目\n4. 没有冗余代码生成和XML配置的要求\n5. 统一的依赖管理\n6. 自动装配，更易使用，更易扩展\n\n## 1.2 使用版本说明\n\nSpringboot版本：使用最新的2.5.0版本\n\n教程参考了官方文档进行制作，权威。\n\n其他依赖版本：\n\n	1. Maven  需求：3.5+\n\n   	2. JDK 需求  8+\n   	3. Spring Framework 5.3.7以上版本\n   	4. Tomcat 9.0\n   	5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n\n# 2. 快速入门\n\n快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。\n\n教程使用的Idea版本：2019.3\n\n## 2.1 创建基础项目\n\n**第一步：** 创建maven项目\n\npom.xml :\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.xiaopizhu</groupId>\n    <artifactId>helloSpringBoot</artifactId>\n    <version>1.0-SNAPSHOT</version>\n	<!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突-->\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.0</version>\n    </parent>\n</project>\n~~~\n\n注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。\n\n此时的工程结构为：\n\n![image20210523173241557.png](https://static.mszlu.com/a7302c88-e106-46ad-9713-dc9a6d523957.png)\n\n**第二步：** 添加web依赖\n\n~~~xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n~~~\n\n添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。\n\n**第三步：** 编写启动类\n\n~~~java\npackage com.xiaopizhu.springboot;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloApp {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n~~~\n\n@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。\n\n**第四步：** 运行启动类的main方法\n\n![image20210523173712142.png](https://static.mszlu.com/dc17b43e-08df-46b0-bb7a-eb73044de7da.png)\n\n看到如上配置，证明启动成功，tomcat端口号默认为8080。\n\n**第五步：**  如果想要修改端口号，可以在resources目录下新建application.properties\n\n~~~properties\nserver.port=8082\n~~~\n\n**第六步：** 重新运行\n\n![image20210523174011613.png](https://static.mszlu.com/318e4b7e-95d2-4e43-a18f-279ea6ff9495.png)\n\n此时的项目结构为：\n\n![image20210523174032053.png](https://static.mszlu.com/756e4ae0-c4c7-43a5-9b5d-bc7ce974a942.png)\n\n**src/main/java :**  编写java代码，注意启动类需要放在项目的根包下。\n\n**src/main/resources:**  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。\n\n**src/test/java:**  测试代码\n\n## 2.2 编写一个Http接口\n\n**第一步：**  创建`HelloController`类，内容如下：\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"hello\")\npublic class HelloController {\n\n    @GetMapping(\"boot\")\n    public String hello(){\n        return \"hello spring boot\";\n    }\n\n}\n\n~~~\n\n**注意包名，必须在启动类所在的包名下。**\n\n**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.3 编写单元测试用例\n\n**第一步： ** 添加spring boot测试依赖\n\n~~~xml\n		<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n~~~\n\n**第二步：** 在src/test 下，编写测试用例\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.http.MediaType;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@SpringBootTest\npublic class TestHelloController {\n\n    private MockMvc mockMvc;\n\n    @BeforeEach\n    public void beforeEach(){\n        mockMvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\n    }\n    @Test\n    public void testHello() throws Exception {\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/hello/boot\")\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(\"hello spring boot\")));\n    }\n}\n\n~~~\n\n上面的测试用例，是构建一个空的`WebApplicationContext`，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。\n\n## 2.4 打包为jar运行\n\n**第一步：** 添加打包(maven构建springboot)插件\n\n~~~xml\n  <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n~~~\n\n在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar\n\n![image20210523181737720.png](https://static.mszlu.com/45aa0db2-598f-4564-964c-a2d889dfbafe.png)\n\n**第二步： ** 打开cmd：找到jar对应的目录\n\n输入命令\n\n~~~shell\njava -jar helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n![image20210523182426404.png](https://static.mszlu.com/74376f77-b8eb-4c2c-a4cc-d3bfe24901e3.png)\n\n**第三步：**  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.5 查看jar包内容\n\n~~~shell\njar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n# 3. 小结\n\n1. 通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。\n2. 通过修改配置文件，更改端口号\n3. 编写了测试用例\n4. 打包jar包运行\n\n','<h1><a id=\"1_Spring_Boot_0\"></a>1. Spring Boot介绍</h1>\n<h2><a id=\"11__2\"></a>1.1 简介</h2>\n<p>在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？</p>\n<p>在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？</p>\n<p>那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！</p>\n<p>Spring Boot让我们的Spring应用变的更轻量化。</p>\n<p>我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。</p>\n<p>通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过<code>java -jar</code>命令就可以运行起来。</p>\n<p>这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。</p>\n<p><strong>总结一下Spring Boot的主要优点：</strong></p>\n<ol>\n<li>为所有Spring开发者更快的入门</li>\n<li>开箱即用，提供各种默认配置来简化项目配置</li>\n<li>内嵌式容器简化Web项目</li>\n<li>没有冗余代码生成和XML配置的要求</li>\n<li>统一的依赖管理</li>\n<li>自动装配，更易使用，更易扩展</li>\n</ol>\n<h2><a id=\"12__27\"></a>1.2 使用版本说明</h2>\n<p>Springboot版本：使用最新的2.5.0版本</p>\n<p>教程参考了官方文档进行制作，权威。</p>\n<p>其他依赖版本：</p>\n<pre><code>1. Maven  需求：3.5+\n\n2. JDK 需求  8+\n3. Spring Framework 5.3.7以上版本\n4. Tomcat 9.0\n5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n</code></pre>\n<h1><a id=\"2__42\"></a>2. 快速入门</h1>\n<p>快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。</p>\n<p>教程使用的Idea版本：2019.3</p>\n<h2><a id=\"21__48\"></a>2.1 创建基础项目</h2>\n<p><strong>第一步：</strong> 创建maven项目</p>\n<p>pom.xml :</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span>\n         <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n         <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.xiaopizhu<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>helloSpringBoot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.5.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span>\n</code></div></pre>\n<p>注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。</p>\n<p>此时的工程结构为：</p>\n<p><img src=\"https://static.mszlu.com/a7302c88-e106-46ad-9713-dc9a6d523957.png\" alt=\"image20210523173241557.png\" /></p>\n<p><strong>第二步：</strong> 添加web依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n</code></div></pre>\n<p>添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。</p>\n<p><strong>第三步：</strong> 编写启动类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloApp</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n</code></div></pre>\n<p>@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。</p>\n<p><strong>第四步：</strong> 运行启动类的main方法</p>\n<p><img src=\"https://static.mszlu.com/dc17b43e-08df-46b0-bb7a-eb73044de7da.png\" alt=\"image20210523173712142.png\" /></p>\n<p>看到如上配置，证明启动成功，tomcat端口号默认为8080。</p>\n<p><strong>第五步：</strong>  如果想要修改端口号，可以在resources目录下新建application.properties</p>\n<pre><code class=\"lang-properties\">server.port=8082\n</code></pre>\n<p><strong>第六步：</strong> 重新运行</p>\n<p><img src=\"https://static.mszlu.com/318e4b7e-95d2-4e43-a18f-279ea6ff9495.png\" alt=\"image20210523174011613.png\" /></p>\n<p>此时的项目结构为：</p>\n<p><img src=\"https://static.mszlu.com/756e4ae0-c4c7-43a5-9b5d-bc7ce974a942.png\" alt=\"image20210523174032053.png\" /></p>\n<p><strong>src/main/java :</strong>  编写java代码，注意启动类需要放在项目的根包下。</p>\n<p><strong>src/main/resources:</strong>  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。</p>\n<p><strong>src/test/java:</strong>  测试代码</p>\n<h2><a id=\"22_Http_138\"></a>2.2 编写一个Http接口</h2>\n<p><strong>第一步：</strong>  创建<code>HelloController</code>类，内容如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RestController;\n\n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"hello\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloController</span> </span>{\n\n    <span class=\"hljs-meta\">@GetMapping</span>(<span class=\"hljs-string\">\"boot\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">hello</span><span class=\"hljs-params\">()</span></span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello spring boot\"</span>;\n    }\n\n}\n\n</code></div></pre>\n<p><strong>注意包名，必须在启动类所在的包名下。</strong></p>\n<p>**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"23__168\"></a>2.3 编写单元测试用例</h2>\n<p>**第一步： ** 添加spring boot测试依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<p><strong>第二步：</strong> 在src/test 下，编写测试用例</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeAll;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeEach;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.Test;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.test.context.SpringBootTest;\n<span class=\"hljs-keyword\">import</span> org.springframework.http.MediaType;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.MockMvc;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.hamcrest.Matchers.equalTo;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n<span class=\"hljs-meta\">@SpringBootTest</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestHelloController</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> MockMvc mockMvc;\n\n    <span class=\"hljs-meta\">@BeforeEach</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">beforeEach</span><span class=\"hljs-params\">()</span></span>{\n        mockMvc = MockMvcBuilders.standaloneSetup(<span class=\"hljs-keyword\">new</span> HelloController()).build();\n    }\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testHello</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        mockMvc.perform(MockMvcRequestBuilders.get(<span class=\"hljs-string\">\"/hello/boot\"</span>)\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(<span class=\"hljs-string\">\"hello spring boot\"</span>)));\n    }\n}\n\n</code></div></pre>\n<p>上面的测试用例，是构建一个空的<code>WebApplicationContext</code>，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。</p>\n<h2><a id=\"24_jar_220\"></a>2.4 打包为jar运行</h2>\n<p><strong>第一步：</strong> 添加打包(maven构建springboot)插件</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n</code></div></pre>\n<p>在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar</p>\n<p><img src=\"https://static.mszlu.com/45aa0db2-598f-4564-964c-a2d889dfbafe.png\" alt=\"image20210523181737720.png\" /></p>\n<p>**第二步： ** 打开cmd：找到jar对应的目录</p>\n<p>输入命令</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">java -jar helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<p><img src=\"https://static.mszlu.com/74376f77-b8eb-4c2c-a4cc-d3bfe24901e3.png\" alt=\"image20210523182426404.png\" /></p>\n<p><strong>第三步：</strong>  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"25_jar_253\"></a>2.5 查看jar包内容</h2>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">jar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<h1><a id=\"3__259\"></a>3. 小结</h1>\n<ol>\n<li>通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。</li>\n<li>通过修改配置文件，更改端口号</li>\n<li>编写了测试用例</li>\n<li>打包jar包运行</li>\n</ol>\n',1405916999732707349),(1521779976186507265,'# 1. Spring Boot介绍\n\n## 1.1 简介\n\n在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？\n\n在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？\n\n那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！\n\nSpring Boot让我们的Spring应用变的更轻量化。\n\n我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。\n\n通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\n\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。\n\n**总结一下Spring Boot的主要优点：**\n\n1. 为所有Spring开发者更快的入门\n2. 开箱即用，提供各种默认配置来简化项目配置\n3. 内嵌式容器简化Web项目\n4. 没有冗余代码生成和XML配置的要求\n5. 统一的依赖管理\n6. 自动装配，更易使用，更易扩展\n\n## 1.2 使用版本说明\n\nSpringboot版本：使用最新的2.5.0版本\n\n教程参考了官方文档进行制作，权威。\n\n其他依赖版本：\n\n	1. Maven  需求：3.5+\n\n   	2. JDK 需求  8+\n   	3. Spring Framework 5.3.7以上版本\n   	4. Tomcat 9.0\n   	5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n\n# 2. 快速入门\n\n快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。\n\n教程使用的Idea版本：2019.3\n\n## 2.1 创建基础项目\n\n**第一步：** 创建maven项目\n\npom.xml :\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.xiaopizhu</groupId>\n    <artifactId>helloSpringBoot</artifactId>\n    <version>1.0-SNAPSHOT</version>\n	<!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突-->\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.0</version>\n    </parent>\n</project>\n~~~\n\n注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。\n\n此时的工程结构为：\n\n![image20210523173241557.png](https://static.mszlu.com/a7302c88-e106-46ad-9713-dc9a6d523957.png)\n\n**第二步：** 添加web依赖\n\n~~~xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n~~~\n\n添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。\n\n**第三步：** 编写启动类\n\n~~~java\npackage com.xiaopizhu.springboot;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloApp {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n~~~\n\n@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。\n\n**第四步：** 运行启动类的main方法\n\n![image20210523173712142.png](https://static.mszlu.com/dc17b43e-08df-46b0-bb7a-eb73044de7da.png)\n\n看到如上配置，证明启动成功，tomcat端口号默认为8080。\n\n**第五步：**  如果想要修改端口号，可以在resources目录下新建application.properties\n\n~~~properties\nserver.port=8082\n~~~\n\n**第六步：** 重新运行\n\n![image20210523174011613.png](https://static.mszlu.com/318e4b7e-95d2-4e43-a18f-279ea6ff9495.png)\n\n此时的项目结构为：\n\n![image20210523174032053.png](https://static.mszlu.com/756e4ae0-c4c7-43a5-9b5d-bc7ce974a942.png)\n\n**src/main/java :**  编写java代码，注意启动类需要放在项目的根包下。\n\n**src/main/resources:**  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。\n\n**src/test/java:**  测试代码\n\n## 2.2 编写一个Http接口\n\n**第一步：**  创建`HelloController`类，内容如下：\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"hello\")\npublic class HelloController {\n\n    @GetMapping(\"boot\")\n    public String hello(){\n        return \"hello spring boot\";\n    }\n\n}\n\n~~~\n\n**注意包名，必须在启动类所在的包名下。**\n\n**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.3 编写单元测试用例\n\n**第一步： ** 添加spring boot测试依赖\n\n~~~xml\n		<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n~~~\n\n**第二步：** 在src/test 下，编写测试用例\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.http.MediaType;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@SpringBootTest\npublic class TestHelloController {\n\n    private MockMvc mockMvc;\n\n    @BeforeEach\n    public void beforeEach(){\n        mockMvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\n    }\n    @Test\n    public void testHello() throws Exception {\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/hello/boot\")\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(\"hello spring boot\")));\n    }\n}\n\n~~~\n\n上面的测试用例，是构建一个空的`WebApplicationContext`，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。\n\n## 2.4 打包为jar运行\n\n**第一步：** 添加打包(maven构建springboot)插件\n\n~~~xml\n  <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n~~~\n\n在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar\n\n![image20210523181737720.png](https://static.mszlu.com/45aa0db2-598f-4564-964c-a2d889dfbafe.png)\n\n**第二步： ** 打开cmd：找到jar对应的目录\n\n输入命令\n\n~~~shell\njava -jar helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n![image20210523182426404.png](https://static.mszlu.com/74376f77-b8eb-4c2c-a4cc-d3bfe24901e3.png)\n\n**第三步：**  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.5 查看jar包内容\n\n~~~shell\njar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n# 3. 小结\n\n1. 通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。\n2. 通过修改配置文件，更改端口号\n3. 编写了测试用例\n4. 打包jar包运行\n\n','<h1><a id=\"1_Spring_Boot_0\"></a>1. Spring Boot介绍</h1>\n<h2><a id=\"11__2\"></a>1.1 简介</h2>\n<p>在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？</p>\n<p>在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？</p>\n<p>那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！</p>\n<p>Spring Boot让我们的Spring应用变的更轻量化。</p>\n<p>我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。</p>\n<p>通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过<code>java -jar</code>命令就可以运行起来。</p>\n<p>这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。</p>\n<p><strong>总结一下Spring Boot的主要优点：</strong></p>\n<ol>\n<li>为所有Spring开发者更快的入门</li>\n<li>开箱即用，提供各种默认配置来简化项目配置</li>\n<li>内嵌式容器简化Web项目</li>\n<li>没有冗余代码生成和XML配置的要求</li>\n<li>统一的依赖管理</li>\n<li>自动装配，更易使用，更易扩展</li>\n</ol>\n<h2><a id=\"12__27\"></a>1.2 使用版本说明</h2>\n<p>Springboot版本：使用最新的2.5.0版本</p>\n<p>教程参考了官方文档进行制作，权威。</p>\n<p>其他依赖版本：</p>\n<pre><code>1. Maven  需求：3.5+\n\n2. JDK 需求  8+\n3. Spring Framework 5.3.7以上版本\n4. Tomcat 9.0\n5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n</code></pre>\n<h1><a id=\"2__42\"></a>2. 快速入门</h1>\n<p>快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。</p>\n<p>教程使用的Idea版本：2019.3</p>\n<h2><a id=\"21__48\"></a>2.1 创建基础项目</h2>\n<p><strong>第一步：</strong> 创建maven项目</p>\n<p>pom.xml :</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span>\n         <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n         <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.xiaopizhu<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>helloSpringBoot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.5.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span>\n</code></div></pre>\n<p>注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。</p>\n<p>此时的工程结构为：</p>\n<p><img src=\"https://static.mszlu.com/a7302c88-e106-46ad-9713-dc9a6d523957.png\" alt=\"image20210523173241557.png\" /></p>\n<p><strong>第二步：</strong> 添加web依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n</code></div></pre>\n<p>添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。</p>\n<p><strong>第三步：</strong> 编写启动类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloApp</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n</code></div></pre>\n<p>@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。</p>\n<p><strong>第四步：</strong> 运行启动类的main方法</p>\n<p><img src=\"https://static.mszlu.com/dc17b43e-08df-46b0-bb7a-eb73044de7da.png\" alt=\"image20210523173712142.png\" /></p>\n<p>看到如上配置，证明启动成功，tomcat端口号默认为8080。</p>\n<p><strong>第五步：</strong>  如果想要修改端口号，可以在resources目录下新建application.properties</p>\n<pre><code class=\"lang-properties\">server.port=8082\n</code></pre>\n<p><strong>第六步：</strong> 重新运行</p>\n<p><img src=\"https://static.mszlu.com/318e4b7e-95d2-4e43-a18f-279ea6ff9495.png\" alt=\"image20210523174011613.png\" /></p>\n<p>此时的项目结构为：</p>\n<p><img src=\"https://static.mszlu.com/756e4ae0-c4c7-43a5-9b5d-bc7ce974a942.png\" alt=\"image20210523174032053.png\" /></p>\n<p><strong>src/main/java :</strong>  编写java代码，注意启动类需要放在项目的根包下。</p>\n<p><strong>src/main/resources:</strong>  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。</p>\n<p><strong>src/test/java:</strong>  测试代码</p>\n<h2><a id=\"22_Http_138\"></a>2.2 编写一个Http接口</h2>\n<p><strong>第一步：</strong>  创建<code>HelloController</code>类，内容如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RestController;\n\n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"hello\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloController</span> </span>{\n\n    <span class=\"hljs-meta\">@GetMapping</span>(<span class=\"hljs-string\">\"boot\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">hello</span><span class=\"hljs-params\">()</span></span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello spring boot\"</span>;\n    }\n\n}\n\n</code></div></pre>\n<p><strong>注意包名，必须在启动类所在的包名下。</strong></p>\n<p>**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"23__168\"></a>2.3 编写单元测试用例</h2>\n<p>**第一步： ** 添加spring boot测试依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<p><strong>第二步：</strong> 在src/test 下，编写测试用例</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeAll;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeEach;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.Test;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.test.context.SpringBootTest;\n<span class=\"hljs-keyword\">import</span> org.springframework.http.MediaType;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.MockMvc;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.hamcrest.Matchers.equalTo;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n<span class=\"hljs-meta\">@SpringBootTest</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestHelloController</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> MockMvc mockMvc;\n\n    <span class=\"hljs-meta\">@BeforeEach</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">beforeEach</span><span class=\"hljs-params\">()</span></span>{\n        mockMvc = MockMvcBuilders.standaloneSetup(<span class=\"hljs-keyword\">new</span> HelloController()).build();\n    }\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testHello</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        mockMvc.perform(MockMvcRequestBuilders.get(<span class=\"hljs-string\">\"/hello/boot\"</span>)\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(<span class=\"hljs-string\">\"hello spring boot\"</span>)));\n    }\n}\n\n</code></div></pre>\n<p>上面的测试用例，是构建一个空的<code>WebApplicationContext</code>，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。</p>\n<h2><a id=\"24_jar_220\"></a>2.4 打包为jar运行</h2>\n<p><strong>第一步：</strong> 添加打包(maven构建springboot)插件</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n</code></div></pre>\n<p>在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar</p>\n<p><img src=\"https://static.mszlu.com/45aa0db2-598f-4564-964c-a2d889dfbafe.png\" alt=\"image20210523181737720.png\" /></p>\n<p>**第二步： ** 打开cmd：找到jar对应的目录</p>\n<p>输入命令</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">java -jar helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<p><img src=\"https://static.mszlu.com/74376f77-b8eb-4c2c-a4cc-d3bfe24901e3.png\" alt=\"image20210523182426404.png\" /></p>\n<p><strong>第三步：</strong>  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"25_jar_253\"></a>2.5 查看jar包内容</h2>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">jar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<h1><a id=\"3__259\"></a>3. 小结</h1>\n<ol>\n<li>通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。</li>\n<li>通过修改配置文件，更改端口号</li>\n<li>编写了测试用例</li>\n<li>打包jar包运行</li>\n</ol>\n',1405916999732707350),(1521780045610627074,'# 1. Spring Boot介绍\n\n## 1.1 简介\n\n在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？\n\n在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？\n\n那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！\n\nSpring Boot让我们的Spring应用变的更轻量化。\n\n我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。\n\n通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\n\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。\n\n**总结一下Spring Boot的主要优点：**\n\n1. 为所有Spring开发者更快的入门\n2. 开箱即用，提供各种默认配置来简化项目配置\n3. 内嵌式容器简化Web项目\n4. 没有冗余代码生成和XML配置的要求\n5. 统一的依赖管理\n6. 自动装配，更易使用，更易扩展\n\n## 1.2 使用版本说明\n\nSpringboot版本：使用最新的2.5.0版本\n\n教程参考了官方文档进行制作，权威。\n\n其他依赖版本：\n\n	1. Maven  需求：3.5+\n\n   	2. JDK 需求  8+\n   	3. Spring Framework 5.3.7以上版本\n   	4. Tomcat 9.0\n   	5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n\n# 2. 快速入门\n\n快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。\n\n教程使用的Idea版本：2019.3\n\n## 2.1 创建基础项目\n\n**第一步：** 创建maven项目\n\npom.xml :\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.xiaopizhu</groupId>\n    <artifactId>helloSpringBoot</artifactId>\n    <version>1.0-SNAPSHOT</version>\n	<!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突-->\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.0</version>\n    </parent>\n</project>\n~~~\n\n注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。\n\n此时的工程结构为：\n\n![image20210523173241557.png](https://static.mszlu.com/a7302c88-e106-46ad-9713-dc9a6d523957.png)\n\n**第二步：** 添加web依赖\n\n~~~xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n~~~\n\n添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。\n\n**第三步：** 编写启动类\n\n~~~java\npackage com.xiaopizhu.springboot;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloApp {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n~~~\n\n@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。\n\n**第四步：** 运行启动类的main方法\n\n![image20210523173712142.png](https://static.mszlu.com/dc17b43e-08df-46b0-bb7a-eb73044de7da.png)\n\n看到如上配置，证明启动成功，tomcat端口号默认为8080。\n\n**第五步：**  如果想要修改端口号，可以在resources目录下新建application.properties\n\n~~~properties\nserver.port=8082\n~~~\n\n**第六步：** 重新运行\n\n![image20210523174011613.png](https://static.mszlu.com/318e4b7e-95d2-4e43-a18f-279ea6ff9495.png)\n\n此时的项目结构为：\n\n![image20210523174032053.png](https://static.mszlu.com/756e4ae0-c4c7-43a5-9b5d-bc7ce974a942.png)\n\n**src/main/java :**  编写java代码，注意启动类需要放在项目的根包下。\n\n**src/main/resources:**  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。\n\n**src/test/java:**  测试代码\n\n## 2.2 编写一个Http接口\n\n**第一步：**  创建`HelloController`类，内容如下：\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"hello\")\npublic class HelloController {\n\n    @GetMapping(\"boot\")\n    public String hello(){\n        return \"hello spring boot\";\n    }\n\n}\n\n~~~\n\n**注意包名，必须在启动类所在的包名下。**\n\n**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.3 编写单元测试用例\n\n**第一步： ** 添加spring boot测试依赖\n\n~~~xml\n		<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n~~~\n\n**第二步：** 在src/test 下，编写测试用例\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.http.MediaType;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@SpringBootTest\npublic class TestHelloController {\n\n    private MockMvc mockMvc;\n\n    @BeforeEach\n    public void beforeEach(){\n        mockMvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\n    }\n    @Test\n    public void testHello() throws Exception {\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/hello/boot\")\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(\"hello spring boot\")));\n    }\n}\n\n~~~\n\n上面的测试用例，是构建一个空的`WebApplicationContext`，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。\n\n## 2.4 打包为jar运行\n\n**第一步：** 添加打包(maven构建springboot)插件\n\n~~~xml\n  <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n~~~\n\n在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar\n\n![image20210523181737720.png](https://static.mszlu.com/45aa0db2-598f-4564-964c-a2d889dfbafe.png)\n\n**第二步： ** 打开cmd：找到jar对应的目录\n\n输入命令\n\n~~~shell\njava -jar helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n![image20210523182426404.png](https://static.mszlu.com/74376f77-b8eb-4c2c-a4cc-d3bfe24901e3.png)\n\n**第三步：**  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.5 查看jar包内容\n\n~~~shell\njar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n# 3. 小结\n\n1. 通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。\n2. 通过修改配置文件，更改端口号\n3. 编写了测试用例\n4. 打包jar包运行\n\n','<h1><a id=\"1_Spring_Boot_0\"></a>1. Spring Boot介绍</h1>\n<h2><a id=\"11__2\"></a>1.1 简介</h2>\n<p>在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？</p>\n<p>在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？</p>\n<p>那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！</p>\n<p>Spring Boot让我们的Spring应用变的更轻量化。</p>\n<p>我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。</p>\n<p>通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过<code>java -jar</code>命令就可以运行起来。</p>\n<p>这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。</p>\n<p><strong>总结一下Spring Boot的主要优点：</strong></p>\n<ol>\n<li>为所有Spring开发者更快的入门</li>\n<li>开箱即用，提供各种默认配置来简化项目配置</li>\n<li>内嵌式容器简化Web项目</li>\n<li>没有冗余代码生成和XML配置的要求</li>\n<li>统一的依赖管理</li>\n<li>自动装配，更易使用，更易扩展</li>\n</ol>\n<h2><a id=\"12__27\"></a>1.2 使用版本说明</h2>\n<p>Springboot版本：使用最新的2.5.0版本</p>\n<p>教程参考了官方文档进行制作，权威。</p>\n<p>其他依赖版本：</p>\n<pre><code>1. Maven  需求：3.5+\n\n2. JDK 需求  8+\n3. Spring Framework 5.3.7以上版本\n4. Tomcat 9.0\n5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n</code></pre>\n<h1><a id=\"2__42\"></a>2. 快速入门</h1>\n<p>快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。</p>\n<p>教程使用的Idea版本：2019.3</p>\n<h2><a id=\"21__48\"></a>2.1 创建基础项目</h2>\n<p><strong>第一步：</strong> 创建maven项目</p>\n<p>pom.xml :</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span>\n         <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n         <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.xiaopizhu<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>helloSpringBoot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.5.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span>\n</code></div></pre>\n<p>注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。</p>\n<p>此时的工程结构为：</p>\n<p><img src=\"https://static.mszlu.com/a7302c88-e106-46ad-9713-dc9a6d523957.png\" alt=\"image20210523173241557.png\" /></p>\n<p><strong>第二步：</strong> 添加web依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n</code></div></pre>\n<p>添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。</p>\n<p><strong>第三步：</strong> 编写启动类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloApp</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n</code></div></pre>\n<p>@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。</p>\n<p><strong>第四步：</strong> 运行启动类的main方法</p>\n<p><img src=\"https://static.mszlu.com/dc17b43e-08df-46b0-bb7a-eb73044de7da.png\" alt=\"image20210523173712142.png\" /></p>\n<p>看到如上配置，证明启动成功，tomcat端口号默认为8080。</p>\n<p><strong>第五步：</strong>  如果想要修改端口号，可以在resources目录下新建application.properties</p>\n<pre><code class=\"lang-properties\">server.port=8082\n</code></pre>\n<p><strong>第六步：</strong> 重新运行</p>\n<p><img src=\"https://static.mszlu.com/318e4b7e-95d2-4e43-a18f-279ea6ff9495.png\" alt=\"image20210523174011613.png\" /></p>\n<p>此时的项目结构为：</p>\n<p><img src=\"https://static.mszlu.com/756e4ae0-c4c7-43a5-9b5d-bc7ce974a942.png\" alt=\"image20210523174032053.png\" /></p>\n<p><strong>src/main/java :</strong>  编写java代码，注意启动类需要放在项目的根包下。</p>\n<p><strong>src/main/resources:</strong>  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。</p>\n<p><strong>src/test/java:</strong>  测试代码</p>\n<h2><a id=\"22_Http_138\"></a>2.2 编写一个Http接口</h2>\n<p><strong>第一步：</strong>  创建<code>HelloController</code>类，内容如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RestController;\n\n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"hello\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloController</span> </span>{\n\n    <span class=\"hljs-meta\">@GetMapping</span>(<span class=\"hljs-string\">\"boot\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">hello</span><span class=\"hljs-params\">()</span></span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello spring boot\"</span>;\n    }\n\n}\n\n</code></div></pre>\n<p><strong>注意包名，必须在启动类所在的包名下。</strong></p>\n<p>**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"23__168\"></a>2.3 编写单元测试用例</h2>\n<p>**第一步： ** 添加spring boot测试依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<p><strong>第二步：</strong> 在src/test 下，编写测试用例</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeAll;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeEach;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.Test;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.test.context.SpringBootTest;\n<span class=\"hljs-keyword\">import</span> org.springframework.http.MediaType;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.MockMvc;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.hamcrest.Matchers.equalTo;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n<span class=\"hljs-meta\">@SpringBootTest</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestHelloController</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> MockMvc mockMvc;\n\n    <span class=\"hljs-meta\">@BeforeEach</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">beforeEach</span><span class=\"hljs-params\">()</span></span>{\n        mockMvc = MockMvcBuilders.standaloneSetup(<span class=\"hljs-keyword\">new</span> HelloController()).build();\n    }\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testHello</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        mockMvc.perform(MockMvcRequestBuilders.get(<span class=\"hljs-string\">\"/hello/boot\"</span>)\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(<span class=\"hljs-string\">\"hello spring boot\"</span>)));\n    }\n}\n\n</code></div></pre>\n<p>上面的测试用例，是构建一个空的<code>WebApplicationContext</code>，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。</p>\n<h2><a id=\"24_jar_220\"></a>2.4 打包为jar运行</h2>\n<p><strong>第一步：</strong> 添加打包(maven构建springboot)插件</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n</code></div></pre>\n<p>在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar</p>\n<p><img src=\"https://static.mszlu.com/45aa0db2-598f-4564-964c-a2d889dfbafe.png\" alt=\"image20210523181737720.png\" /></p>\n<p>**第二步： ** 打开cmd：找到jar对应的目录</p>\n<p>输入命令</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">java -jar helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<p><img src=\"https://static.mszlu.com/74376f77-b8eb-4c2c-a4cc-d3bfe24901e3.png\" alt=\"image20210523182426404.png\" /></p>\n<p><strong>第三步：</strong>  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"25_jar_253\"></a>2.5 查看jar包内容</h2>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">jar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<h1><a id=\"3__259\"></a>3. 小结</h1>\n<ol>\n<li>通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。</li>\n<li>通过修改配置文件，更改端口号</li>\n<li>编写了测试用例</li>\n<li>打包jar包运行</li>\n</ol>\n',1405916999732707351),(1521822721332662273,'\n\n\n# 1. 类图概述\n统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。\n\nUML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图。\n\n类图(Class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。\n\n## 1.2 类图的作用\n\n* 在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解；\n* 类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。\n\n## 1.3 类图表示法\n\n### 1.3.1 类的表示方式\n\n在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name,age和address这3个属性，以及work()方法。 \n\n\n属性/方法名称前加的加号和减号表示了这个属性/方法的可见性，UML类图中表示可见性的符号有三种：\n\n* +：表示public\n\n* -：表示private\n\n* #：表示protected\n\n属性的完整表示方式是： **可见性  名称 ：类型 [ = 缺省值]**  \n\n方法的完整表示方式是： **可见性  名称(参数列表) [ ： 返回类型]**\n\n> 注意：\n>\n> 1，中括号中的内容表示是可选的\n>\n> 2，也有将类型放在变量名前面，返回值类型放在方法名前面\n\n**举个栗子：**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/04fd7b0a2dd048adb179e927ba586dad.png#pic_center)\n\n\n上图Demo类定义了三个方法：\n\n* method()方法：修饰符为public，没有参数，没有返回值。\n* method1()方法：修饰符为private，没有参数，返回值类型为String。\n* method2()方法：修饰符为protected，接收两个参数，第一个参数类型为int，第二个参数类型为String，返回值类型是int。\n\n### 1.3.2 类与类之间关系的表示方式\n\n#### 1.3.2.1 关联关系\n\n关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。\n\n关联又可以分为单向关联，双向关联，自关联。\n\n**1，单向关联**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d636bca3668743b08aea2ded7d8af0ff.png#pic_center)\n\n\n在UML类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。\n\n**2，双向关联**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/fd2544a1ba7248fab799c931fa589a1d.png#pic_center)\n\n\n从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。\n\n在UML类图中，双向关联用一个不带箭头的直线表示。上图中在Customer类中维护一个List\\<Product>，表示一个顾客可以购买多个商品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。\n\n**3，自关联**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6406fb400c2149a482547f3a6cbb21cb.png#pic_center)\n\n\n自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。\n\n\n\n#### 1.3.2.2 聚合关系\n\n聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。\n\n聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。\n\n在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。下图所示是大学和教师的关系图：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c17e7163c4da46c39c7564d9222f371f.png#pic_center)\n\n\n#### 1.3.2.3 组合关系\n\n组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。\n\n在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。\n\n在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。下图所示是头和嘴的关系图：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/0a9262e57101450d87e9295c8a7d78ab.png#pic_center)\n\n\n\n\n#### 1.3.2.4 依赖关系\n\n依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。\n\n在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是司机和汽车的关系图，司机驾驶汽车：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ef2a51cf0d714b4e807e2d7145d32ebb.png#pic_center)\n\n\n#### 1.3.2.5 继承关系\n\n继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。\n\n在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下图所示：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a3076e2833644fef8799a2f806cf0857.png#pic_center)\n\n\n\n\n#### 1.3.2.6 实现关系\n\n实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。\n\n在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如图 9 所示。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/18c9100e673346a1ae755058457e8d06.png#pic_center)\n\n\n\n\n\n\n# 常用设计模式\n\n==创建者：单例、工厂==\n\n==结构型：代理、适配器、装饰者、外观==\n\n==行为型：策略、模板、职责链、观察者、发布与订阅==\n\n# 1. 软件设计原则\n\n## 1.1 开闭原则\n\n**对扩展开放，对改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。\n\n> 想要达到这样的效果，我们需要使用接口和抽象类。\n\n【例】`搜狗输入法` 的皮肤设计。\n\n分析：`搜狗输入法` 的皮肤是输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，也可以从网上下载新的皮肤。这些皮肤有共同的特点，可以为其定义一个抽象类（AbstractSkin），而每个具体的皮肤（DefaultSpecificSkin和HeimaSpecificSkin）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。\n\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/c1d781a7e69949f58128646fb7d7fd03.png#pic_center)\n\n\n## 1.2 里氏代换原则\n\n​	里氏代换原则：任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。\n\n 	**子类可以扩展父类的功能，但不能改变父类原有的功能。** 也就是既不能重写父类的方法，也不能重载父类的方法。\n\n【例】\n\n父类长方形\n\n```java\npackage com.morris.pattern.lsp;\n\npublic class Rectangle {\n\n    protected int width;\n\n    protected int height;\n\n    public Rectangle(int width, int height) {\n        this.width = width;\n        this.height = height;\n    }\n\n    public int calcArea() {\n        return width * height;\n    }\n\n}\n```\n\n子类正方形\n\n```java\npackage com.morris.pattern.lsp;\n\npublic class Square extends Rectangle {\n\n    public Square(int width, int height) {\n        super(width, height);\n    }\n    @Override //重写了父类计算面积的方法\n    public int calcArea() {\n        return width * width;\n    }\n\n}\n```\n\n测试类\n\n```java\npackage com.morris.pattern.lsp;\n\npublic class App {\n\n    public static void main(String[] args) {\n        Rectangle rectangle = new Rectangle(10, 20); //长方\n        Rectangle rectangle = new Square(10, 20); //正方形\n        System.out.println(rectangle.calcArea());\n    }\n\n}\n```\n\n如果把长方形类Rectangle替换为正方形类Square，那么求出的面积就不正确了，原因是继承的时候重写了父类的getArea方法。这是违背里氏替换原则的。 \n\n## 1.3 依赖倒转原则\n\n​		高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\n\n> 个人认为跟开闭原则很像，都是要求面向接口 / 抽象编程。因为对接口编程时，很方便扩展，那么实现类修改了，只要接口不变，使用该接口的类也不需要变。**面向接口编程就能满足两种原则了！**\n\n【例】\n\n**之前**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/f133ab2a16df47a6864f45b12f12829b.png#pic_center)\n\n\n------------\n\n**之后**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6dfc0e3ef527423ba7f9c4533a5b3923.png#pic_center)\n\n\n## 1.4 接口隔离原则\n\n客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在**最小的接口**上。\n\n> 这里跟数据库的第一范式很相似，就是对于属性的粒度划分要刚刚好，要小到不能划分。\n>\n> 就像人能拉屎拉尿，也不应该将这两个功能写在同一接口里面，应该分开接口来写，因为有些人是不能拉尿的。\n\n## 1.5 迪米特法则\n\n**又叫最少知识原则。**\n\n其含义是：如果两个软件实体**无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用**。其目的是降低类之间的耦合度，提高模块的相对独立性。\n\n## 1.6 合成复用原则\n\n合成复用原则是指：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。\n\n【例】汽车分类管理程序\n\n汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。类图如下： \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/efce48a226014b559795ab6e48f879e6.png#pic_center)\n\n\n从上面类图我们可以看到使用继承复用产生了很多子类，如果现在又有新的动力源或者新的颜色的话，就需要再定义新的类。我们试着将继承复用改为聚合复用看一下。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2d6f81f4cc6440339a8049951949b968.png#pic_center)\n\n\n# 2. 创建者模式\n\n创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。\n\n这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。\n\n创建型模式分为：\n\n* 单例模式\n* 工厂方法模式\n* 抽象工程模式\n* 原型模式\n* 建造者模式\n\n## 2.1 单例设计模式\n\n单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n\n这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\n\n### 2.1.1 单例模式的结构\n\n单例模式的主要有以下角色：\n\n* 单例类。只能创建一个实例的类\n* 访问类。使用单例类\n\n### 2.1.2 单例模式的实现\n\n> 单例设计模式分类两种：\n>\n> ​	饿汉式：类加载就会导致该单实例对象被创建	\n>\n> ​	懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建\n\n1. 饿汉式\n\n   ```java\n   /**\n    * 饿汉式\n    *      静态变量创建类的对象\n    */\n   public class Singleton {\n       //私有构造方法\n       private Singleton() {}\n   \n       //在成员位置创建该类的对象\n       private static Singleton instance = new Singleton();\n   \n       //对外提供静态方法获取该对象\n       public static Singleton getInstance() {\n           return instance;\n       }\n   }\n   ```\n\n2. 懒汉式\n\n   添加 `volatile` 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。\n\n   ```java\n   /**\n    * 双重检查方式\n    */\n   public class Singleton {\n   \n       //私有构造方法\n       private Singleton() {}\n   \n       private static volatile Singleton instance;\n   \n      //对外提供静态方法获取该对象\n       public static Singleton getInstance() {\n   		//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际\n           if(instance == null) {\n               synchronized (Singleton.class) {\n                   //抢到锁之后再次判断是否为空\n                   if(instance == null) {\n                       instance = new Singleton();\n                   }\n               }\n           }\n           return instance;\n       }\n   }\n   ```\n\n3. 懒汉式-方式4（静态内部类方式）\n\n   静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性/方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 `static` 修饰，保证只被实例化一次，并且严格保证实例化顺序。\n\n   ```java\n   /**\n    * 静态内部类方式\n    */\n   public class Singleton {\n   \n       //私有构造方法\n       private Singleton() {}\n   \n       private static class SingletonHolder {\n           private static final Singleton INSTANCE = new Singleton();\n       }\n   \n       //对外提供静态方法获取该对象\n       public static Singleton getInstance() {\n           return SingletonHolder.INSTANCE;\n       }\n   }\n   ```\n\n4. 枚举方式\n\n   枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。\n\n   ```java\n   /**\n    * 枚举方式\n    */\n   public enum Singleton {\n       INSTANCE;\n   }\n   ```\n\n### 2.1.3 存在的问题及解决\n\n>  *反序列化破坏单例的解决方式* \n\n​	在Singleton类中添加`readResolve()`方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。 \n\n\n```java\npublic class Singleton implements Serializable {\n\n    //私有构造方法\n    private Singleton() {}\n\n    private static class SingletonHolder {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n\n    //对外提供静态方法获取该对象\n    public static Singleton getInstance() {\n        return SingletonHolder.INSTANCE;\n    }\n    \n    /**\n     * 下面是为了解决序列化反序列化破解单例模式\n     */\n    private Object readResolve() {\n        return SingletonHolder.INSTANCE;\n    }\n}\n```\n\n> 反射方式破解单例的解决方法\n>\n\n```java\npublic class Singleton {\n\n    //私有构造方法\n    private Singleton() {\n        /*\n           反射破解单例模式需要添加的代码\n        */\n        if(instance != null) {\n            throw new RuntimeException();\n        }\n    }\n    \n    private static volatile Singleton instance;\n\n    //对外提供静态方法获取该对象\n    public static Singleton getInstance() {\n\n        if(instance != null) {\n            return instance;\n        }\n\n        synchronized (Singleton.class) {\n            if(instance != null) {\n                return instance;\n            }\n            instance = new Singleton();\n            return instance;\n        }\n    }\n}\n```\n\n## 2.2 工厂模式\n\n在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。\n\n如果**我们使用工厂来生产对象**，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：**解耦**。\n\n### 2.2.1 简单工厂模式\n\n简单工厂不是一种设计模式，反而比较像是一种编程习惯。\n\n>  结构\n\n简单工厂包含如下角色：\n\n* 抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。\n* 具体产品 ：实现或者继承抽象产品的子类\n* 具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/71636e5b69354341b5cc24642eec09ec.png#pic_center)\n\n\n> 优缺点\n\n**优点：**\n\n封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。\n\n**缺点：**\n\n增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。\n\n> 扩展\n\n**静态工厂**\n\n在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是23种设计模式中的。代码如下：\n\n```java\npublic class SimpleCoffeeFactory {\n\n    public static Coffee createCoffee(String type) {\n        Coffee coffee = null;\n        if(\"americano\".equals(type)) {\n            coffee = new AmericanoCoffee();\n        } else if(\"latte\".equals(type)) {\n            coffee = new LatteCoffee();\n        }\n        return coffe;\n    }\n}\n```\n\n### 2.2.2 工厂方法模式\n\n>  概念\n\n定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。\n\n> 结构\n\n工厂方法模式的主要角色：\n\n* 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。\n* 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。\n* 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。\n* 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d7bc2712a78a4a32857f74e2d7e6d791.png#pic_center)\n\n\n代码如下：\n\n抽象工厂：\n\n```java\npublic interface CoffeeFactory {\n\n    Coffee createCoffee();\n}\n```\n\n具体工厂：\n\n```java\npublic class LatteCoffeeFactory implements CoffeeFactory {\n\n    public Coffee createCoffee() {\n        return new LatteCoffee();\n    }\n}\n\npublic class AmericanCoffeeFactory implements CoffeeFactory {\n\n    public Coffee createCoffee() {\n        return new AmericanCoffee();\n    }\n}\n```\n\n咖啡店类：\n\n```java\npublic class CoffeeStore {\n\n    private CoffeeFactory factory;\n\n    public CoffeeStore(CoffeeFactory factory) {\n        this.factory = factory;\n    }\n\n    public Coffee orderCoffee(String type) {\n        Coffee coffee = factory.createCoffee();\n        coffee.addMilk();\n        coffee.addsugar();\n        return coffee;\n    }\n}\n```\n\n从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点。\n\n工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。\n\n### 2.2.3 抽象工厂模式\n\n前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、传智播客只培养计算机软件专业的学生等。\n\n这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。\n\n本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，下图所示横轴是产品等级，也就是同一类产品；纵轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/669b5f6bcec94e5f8e2b8cc61bd79eba.png#pic_center)\n\n\n比如：咖啡分美式英式等为同一等级。咖啡、奶茶、果汁为同一族，而应把他们抽象成同一产品族：饮料工厂。\n\n> 概念\n\n抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。\n\n>  结构\n\n抽象工厂模式的主要角色如下：\n\n* 抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。\n* 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。\n* 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。\n* 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。\n\n> 实现\n\n现咖啡店业务发生改变，不仅要生产咖啡还要生产甜点，如提拉米苏、抹茶慕斯等，要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。其中拿铁咖啡、美式咖啡是一个产品等级，都是咖啡；提拉米苏、抹茶慕斯也是一个产品等级；拿铁咖啡和提拉米苏是同一产品族（也就是都属于意大利风味），美式咖啡和抹茶慕斯是同一产品族（也就是都属于美式风味）。所以这个案例可以使用抽象工厂模式实现。类图如下：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d3354cf0800b4dbd8a21065e6a214c13.png#pic_center)\n\n\n> 优缺点\n\n**优点：**\n\n当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。\n\n**缺点：**\n\n当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。\n\n###  2.2.4 模式扩展\n\n**简单工厂+配置文件解除耦合**\n\n可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。\n\n第一步：定义配置文件\n\n为了演示方便，我们使用properties文件作为配置文件，名称为bean.properties\n\n```properties\namerican=com.itheima.pattern.factory.config_factory.AmericanCoffee\nlatte=com.itheima.pattern.factory.config_factory.LatteCoffee\n```\n\n第二步：改进工厂类\n\n```java\npublic class CoffeeFactory {\n\n    private static Map<String,Coffee> map = new HashMap();\n\n    static {\n        Properties p = new Properties();\n        InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream(\"bean.properties\");\n        try {\n            p.load(is);\n            //遍历Properties集合对象\n            Set<Object> keys = p.keySet();\n            for (Object key : keys) {\n                //根据键获取值（全类名）\n                String className = p.getProperty((String) key);\n                //获取字节码对象\n                Class clazz = Class.forName(className);\n                Coffee obj = (Coffee) clazz.newInstance();\n                map.put((String)key,obj);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static Coffee createCoffee(String name) {\n\n        return map.get(name);\n    }\n}\n```\n\n静态成员变量用来存储创建的对象（键存储的是名称，值存储的是对应的对象），而读取配置文件以及创建对象写在静态代码块中，目的就是只需要执行一次。\n\n## 2.3 原型模式\n\n> 概述\n\n用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。\n\n> 结构\n\n原型模式包含如下角色：\n\n* 抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。\n* 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。\n* 访问类：使用具体原型类中的 clone() 方法来复制新的对象。\n\n> 实现\n>\n\n原型模式的克隆分为浅克隆和深克隆。\n\n- 浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。\n\n  ==克隆后的对象本身地址改变，但是克隆后的对象的成员变量中引用类型的数据的地址仍然与原型对象一致==\n\n- 深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。\n\n  ==里里外外就是一个新对象==\n\nJava中的Object类中提供了 `clone()` 方法来实现浅克隆。 Cloneable 接口是上面的类图中的抽象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。\n\n> 浅克隆\n\n```java\npublic class Realizetype implements Cloneable { //实现浅克隆接口\n\n    public Realizetype() {\n        System.out.println(\"具体的原型对象创建完成！\");//手动new对象用的是构造器，但是clone方法不是用的构造器\n    }\n\n    @Override\n    protected Realizetype clone() throws CloneNotSupportedException {\n        System.out.println(\"具体原型复制成功！\");\n        return (Realizetype) super.clone();\n    }\n}\n```\n\n> 深克隆\n>\n\n通过序列化与反序列化方式完成深克隆，注意：==自定义对象需要实现序列化接口==\n\n```java\npublic class CitationTest1 {\n    public static void main(String[] args) throws Exception {\n        Citation c1 = new Citation();\n        Student stu = new Student(\"张三\", \"西安\");\n        c1.setStu(stu);\n\n        //创建对象输出流对象\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"C:\\\\Users\\\\Think\\\\Desktop\\\\b.txt\"));\n        //将c1对象写出到文件中\n        oos.writeObject(c1);\n        oos.close();\n\n        //创建对象出入流对象\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"C:\\\\Users\\\\Think\\\\Desktop\\\\b.txt\"));\n        //读取对象\n        Citation c2 = (Citation) ois.readObject();\n        //获取c2奖状所属学生对象\n        Student stu1 = c2.getStu();\n        stu1.setName(\"李四\");\n\n        //判断stu对象和stu1对象是否是同一个对象\n        System.out.println(\"stu和stu1是同一个对象？\" + (stu == stu1));\n\n        c1.show();\n        c2.show();\n    }\n}\n```\n\n# 3. 结构型模式\n\n结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。\n\n由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。\n\n结构型模式分为以下 7 种：\n\n* 代理模式\n* 适配器模式\n* 装饰者模式\n* 桥接模式\n* 外观模式\n* 组合模式\n* 享元模式\n\n\n\n## 3.1 代理模式\n\n### 3.1.1 概述\n\n由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\n\nJava中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。\n\n### 3.1.2 结构\n\n代理（Proxy）模式分为三种角色：\n\n* 抽象主题（Subject）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n* 真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n* 代理（Proxy）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 3.1.3 静态代理\n\n【例】火车站卖票\n\n如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。类图如下：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/5320fe83001649cd9a0067e36c60a1a5.png#pic_center)\n\n\n代码如下：\n\n```java\n//卖票接口\npublic interface SellTickets {\n    void sell();\n}\n\n//火车站  火车站具有卖票功能，所以需要实现SellTickets接口\npublic class TrainStation implements SellTickets {\n\n    public void sell() {\n        System.out.println(\"火车站卖票\");\n    }\n}\n\n//代售点\npublic class ProxyPoint implements SellTickets {\n\n    private TrainStation station = new TrainStation();\n\n    public void sell() {\n        System.out.println(\"代理点收取一些服务费用\");\n        station.sell();\n    }\n}\n\n//测试类\npublic class Client {\n    public static void main(String[] args) {\n        ProxyPoint pp = new ProxyPoint();\n        pp.sell();\n    }\n}\n```\n\n从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介。同时也对sell方法进行了增强（代理点收取一些服务费用）。\n\n### 3.1.4 JDK动态代理\n\n代码如下：\n\n```java\n//卖票接口\npublic interface SellTickets {\n    void sell();\n}\n\n//火车站  火车站具有卖票功能，所以需要实现SellTickets接口\npublic class TrainStation implements SellTickets {\n\n    public void sell() {\n        System.out.println(\"火车站卖票\");\n    }\n}\n\n//代理工厂，用来创建代理对象\npublic class ProxyFactory {\n\n    private TrainStation station = new TrainStation();\n\n    public SellTickets getProxyObject() {\n        //使用Proxy获取代理对象\n        /*\n            newProxyInstance()方法参数说明：\n                ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可\n                Class<?>[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口\n                InvocationHandler h ： 代理对象的调用处理程序\n         */\n        SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),\n                station.getClass().getInterfaces(),\n                new InvocationHandler() {\n                    /*\n                        InvocationHandler中invoke方法参数说明：\n                            proxy ： 代理对象\n                            method ： 对应于在代理对象上调用的接口方法的 Method 实例\n                            args ： 代理对象调用接口方法时传递的实际参数\n                     */\n                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\n                        System.out.println(\"代理点收取一些服务费用(JDK动态代理方式)\");\n                        //执行真实对象\n                        Object result = method.invoke(station, args);\n                        return result;\n                    }\n                });\n        return sellTickets;\n    }\n}\n\n//测试类\npublic class Client {\n    public static void main(String[] args) {\n        //获取代理对象\n        ProxyFactory factory = new ProxyFactory();\n        \n        SellTickets proxyObject = factory.getProxyObject();\n        proxyObject.sell();\n    }\n}\n```\n\n执行流程如下：\n\n  1. 在测试类中通过代理对象调用sell()方法\n  2. 根据多态的特性，执行的是代理类（$Proxy0）中的sell()方法\n  3. 代理类（$Proxy0）中的sell()方法中又调用了InvocationHandler接口的子实现类对象的invoke方法\n  4. invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法\n\n### 3.1.5 CGLIB动态代理\n\n同样是上面的案例，我们再次使用CGLIB代理实现。\n\n如果没有定义SellTickets接口，只定义了TrainStation(火车站类)。很显然JDK代理是无法使用了，因为JDK动态代理要求必须定义接口，对接口进行代理。\n\nCGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。\n\nCGLIB是第三方提供的包，所以需要引入jar包的坐标：\n\n```xml\n<dependency>\n    <groupId>cglib</groupId>\n    <artifactId>cglib</artifactId>\n    <version>2.2.2</version>\n</dependency>\n```\n\n代码如下：\n\n```java\n//火车站\npublic class TrainStation {\n\n    public void sell() {\n        System.out.println(\"火车站卖票\");\n    }\n}\n\n//代理工厂\npublic class ProxyFactory implements MethodInterceptor {\n\n    private TrainStation target = new TrainStation();\n\n    public TrainStation getProxyObject() {\n        //创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数\n        Enhancer enhancer =new Enhancer();\n        //设置父类的字节码对象\n        enhancer.setSuperclass(target.getClass());\n        //设置回调函数\n        enhancer.setCallback(this);\n        //创建代理对象\n        TrainStation obj = (TrainStation) enhancer.create();\n        return obj;\n    }\n\n    /*\n        intercept方法参数说明：\n            o ： 代理对象\n            method ： 真实对象中的方法的Method实例\n            args ： 实际参数\n            methodProxy ：代理对象中的方法的method实例\n     */\n    public TrainStation intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n        System.out.println(\"代理点收取一些服务费用(CGLIB动态代理方式)\");\n        TrainStation result = (TrainStation) methodProxy.invokeSuper(o, args);\n        return result;\n    }\n}\n\n//测试类\npublic class Client {\n    public static void main(String[] args) {\n        //创建代理工厂对象\n        ProxyFactory factory = new ProxyFactory();\n        //获取代理对象\n        TrainStation proxyObject = factory.getProxyObject();\n\n        proxyObject.sell();\n    }\n}\n```\n\n### 3.1.6 三种代理的对比\n\n* jdk代理和CGLIB代理\n\n  使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。\n\n  在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理。\n\n* 动态代理和静态代理\n\n  动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。\n\n  如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题\n\n\n\n### 3.1.7 优缺点\n\n**优点：**\n\n- 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n- 代理对象可以扩展目标对象的功能；\n- 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；\n\n**缺点：**\n\n* 增加了系统的复杂度；\n\n## 3.2 适配器模式\n\n### 3.2.1 概述\n\n 如果去欧洲国家去旅游的话，他们的插座如下图最左边，是欧洲标准。而我们使用的插头如下图最右边的。因此我们的笔记本电脑，手机在当地不能直接充电。所以就需要一个插座转换器，转换器第1面插入当地的插座，第2面供我们充电，这样使得我们的插头在当地能使用。生活中这样的例子很多，手机充电器（将220v转换为5v的电压），读卡器等，其实就是使用到了适配器模式。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b59606ae4a414f0382d89c3e819d28b2.png#pic_center)\n\n\n**定义：**\n\n​	将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。\n\n​	适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。\n\n### 3.2.2 结构\n\n适配器模式（Adapter）包含以下主要角色：\n\n* 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。\n* 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。\n* 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。\n\n> 适配器模式分为类适配器与对象适配器，对象适配器跟广泛一些。\n>\n\n### 3.2.3 对象适配器模式\n\n我们有一个 *NewMediaPlayer* 接口和一个实现了 *NewMediaPlayer* 接口的实体类 *NewMediaPlayerImpl*。默认情况下，NewMediaPlayerImpl可以播放 mp3 格式的音频文件。\n\n我们还有另一个接口 *AdvancedMediaPlayer* 和实现了 *AdvancedMediaPlayer* 接口的实体类。该类可以播放 avi和 mp4 格式的文件。\n\n我们想要让 NewMediaPlayerImpl播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 *NewMediaPlayer*接口的适配器类 *MediaAdapter*，并使用 *AdvancedMediaPlayer* 对象来播放所需的格式。\n\n> 类图\n>\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a4dacadcc9dc4590a54d26ce24c1131f.png#pic_center)\n\n\n> 代码\n\n1. AdvanceMediaPlayer接口代码\n\n```java\npublic interface AdvanceMediaPlayer {\n    void playMp4(String filename);\n    void playAvi(String filename);\n}\n```\n\n2. 实现AdvanceMediaPlayer接口的类AdvanceMediaPlayerImpl\n\n```java\npublic class AdvanceMediaPlayerImpl implements AdvanceMediaPlayer {\n\n    @Override\n    public void playMp4(String filename) {\n        System.out.println(\"原生播放器播放mp4:\"+filename);\n    }\n\n    @Override\n    public void playAvi(String filename) {\n        System.out.println(\"原生播放器播放Avi:\"+filename);\n    }\n}\n```\n\n3. NewMediaPlayer接口\n\n```java\npublic interface NewMediaPlayer {\n    void playMp3(String filename);\n}\n```\n\n4. 适配器类MediaAdapter\n\n```java\npublic class MediaAdapter implements NewMediaPlayer {\n//    适配器，是为了新播放器能够使用已经有的播放器（MP4，avi），所以使用者只是希望调用旧的播放器来播放\n//    因此，使用者只管在适配器中调用新播放器的接口的方法，但适配器实际用的是就播放器，但使用者不关心。\n//    为了不混乱，规定某个对象被扩展功能，其则是新播放器，需要为其适配器\n    AdvanceMediaPlayer advanceMediaPlayer;\n\n    /**\n     * 注意，这里的方法名有mp3，只是给使用者看的，\n     * 内部透明，但是作为适配器，\n     * 内部实际上调用的是advance播放器接口\n     *\n     * @param filename\n     */\n    @Override\n    public void playMp3(String filename) {\n        advanceMediaPlayer = new AdvanceMediaPlayerImpl();\n        if (filename.indexOf(\"mp4\") > 0) {\n            System.out.print(\"适配器接手==>\");\n            advanceMediaPlayer.playMp4(filename);\n        } else if (filename.indexOf(\"avi\") > 0) {\n            System.out.print(\"适配器接手==>\");\n            advanceMediaPlayer.playAvi(filename);\n        }\n    }\n```\n\n5. NewMediaPlayer接口实现类NewMediaPlayerImpl\n\n```java\npublic class NewMediaPlayerImpl implements NewMediaPlayer {\n    private MediaAdapter mediaAdapter;\n\n    /**\n     * 如果是mp3格式，对象本身可以播放，\n     * 但如果是mp4/avi则不支持，\n     * 需要调用适配器中的方法来播放其他格式\n     *\n     * @param filename\n     */\n    @Override\n    public void playMp3(String filename) {\n        if (filename.indexOf(\"mp3\") > 0) {\n//            对象本身支持mp3\n            System.out.println(\"新的播放器播放mp3:\" + filename);\n        } else if (filename.indexOf(\"mp4\") > 0 || filename.indexOf(\"avi\") > 0) {\n//            对象不支持，调用适配器api\n            mediaAdapter = new MediaAdapter();\n            mediaAdapter.playMp3(filename);\n        }\n    }\n\n}\n```\n\n6. 测试类\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        NewMediaPlayer newMediaPlayer = new NewMediaPlayerImpl();\n        newMediaPlayer.playMp3(\"苍井空.mp3\");\n        newMediaPlayer.playMp3(\"苍井空.mp4\");\n        newMediaPlayer.playMp3(\"苍井空.avi\");\n\n    }\n}\n```\n\n7. 结果\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e56fe80d00ac4b9dbadd13617828c47b.png#pic_center)\n\n\n## 3.3 装饰者模式\\*\\*\\*\n\n### 3.3.1 结构\n\n装饰（Decorator）模式中的角色：\n\n* 抽象构件（Component）角色 ：定义一个抽象接口以规范准备接收附加责任的对象。\n* 具体构件（Concrete  Component）角色 ：实现抽象构件，通过装饰角色为其添加一些职责。\n* 抽象装饰（Decorator）角色 ： ==继承或实现抽象构件，并包含具体构件的实例==，可以通过其子类扩展具体构件的功能。==妙处所在==\n* 具体装饰（ConcreteDecorator）角色 ：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。\n\n### 3.3.2 案例\n\n快餐+配菜。快餐有米饭、面条，配菜有鸡蛋、培根\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c7f9a7b4f78847e6b62a2eaee725d8c6.png#pic_center)\n\n\n\n\n> 代码\n>\n\n快餐抽象类\n\n```java\npublic abstract class FastFood {\n    private float price;\n    private String Description;\n\n    public FastFood() {\n    }\n\n    public FastFood(float price, String description) {\n        this.price = price;\n        Description = description;\n    }\n\n    public float getPrice() {\n        return price;\n    }\n\n    public void setPrice(float price) {\n        this.price = price;\n    }\n\n    public String getDescription() {\n        return Description;\n    }\n\n    public void setDescription(String description) {\n        Description = description;\n    }\n}\n```\n\n快餐实现类\n\n```java\n//炒饭\npublic class FriedRice extends FastFood{\n    public FriedRice() {\n        super(10, \"炒饭\");\n    }\n}\n//炒面\npublic class FriedNoodles extends FastFood{\n    public FriedNoodles(float price, String description) {\n        super(20, \"炒面\");\n    }\n}\n```\n\n装饰者抽象类\n\n```java\n/**\n * 装饰者本身既要继承/实现快餐类，并且要聚合被快餐类！\n * 因为鸡蛋培根都是装饰者的子类，该鸡蛋培根的子类是给快餐装饰的，所以鸡蛋培根快餐属于同一族，因此装饰者要继承快餐类，这样子鸡蛋培根就跟快餐同一族，\n * 拥有相同的属性，这样才能凑合。\n * 对于装饰者本身就是属于鸡蛋、培根，但是装饰者的字段是快餐\n *\n */\npublic abstract class Garnish extends FastFood{\n    private FastFood fastFood;\n\n    public FastFood getFastFood() {\n        return fastFood;\n    }\n\n//    给子类实现，实例化为鸡蛋、培根，这样装饰者本身是鸡蛋、培根。而FastFood是本来就有的快餐，赋值给装饰者字段\n    public Garnish(float price, String description, FastFood fastFood) {\n        super(price, description);\n        this.fastFood = fastFood;\n    }\n\n    public abstract float cost();\n\n}\n```\n\n装饰者的子类\n\n```java\n//Garnish实现了FastFood所以才有价格，描述的属性，getPrice只是获取鸡蛋的价格，注意继承类，只是继承类的字段，字段的具体值由子类决定，所以说为什么这里的价格只是鸡蛋的价格。\npublic class Egg extends Garnish{\n\n    public Egg(FastFood fastFood) {\n        super(1, \"鸡蛋\", fastFood);\n    }\n\n    @Override\n    public float cost() {\n        return getPrice()+ getFastFood().getPrice();\n    }\n\n    @Override\n    public String getDescription() {\n        return super.getDescription()+getFastFood().getDescription();\n    }\n}\n```\n\n测试类\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        FastFood rice = new FriedRice();\n        System.out.println(rice.getDescription()+\"  \"+rice.getPrice());\n//        炒饭  10.0\n        Egg egg = new Egg(rice);\n        System.out.println(egg.getDescription()+\"   \"+egg.cost());\n//        鸡蛋炒饭   11.0\n    }\n}\n```\n\n\n\n**好处：**\n\n* 饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任。\n\n* 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。\n\n## 3.4 桥接模式\n\n### 5.4.1 概述\n\n现在有一个需求，需要创建不同的图形，并且每个图形都有可能会有不同的颜色。我们可以利用继承的方式来设计类的关系：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b8135ce6beda429d880509790cb65f98.png#pic_center)\n\n\n我们可以发现有很多的类，假如我们再增加一个形状或再增加一种颜色，就需要创建更多的类。\n\n试想，在一个有多种可能会变化的维度的系统中，用继承方式会造成类爆炸，扩展起来不灵活。每次在一个维度上新增一个具体实现都要增加多个子类。为了更加灵活的设计系统，我们此时可以考虑使用桥接模式。\n\n**定义：**\n\n​	将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。\n\n\n\n### 3.4.2 结构\n\n桥接（Bridge）模式包含以下主要角色：\n\n* 抽象化（Abstraction）角色 ：定义抽象类，并包含一个对实现化对象的引用。\n* 扩展抽象化（Refined  Abstraction）角色 ：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。\n* 实现化（Implementor）角色 ：定义实现化角色的接口，供扩展抽象化角色调用。\n* 具体实现化（Concrete Implementor）角色 ：给出实现化角色接口的具体实现。\n\n### 3.4.3 案例\n\n【例】视频播放器\n\n需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等。该播放器包含了两个维度，适合使用桥接模式。\n\n类图如下：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/34cba7a4e76f4da78727d2298754e361.png#pic_center)\n\n\n\n\n代码如下：\n\n```java\n//视频文件\npublic interface VideoFile {\n    void decode(String fileName);\n}\n\n//avi文件\npublic class AVIFile implements VideoFile {\n    public void decode(String fileName) {\n        System.out.println(\"avi视频文件：\"+ fileName);\n    }\n}\n\n//rmvb文件\npublic class REVBBFile implements VideoFile {\n\n    public void decode(String fileName) {\n        System.out.println(\"rmvb文件：\" + fileName);\n    }\n}\n\n//操作系统版本\npublic abstract class OperatingSystemVersion {\n\n    protected VideoFile videoFile;\n\n    public OperatingSystemVersion(VideoFile videoFile) {\n        this.videoFile = videoFile;\n    }\n\n    public abstract void play(String fileName);\n}\n\n//Windows版本\npublic class Windows extends OperatingSystem {\n\n    public Windows(VideoFile videoFile) {\n        super(videoFile);\n    }\n\n    public void play(String fileName) {\n        videoFile.decode(fileName);\n    }\n}\n\n//mac版本\npublic class Mac extends OperatingSystemVersion {\n\n    public Mac(VideoFile videoFile) {\n        super(videoFile);\n    }\n\n    public void play(String fileName) {\n		videoFile.decode(fileName);\n    }\n}\n\n//测试类\npublic class Client {\n    public static void main(String[] args) {\n        OperatingSystem os = new Windows(new AVIFile());\n        os.play(\"战狼3\");\n    }\n}\n```\n\n**好处：**\n\n* 桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。\n\n  如：如果现在还有一种视频文件类型wmv，我们只需要再定义一个类实现VideoFile接口即可，其他类不需要发生变化。\n\n* 实现细节对客户透明\n\n### 3.4.4 使用场景\n\n* 当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。\n* 当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。\n* 当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。\n\n## 3.5 外观模式\n\n### 3.5.1 概述\n\n有些人可能炒过股票，但其实大部分人都不太懂，这种没有足够了解证券知识的情况下做股票是很容易亏钱的，刚开始炒股肯定都会想，如果有个懂行的帮帮手就好，其实基金就是个好帮手，支付宝里就有许多的基金，它将投资者分散的资金集中起来，交由专业的经理人进行管理，投资于股票、债券、外汇等领域，而基金投资的收益归持有者所有，管理机构收取一定比例的托管管理费用。\n\n**定义：**\n\n​	又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。\n\n​	外观（Facade）模式是“迪米特法则”的典型应用\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/0aedecfb7114485c9b0d59c860499b77.png#pic_center)\n\n\n\n\n### 3.5.2 结构\n\n外观（Facade）模式包含以下主要角色：\n\n* 外观（Facade）角色：为多个子系统对外提供一个共同的接口。\n* 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。\n\n### 3.5.3 案例\n\n【例】智能家电控制\n\n小明的爷爷已经60岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；操作起来都比较麻烦。所以小明给爷爷买了智能音箱，可以通过语音直接控制这些智能家电的开启和关闭。类图如下：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d76aca27d02b4f5995cbc5506bcfd117.png#pic_center)\n\n\n代码如下：\n\n```java\n//灯类\npublic class Light {\n    public void on() {\n        System.out.println(\"打开了灯....\");\n    }\n\n    public void off() {\n        System.out.println(\"关闭了灯....\");\n    }\n}\n\n//电视类\npublic class TV {\n    public void on() {\n        System.out.println(\"打开了电视....\");\n    }\n\n    public void off() {\n        System.out.println(\"关闭了电视....\");\n    }\n}\n\n//控制类\npublic class AirCondition {\n    public void on() {\n        System.out.println(\"打开了空调....\");\n    }\n\n    public void off() {\n        System.out.println(\"关闭了空调....\");\n    }\n}\n\n//智能音箱\npublic class SmartAppliancesFacade {\n\n    private Light light;\n    private TV tv;\n    private AirCondition airCondition;\n\n    public SmartAppliancesFacade() {\n        light = new Light();\n        tv = new TV();\n        airCondition = new AirCondition();\n    }\n\n    public void say(String message) {\n        if(message.contains(\"打开\")) {\n            on();\n        } else if(message.contains(\"关闭\")) {\n            off();\n        } else {\n            System.out.println(\"我还听不懂你说的！！！\");\n        }\n    }\n\n    //起床后一键开电器\n    private void on() {\n        System.out.println(\"起床了\");\n        light.on();\n        tv.on();\n        airCondition.on();\n    }\n\n    //睡觉一键关电器\n    private void off() {\n        System.out.println(\"睡觉了\");\n        light.off();\n        tv.off();\n        airCondition.off();\n    }\n}\n\n//测试类\npublic class Client {\n    public static void main(String[] args) {\n        //创建外观对象\n        SmartAppliancesFacade facade = new SmartAppliancesFacade();\n        //客户端直接与外观对象进行交互\n        facade.say(\"打开家电\");\n        facade.say(\"关闭家电\");\n    }\n}\n```\n\n**好处：**\n\n* 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。\n* 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。\n\n**缺点：**\n\n* 不符合开闭原则，修改很麻烦\n\n\n\n### 3.5.4 使用场景\n\n* 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。\n* 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。\n* 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。\n\n\n\n### 3.5.5 源码解析\n\n使用tomcat作为web容器时，接收浏览器发送过来的请求，tomcat会将请求信息封装成ServletRequest对象，如下图①处对象。但是大家想想ServletRequest是一个接口，它还有一个子接口HttpServletRequest，而我们知道该request对象肯定是一个HttpServletRequest对象的子实现类对象，到底是哪个类的对象呢？可以通过输出request对象，我们就会发现是一个名为RequestFacade的类的对象。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7fe45f1701074db582d0ed201b065e09.png#pic_center)\n\n\nRequestFacade类就使用了外观模式。先看结构图：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a6a2954b0b504f30a4275377103f9678.png#pic_center)\n\n\n**为什么在此处使用外观模式呢？**\n\n定义 RequestFacade 类，分别实现 ServletRequest ，同时定义私有成员变量 Request ，并且方法的实现调用 Request  的实现。然后，将 RequestFacade上转为 ServletRequest  传给 servlet 的 service 方法，这样即使在 servlet 中被下转为 RequestFacade ，也不能访问私有成员变量对象中的方法。既用了 Request ，又能防止其中方法被不合理的访问。\n\n## 3.6 组合模式\n\n### 3.6.1 概述\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/9989fa411d994b33832dadd593a89fab.png#pic_center)\n\n\n​	对于这个图片肯定会非常熟悉，上图我们可以看做是一个文件系统，对于这样的结构我们称之为树形结构。在树形结构中可以通过调用某个方法来遍历整个树，当我们找到某个叶子节点后，就可以对叶子节点进行相关的操作。可以将这颗树理解成一个大的容器，容器里面包含很多的成员对象，这些成员对象即可是容器对象也可以是叶子对象。但是由于容器对象和叶子对象在功能上面的区别，使得我们在使用的过程中必须要区分容器对象和叶子对象，但是这样就会给客户带来不必要的麻烦，作为客户而已，它始终希望能够一致的对待容器对象和叶子对象。\n\n**定义：**\n\n​	又名部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。\n\n### 3.6.2 结构\n\n组合模式主要包含三种角色：\n\n* 抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。\n* 树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。\n* 叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。\n\n### 3.6.3 案例实现\n\n【例】软件菜单\n\n如下图，我们在访问别的一些管理系统时，经常可以看到类似的菜单。一个菜单可以包含菜单项（菜单项是指不再包含其他内容的菜单条目），也可以包含带有其他菜单项的菜单，因此使用组合模式描述菜单就很恰当，我们的需求是针对一个菜单，打印出其包含的所有菜单以及菜单项的名称。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d5465a9b244a4709b3575d1265517d12.png#pic_center)\n\n\n要实现该案例，我们先画出类图：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e797c989e5a54ffa9d08c557a90c4b06.png#pic_center)\n\n\n**代码实现：**\n\n不管是菜单还是菜单项，都应该继承自统一的接口，这里姑且将这个统一的接口称为菜单组件。\n\n```java\n//菜单组件  不管是菜单还是菜单项，都应该继承该类\npublic abstract class MenuComponent {\n\n    protected String name;\n    protected int level;\n\n    //添加菜单\n    public void add(MenuComponent menuComponent){\n        throw new UnsupportedOperationException();\n    }\n\n    //移除菜单\n    public void remove(MenuComponent menuComponent){\n        throw new UnsupportedOperationException();\n    }\n\n    //获取指定的子菜单\n    public MenuComponent getChild(int i){\n        throw new UnsupportedOperationException();\n    }\n\n    //获取菜单名称\n    public String getName(){\n        return name;\n    }\n\n    public void print(){\n        throw new UnsupportedOperationException();\n    }\n}\n```\n\n这里的MenuComponent定义为抽象类，因为有一些共有的属性和行为要在该类中实现，Menu和MenuItem类就可以只覆盖自己感兴趣的方法，而不用搭理不需要或者不感兴趣的方法，举例来说，Menu类可以包含子菜单，因此需要覆盖add()、remove()、getChild()方法，但是MenuItem就不应该有这些方法。这里给出的默认实现是抛出异常，你也可以根据自己的需要改写默认实现。\n\n```java\npublic class Menu extends MenuComponent {\n\n    private List<MenuComponent> menuComponentList;\n\n    public Menu(String name,int level){\n        this.level = level;\n        this.name = name;\n        menuComponentList = new ArrayList<MenuComponent>();\n    }\n\n    @Override\n    public void add(MenuComponent menuComponent) {\n        menuComponentList.add(menuComponent);\n    }\n\n    @Override\n    public void remove(MenuComponent menuComponent) {\n        menuComponentList.remove(menuComponent);\n    }\n\n    @Override\n    public MenuComponent getChild(int i) {\n        return menuComponentList.get(i);\n    }\n\n    @Override\n    public void print() {\n\n        for (int i = 1; i < level; i++) {\n            System.out.print(\"--\");\n        }\n        System.out.println(name);\n        for (MenuComponent menuComponent : menuComponentList) {\n            menuComponent.print();\n        }\n    }\n}\n```\n\nMenu类已经实现了除了getName方法的其他所有方法，因为Menu类具有添加菜单，移除菜单和获取子菜单的功能。\n\n```java\npublic class MenuItem extends MenuComponent {\n\n    public MenuItem(String name,int level) {\n        this.name = name;\n        this.level = level;\n    }\n\n    @Override\n    public void print() {\n        for (int i = 1; i < level; i++) {\n            System.out.print(\"--\");\n        }\n        System.out.println(name);\n    }\n}\n```\n\nMenuItem是菜单项，不能再有子菜单，所以添加菜单，移除菜单和获取子菜单的功能并不能实现。\n\n\n\n### 3.6.4 组合模式的分类\n\n在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式。\n\n* 透明组合模式\n\n  透明组合模式中，抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中 `MenuComponent` 声明了 `add`、`remove` 、`getChild` 方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。\n\n  透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 add()、remove() 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）\n\n* 安全组合模式\n\n  在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点 `Menu` 类中声明并实现这些方法。安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。\n\n  ![在这里插入图片描述](https://img-blog.csdnimg.cn/14145de2f378443184306c5c932da46c.png#pic_center)\n\n\n\n\n### 3.6.5 优点\n\n* 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。\n* 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。\n* 在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”。\n* 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。\n\n\n\n### 3.6.6 使用场景\n\n组合模式正是应树形结构而生，所以组合模式的使用场景就是出现树形结构的地方。比如：文件目录显示，多级目录呈现等树形结构数据的操作。\n## 3.7 享元模式\n\n# 4. 行为型模式\n\n行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。\n\n行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。\n\n行为型模式分为：\n\n* 模板方法模式\n* 策略模式\n* 命令模式\n* 职责链模式\n* 状态模式\n* 观察者模式\n* 中介者模式\n* 迭代器模式\n* 访问者模式\n* 备忘录模式\n* 解释器模式\n\n以上 11 种行为型模式，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式。\n\n## 4.1 模板方法模式\n\n### 4.1.1 概述\n\n在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。\n\n例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。\n\n**定义：**\n\n==定义一个操作中的算法骨架，其实就是方法的执行顺序固定==，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。\n\n###  4.1.2 结构\n\n模板方法（Template Method）模式包含以下主要角色：\n\n* 抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。\n\n  * 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。\n\n  * 基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：\n\n    * 抽象方法(Abstract Method) ：一个抽象方法由抽象类声明、由其具体子类实现。\n\n    * 具体方法(Concrete Method) ：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。\n\n    * 钩子方法(Hook Method) ：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。\n\n      一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。\n\n* 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。\n\n【例子】\n\n学生行为包括：先揉眼睛、看xx、闭上眼睛。但是前后一个都是必经的，所以我们不妨提取出骨架，保证执行顺序，但是具体看什么，由具体类实现具体看什么。比如看书、看电影。\n\n> 代码\n\n```java\n//学生行为抽象类\npublic abstract class StudentBehavior {\n    abstract void look();\n\n    //这里就是模板方法的算法骨架。我们把骨架放在抽象类（实体类也行，但是抽象类更符合，因为我们要去子类实现骨架中的方法）\n    //而look则是由子类实现，子类可以不同方式实现，骨架不动。look()调用，同个类的实例方法调用，完整写法：this.look()，但可以省略的\n    public void process(){\n        System.out.println(\"先揉眼睛\");\n        look();\n        System.out.println(\"闭上眼睛\");\n    }\n}\n```\n\n具体类\n\n```java\npublic class StudentBook extends StudentBehavior{\n    @Override\n    public void look() {\n        System.out.println(\"子类在看->书\");\n    }\n}\npublic class StudentFilm extends StudentBehavior{\n    @Override\n    void look() {\n        System.out.println(\"子类在看->电影\");\n    }\n}\n```\n\n测试：\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        StudentBehavior studentBook = new StudentBook();\n        studentBook.process();\n        StudentBehavior studentFilm = new StudentFilm();\n        studentFilm.process();\n       /* 先揉眼睛\n            子类在看->书\n          闭上眼睛\n        =============\n         先揉眼睛\n            子类在看->电影\n         闭上眼睛*/\n    }\n}\n```\n\n### 4.1.3 优缺点\n\n**优点：**\n\n* 提高代码复用性\n\n  将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。\n\n* 实现了反向控制\n\n  通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。\n\n**缺点：**\n\n* 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。\n* 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。\n\n\n\n### 4.1.4 适用场景\n\n* 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\n* 需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。\n\n### 4.1.5 JDK源码解析\n\nInputStream类就使用了模板方法模式。在InputStream类中定义了多个 `read()` 方法，如下：\n\n```java\npublic abstract class InputStream implements Closeable {\n    //抽象方法，要求子类必须重写\n    public abstract int read() throws IOException;\n\n    public int read(byte b[]) throws IOException {\n        return read(b, 0, b.length);\n    }\n\n    public int read(byte b[], int off, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (off < 0 || len < 0 || len > b.length - off) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        }\n\n        int c = read(); //调用了无参的read方法，该方法是每次读取一个字节数据\n        if (c == -1) {\n            return -1;\n        }\n        b[off] = (byte)c;\n\n        int i = 1;\n        try {\n            for (; i < len ; i++) {\n                c = read();\n                if (c == -1) {\n                    break;\n                }\n                b[off + i] = (byte)c;\n            }\n        } catch (IOException ee) {\n        }\n        return i;\n    }\n}\n```\n\n从上面代码可以看到，无参的 `read()` 方法是抽象方法，要求子类必须实现。而 `read(byte b[])` 方法调用了 `read(byte b[], int off, int len)` 方法，所以在此处重点看的方法是带三个参数的方法。 \n\n在该方法中第18行、27行，可以看到调用了无参的抽象的 `read()` 方法。\n\n总结如下： 在InputStream父类中已经定义好了读取一个字节数组数据的方法是每次读取一个字节，并将其存储到数组的第一个索引位置，读取len个字节数据。具体如何读取一个字节数据呢？由子类实现。\n\n## 4.2 策略模式\n\n### 4.2.1 概述\n\n先看下面的图片，我们去旅游选择出行模式有很多种，可以骑自行车、可以坐汽车、可以坐火车、可以坐飞机。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2e43bbc948ab49e992aa7a11f112fda3.png#pic_center)\n\n\n\n\n**定义：**\n\n​	==该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。==策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。\n\n### 4.2.2 结构\n\n策略模式的主要角色如下：\n\n* 抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。\n* 具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。\n* 环境（Context）类：持有一个策略类的引用，最终给客户端调用。\n\n【例子】\n\n> 代码\n\n移动接口\n\n```java\npublic interface StrategyMove {    void move();}\n```\n\n移动实现类\n\n```java\npublic class StrategyRun implements StrategyMove{\n    @Override\n    public void move() {\n        System.out.println(\"跑步\");\n    }\n}\n\npublic class StrategyWalk implements StrategyMove{\n\n    @Override\n    public void move() {\n        System.out.println(\"走路\");\n    }\n}\n```\n\n实现的对象（其实可以抽象化更好）又叫环境角色类\n\n```java\n/*\npublic abstract People implements StrategyMove{\n    @Override\n    public void move() {\n\n    }\n}\n这是反例!\n虽然我们可以理解说接口就是功能，但也不能作用在对象身上，\n因为如果新增People的子类，那就要重写父类方法，有些移动方法在其他对象其实已经写过了。\n如果新增了移动方法，那么所有的对象都要新增，维护成本极大！\n算法的变化不会影响使用算法的客户才行！而不是新增一个移动，就要新增改造对象。\n**希望的是移动方法由客户来替换而不是去改客户的代码！**\n《合成复用原则》\n*/\n\npublic class People {\n    StrategyMove strategyMove;\n\n    public People(StrategyMove strategyMove) {\n        this.strategyMove = strategyMove;\n    }\n    public void move(){\n        strategyMove.move();\n    }\n}\n```\n\n测试\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        People people1 = new People(new StrategyRun());\n        people1.move();\n        People people2 = new People(new StrategyWalk());\n        people2.move();\n    }\n}\n```\n\n### 4.2.4 优缺点\n\n**1，优点：**\n\n* 策略类之间可以自由切换\n\n  由于策略类都实现同一个接口，所以使它们之间可以自由切换。\n\n* 易于扩展\n\n  增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则“\n\n* 避免使用多重条件选择语句（if else），充分体现面向对象设计思想。\n\n**2，缺点：**\n\n* 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。\n* 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。\n\n### 4.2.5 使用场景\n\n* 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\n* 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\n* 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\n* 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。\n* 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\n\n### 4.2.6 JDK源码解析\n\n`Comparator` 中的策略模式。在Arrays类中有一个 `sort()` 方法，如下：\n\n```java\npublic class Arrays{\n    public static <T> void sort(T[] a, Comparator<? super T> c) {\n        if (c == null) {\n            sort(a);\n        } else {\n            if (LegacyMergeSort.userRequested)\n                legacyMergeSort(a, c);\n            else\n                TimSort.sort(a, 0, a.length, c, null, 0, 0);\n        }\n    }\n}\n```\n\nArrays就是一个环境角色类，这个sort方法可以传一个新策略让Arrays根据这个策略来进行排序。就比如下面的测试类。\n\n```java\npublic class demo {\n    public static void main(String[] args) {\n\n        Integer[] data = {12, 2, 3, 2, 4, 5, 1};\n        // 实现降序排序\n        Arrays.sort(data, new Comparator<Integer>() {\n            public int compare(Integer o1, Integer o2) {\n                return o2 - o1;\n            }\n        });\n        System.out.println(Arrays.toString(data)); //[12, 5, 4, 3, 2, 2, 1]\n    }\n}\n```\n\n这里我们在调用Arrays的sort方法时，第二个参数传递的是Comparator接口的子实现类对象。所以Comparator充当的是抽象策略角色，而具体的子实现类充当的是具体策略角色。环境角色类（Arrays）应该持有抽象策略的引用来调用。那么，Arrays类的sort方法到底有没有使用Comparator子实现类中的 `compare()` 方法吗？让我们继续查看TimSort类的 `sort()` 方法，代码如下：\n\n```java\nclass TimSort<T> {\n    static <T> void sort(T[] a, int lo, int hi, Comparator<? super T> c,\n                         T[] work, int workBase, int workLen) {\n        assert c != null && a != null && lo >= 0 && lo <= hi && hi <= a.length;\n\n        int nRemaining  = hi - lo;\n        if (nRemaining < 2)\n            return;  // Arrays of size 0 and 1 are always sorted\n\n        // If array is small, do a \"mini-TimSort\" with no merges\n        if (nRemaining < MIN_MERGE) {\n            int initRunLen = countRunAndMakeAscending(a, lo, hi, c);\n            binarySort(a, lo, hi, lo + initRunLen, c);\n            return;\n        }\n        ...\n    }   \n        \n    private static <T> int countRunAndMakeAscending(T[] a, int lo, int hi,Comparator<? super T> c) {\n        assert lo < hi;\n        int runHi = lo + 1;\n        if (runHi == hi)\n            return 1;\n\n        // Find end of run, and reverse range if descending\n        if (c.compare(a[runHi++], a[lo]) < 0) { // Descending\n            while (runHi < hi && c.compare(a[runHi], a[runHi - 1]) < 0)\n                runHi++;\n            reverseRange(a, lo, runHi);\n        } else {                              // Ascending\n            while (runHi < hi && c.compare(a[runHi], a[runHi - 1]) >= 0)\n                runHi++;\n        }\n\n        return runHi - lo;\n    }\n}\n```\n\n上面的代码中最终会跑到 `countRunAndMakeAscending()` 这个方法中。我们可以看见，只用了compare方法，所以在调用Arrays.sort方法只传具体compare重写方法的类对象就行，这也是Comparator接口中必须要子类实现的一个方法。\n\n## 4.3 命令模式\n\n### 4.3.1 概述\n\n日常生活中，我们出去吃饭都会遇到下面的场景。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/5086452cfc0449e4a79b2a9e2ca8d3e2.png#pic_center)\n\n\n**定义：**\n\n将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。\n\n\n\n### 4.3.2 结构\n\n命令模式包含以下主要角色：\n\n* 抽象命令类（Command）角色： 定义命令的接口，声明执行的方法。\n* 具体命令（Concrete  Command）角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。\n* 实现者/接收者（Receiver）角色： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。\n* 调用者/请求者（Invoker）角色： 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。\n\n\n\n### 4.3.3 案例实现\n\n将上面的案例用代码实现，那我们就需要分析命令模式的角色在该案例中由谁来充当。\n\n服务员： 就是调用者角色，由她来发起命令。\n\n资深大厨： 就是接收者角色，真正命令执行的对象。\n\n订单： 命令中包含订单。\n\n类图如下：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ad057e08769a4ec4abab4d39368fbbec.png#pic_center)\n\n\n代码如下：\n\n```java\npublic interface Command {\n    void execute();//只需要定义一个统一的执行方法\n}\n\npublic class OrderCommand implements Command {\n\n    //持有接受者对象\n    private SeniorChef receiver;\n    private Order order;\n\n    public OrderCommand(SeniorChef receiver, Order order){\n        this.receiver = receiver;\n        this.order = order;\n    }\n\n    public void execute()  {\n        System.out.println(order.getDiningTable() + \"桌的订单：\");\n        Set<String> keys = order.getFoodDic().keySet();\n        for (String key : keys) {\n            receiver.makeFood(order.getFoodDic().get(key),key);\n        }\n\n        try {\n            Thread.sleep(100);//停顿一下 模拟做饭的过程\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n\n        System.out.println(order.getDiningTable() + \"桌的饭弄好了\");\n    }\n}\n\npublic class Order {\n    // 餐桌号码\n    private int diningTable;\n\n    // 用来存储餐名并记录份数\n    private Map<String, Integer> foodDic = new HashMap<String, Integer>();\n\n    public int getDiningTable() {\n        return diningTable;\n    }\n\n    public void setDiningTable(int diningTable) {\n        this.diningTable = diningTable;\n    }\n\n    public Map<String, Integer> getFoodDic() {\n        return foodDic;\n    }\n\n    public void setFoodDic(String name, int num) {\n        foodDic.put(name,num);\n    }\n}\n\n// 资深大厨类 是命令的Receiver\npublic class SeniorChef {\n\n    public void makeFood(int num,String foodName) {\n        System.out.println(num + \"份\" + foodName);\n    }\n}\n\npublic class Waitor {\n\n    private ArrayList<Command> commands;//可以持有很多的命令对象\n\n    public Waitor() {\n        commands = new ArrayList();\n    }\n    \n    public void setCommand(Command cmd){\n        commands.add(cmd);\n    }\n\n    // 发出命令 喊 订单来了，厨师开始执行\n    public void orderUp() {\n        System.out.println(\"美女服务员：叮咚，大厨，新订单来了.......\");\n        for (int i = 0; i < commands.size(); i++) {\n            Command cmd = commands.get(i);\n            if (cmd != null) {\n                cmd.execute();\n            }\n        }\n    }\n}\n\npublic class Client {\n    public static void main(String[] args) {\n        //创建2个order\n        Order order1 = new Order();\n        order1.setDiningTable(1);\n        order1.getFoodDic().put(\"西红柿鸡蛋面\",1);\n        order1.getFoodDic().put(\"小杯可乐\",2);\n\n        Order order2 = new Order();\n        order2.setDiningTable(3);\n        order2.getFoodDic().put(\"尖椒肉丝盖饭\",1);\n        order2.getFoodDic().put(\"小杯雪碧\",1);\n\n        //创建接收者\n        SeniorChef receiver=new SeniorChef();\n        //将订单和接收者封装成命令对象\n        OrderCommand cmd1 = new OrderCommand(receiver, order1);\n        OrderCommand cmd2 = new OrderCommand(receiver, order2);\n        //创建调用者 waitor\n        Waitor invoker = new Waitor();\n        invoker.setCommand(cmd1);\n        invoker.setCommand(cmd2);\n\n        //将订单带到柜台 并向厨师喊 订单来了\n        invoker.orderUp();\n    }\n}\n```\n\n\n\n### 4.3.4 优缺点\n\n**1，优点：**\n\n* 降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。\n* 增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。\n* 可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。\n* 方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。\n\n**2，缺点：**\n\n* 使用命令模式可能会导致某些系统有过多的具体命令类。\n* 系统结构更加复杂。\n\n\n\n### 4.3.5 使用场景\n\n* 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。\n* 系统需要在不同的时间指定请求、将请求排队和执行请求。\n* 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。\n\n\n\n### 4.3.6 JDK源码解析\n\nRunable是一个典型命令模式，Runnable担当命令的角色，Thread充当的是调用者，start方法就是其执行方法\n\n```java\n//命令接口(抽象命令角色)\npublic interface Runnable {\n	public abstract void run();\n}\n\n//调用者\npublic class Thread implements Runnable {\n    private Runnable target;\n    \n    public synchronized void start() {\n        if (threadStatus != 0)\n            throw new IllegalThreadStateException();\n\n        group.add(this);\n\n        boolean started = false;\n        try {\n            start0();\n            started = true;\n        } finally {\n            try {\n                if (!started) {\n                    group.threadStartFailed(this);\n                }\n            } catch (Throwable ignore) {\n            }\n        }\n    }\n    \n    private native void start0();\n}\n```\n\n会调用一个native方法start0(),调用系统方法，开启一个线程。而接收者是对程序员开放的，可以自己定义接收者。\n\n```java\n/**\n * jdk Runnable 命令模式\n *		TurnOffThread ： 属于具体\n */\npublic class TurnOffThread implements Runnable{\n     private Receiver receiver;\n    \n     public TurnOffThread(Receiver receiver) {\n     	this.receiver = receiver;\n     }\n     public void run() {\n     	receiver.turnOFF();\n     }\n}\n```\n\n```java\n/**\n * 测试类\n */\npublic class Demo {\n     public static void main(String[] args) {\n         Receiver receiver = new Receiver();\n         TurnOffThread turnOffThread = new TurnOffThread(receiver);\n         Thread thread = new Thread(turnOffThread);\n         thread.start();\n     }\n}\n```\n\n## 4.4 责任链模式\n\n### 4.4.1 概述\n\n在现实生活中，常常会出现这样的事例：一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。例如，公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这增加了难度。这样的例子还有很多，如找领导出差报销、生活中的“击鼓传花”游戏等。\n\n**定义：**\n\n又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。\n\n\n\n### 4.4.2 结构\n\n职责链模式主要包含以下角色:\n\n* 抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。\n* 具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。\n* 客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。\n\n\n\n### 4.4.3 案例实现\n\n一人想要借钱，有三个老板可以提供借钱，A老板最多借50元，B老板最多借钱100元，C老板最多借钱200元。\n\n> 代码\n>\n\n抽象老板类\n\n```java\npublic abstract class AbstractBoss {\n    protected static final int MONEY_50=50;\n    protected static final int MONEY_100=100;\n    protected static final int MONEY_200=200;\n\n    private int hasMoney;\n    private AbstractBoss nextBoss;\n\n    public AbstractBoss(int hasMoney) {\n        this.hasMoney = hasMoney;\n    }\n\n    public int getHasMoney() {\n        return hasMoney;\n    }\n\n    public void setAbstractBoss(AbstractBoss nextBoss) {\n        this.nextBoss = nextBoss;\n    }\n\n    //不允许子类重写，属于结构型模式中模板方法模式，process是骨架,抽象lend由子类实现。\n    public final void process(int needMoney){\n        if (needMoney<=this.hasMoney){\n            lend(needMoney);\n        }else if (null!=this.nextBoss){\n            this.nextBoss.process(needMoney);\n        }\n    }\n\n    protected abstract void lend(int needMoney);\n}\n```\n\n具体老板类\n\n```java\npublic class BossA extends AbstractBoss{\n    public BossA(int hasMoney) {\n        super(hasMoney);\n    }\n\n    @Override\n    protected void lend(int needMoney) {\n        System.out.print(\"A老板借出去\"+needMoney+\"元\");\n    }\n}\n\npublic class BossB extends AbstractBoss{\n    public BossB(int hasMoney) {\n        super(hasMoney);\n    }\n\n    @Override\n    protected void lend(int needMoney) {\n        System.out.print(\"B老板借出去\"+needMoney+\"元\");\n    }\n}\n\npublic class BossC extends AbstractBoss{\n    public BossC(int hasMoney) {\n        super(hasMoney);\n    }\n\n    @Override\n    protected void lend(int needMoney) {\n        System.out.print(\"C老板借出去\"+needMoney+\"元\");\n    }\n}\n```\n\n测试类\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        AbstractBoss bossA = new BossA(AbstractBoss.MONEY_50);\n        AbstractBoss bossB = new BossB(AbstractBoss.MONEY_100);\n        AbstractBoss bossC = new BossC(AbstractBoss.MONEY_200);\n\n        //职责链从低层向上引用！确保钱被最佳化处理\n        bossA.setAbstractBoss(bossB);\n        bossB.setAbstractBoss(bossC);\n\n        bossA.process(49);System.out.println(\"(over)\");\n        bossA.process(99);System.out.println(\"(over)\");\n        bossA.process(199);System.out.println(\"(over)\");\n        bossA.process(201);System.out.println(\"(over)\");\n\n    }\n}\nA老板借出去49元(over)\nB老板借出去99元(over)\nC老板借出去199元(over)\n(over)\n```\n\n## 4.5 观察者模式\n\n### 4.5.1 概述\n\n**定义：**\n\n又被称为发布-订阅（Publish/Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。\n\n\n\n### 4.5.2 结构\n\n在观察者模式中有如下角色：\n\n* Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。\n* ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。\n* Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。\n* ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。\n\n### 4.5.3 案例实现\n\n【例】微信公众号\n\n在使用微信公众号时，大家都会有这样的体验，当你关注的公众号中有新内容更新的话，它就会推送给关注公众号的微信用户端。我们使用观察者模式来模拟这样的场景，微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了程序猿这个公众号。\n\n类图如下：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d9bf7fee5021423b972cd645ea0d32f7.png#pic_center)\n\n\n代码如下：\n\n定义抽象观察者类，里面定义一个更新的方法\n\n```java\npublic interface Observer {\n    void update(String message);\n}\n```\n\n定义具体观察者类，微信用户是观察者，里面实现了更新的方法\n\n```java\npublic class WeixinUser implements Observer {\n    // 微信用户名\n    private String name;\n\n    public WeixinUser(String name) {\n        this.name = name;\n    }\n    @Override\n    public void update(String message) {\n        System.out.println(name + \"-\" + message);\n    }\n}\n```\n\n定义抽象主题类，提供了attach、detach、notify三个方法\n\n```java\npublic interface Subject {\n    //增加订阅者\n    public void attach(Observer observer);\n\n    //删除订阅者\n    public void detach(Observer observer);\n    \n    //通知订阅者更新消息\n    public void notify(String message);\n}\n\n```\n\n微信公众号是具体主题（具体被观察者），里面存储了订阅该公众号的微信用户，并实现了抽象主题中的方法\n\n```java\npublic class SubscriptionSubject implements Subject {\n    //储存订阅公众号的微信用户\n    private List<Observer> weixinUserlist = new ArrayList<Observer>();\n\n    @Override\n    public void attach(Observer observer) {\n        weixinUserlist.add(observer);\n    }\n\n    @Override\n    public void detach(Observer observer) {\n        weixinUserlist.remove(observer);\n    }\n\n    @Override\n    public void notify(String message) {\n        for (Observer observer : weixinUserlist) {\n            observer.update(message);\n        }\n    }\n}\n```\n\n客户端程序\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        SubscriptionSubject mSubscriptionSubject=new SubscriptionSubject();\n        //创建微信用户\n        WeixinUser user1=new WeixinUser(\"孙悟空\");\n        WeixinUser user2=new WeixinUser(\"猪悟能\");\n        WeixinUser user3=new WeixinUser(\"沙悟净\");\n        //订阅公众号\n        mSubscriptionSubject.attach(user1);\n        mSubscriptionSubject.attach(user2);\n        mSubscriptionSubject.attach(user3);\n        //公众号更新发出消息给订阅的微信用户\n        mSubscriptionSubject.notify(\"传智黑马的专栏更新了\");\n    }\n}\n\n```\n\n### 4.5.4 使用场景\n\n* 对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。\n* 当一个抽象模型有两个方面，其中一个方面依赖于另一方面时。\n\n### 4.5.5 JDK实现\n\n在 Java 中，通过 java.util.Observable 类和 java.util.Observer 接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。\n\n**1，Observable类**\n\nObservable 类是抽象目标类（被观察者），它有一个 Vector 集合成员变量，用于保存所有要通知的观察者对象，下面来介绍它最重要的 3 个方法。\n\n* void addObserver(Observer o) 方法：用于将新的观察者对象添加到集合中。\n\n* void notifyObservers(Object arg) 方法：调用集合中的所有观察者对象的 update方法，通知它们数据发生改变。通常越晚加入集合的观察者越先得到通知。\n\n* void setChange() 方法：用来设置一个 boolean 类型的内部标志，注明目标对象发生了变化。当它为true时，notifyObservers() 才会通知观察者。\n\n**2，Observer 接口**\n\nObserver 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 update 方法，进行相应的工作。\n\n【例子】\n\n多个警察抓一个小偷。\n\n警察\n\n```java\n//实现了这个接口 只是单单说明了警察是观察者。update是回调函数。\npublic class Police implements Observer {\n    @Override\n    public void update(Observable o, Object arg) {\n        Thief o1 = (Thief) o;\n        System.out.println(\"成功抓获小偷：\"+o1.getName());\n    }\n}\n```\n\n小偷\n\n```java\n//小偷继承Observable表示是可以被观察的类。\npublic class Thief extends Observable {\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Thief() {\n        setChanged();\n    }\n\n    protected void steal(){\n        System.out.println(\"小偷正在偷东西！\");\n        notifyObservers();//底层遍历了所有观察者并逐个执行其update方法。\n    }\n\n}\n```\n\n测试类\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        Thief thief = new Thief();\n        Police police = new Police();\n\n        thief.setName(\"肥莫\");\n//        添加为小偷的观察者，才能使得警察的观察有作用，也就是update可以被调用了\n        thief.addObserver(police);\n\n        thief.steal();\n    }\n}\n```\n## 4.6 状态模式\n\n## 4.7 中介者模式\n\n## 4.8 迭代器模式\n\n## 4.9 访问者模式\n\n## 4.10 备忘录模式\n\n## 4.11 解释器模式\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n','<h1><a id=\"1__3\"></a>1. 类图概述</h1>\n<p>统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。</p>\n<p>UML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图。</p>\n<p>类图(Class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。</p>\n<h2><a id=\"12__10\"></a>1.2 类图的作用</h2>\n<ul>\n<li>在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解；</li>\n<li>类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。</li>\n</ul>\n<h2><a id=\"13__15\"></a>1.3 类图表示法</h2>\n<h3><a id=\"131__17\"></a>1.3.1 类的表示方式</h3>\n<p>在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name,age和address这3个属性，以及work()方法。</p>\n<p>属性/方法名称前加的加号和减号表示了这个属性/方法的可见性，UML类图中表示可见性的符号有三种：</p>\n<ul>\n<li>\n<p>+：表示public</p>\n</li>\n<li>\n<p>-：表示private</p>\n</li>\n<li>\n<p>#：表示protected</p>\n</li>\n</ul>\n<p>属性的完整表示方式是： <strong>可见性  名称 ：类型 [ = 缺省值]</strong></p>\n<p>方法的完整表示方式是： <strong>可见性  名称(参数列表) [ ： 返回类型]</strong></p>\n<blockquote>\n<p>注意：</p>\n<p>1，中括号中的内容表示是可选的</p>\n<p>2，也有将类型放在变量名前面，返回值类型放在方法名前面</p>\n</blockquote>\n<p><strong>举个栗子：</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/04fd7b0a2dd048adb179e927ba586dad.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>上图Demo类定义了三个方法：</p>\n<ul>\n<li>method()方法：修饰符为public，没有参数，没有返回值。</li>\n<li>method1()方法：修饰符为private，没有参数，返回值类型为String。</li>\n<li>method2()方法：修饰符为protected，接收两个参数，第一个参数类型为int，第二个参数类型为String，返回值类型是int。</li>\n</ul>\n<h3><a id=\"132__51\"></a>1.3.2 类与类之间关系的表示方式</h3>\n<h4><a id=\"1321__53\"></a>1.3.2.1 关联关系</h4>\n<p>关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。</p>\n<p>关联又可以分为单向关联，双向关联，自关联。</p>\n<p><strong>1，单向关联</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/d636bca3668743b08aea2ded7d8af0ff.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>在UML类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。</p>\n<p><strong>2，双向关联</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/fd2544a1ba7248fab799c931fa589a1d.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。</p>\n<p>在UML类图中，双向关联用一个不带箭头的直线表示。上图中在Customer类中维护一个List&lt;Product&gt;，表示一个顾客可以购买多个商品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。</p>\n<p><strong>3，自关联</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/6406fb400c2149a482547f3a6cbb21cb.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。</p>\n<h4><a id=\"1322__84\"></a>1.3.2.2 聚合关系</h4>\n<p>聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。</p>\n<p>聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。</p>\n<p>在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。下图所示是大学和教师的关系图：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/c17e7163c4da46c39c7564d9222f371f.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"1323__95\"></a>1.3.2.3 组合关系</h4>\n<p>组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。</p>\n<p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。</p>\n<p>在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。下图所示是头和嘴的关系图：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/0a9262e57101450d87e9295c8a7d78ab.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"1324__108\"></a>1.3.2.4 依赖关系</h4>\n<p>依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。</p>\n<p>在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是司机和汽车的关系图，司机驾驶汽车：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/ef2a51cf0d714b4e807e2d7145d32ebb.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"1325__117\"></a>1.3.2.5 继承关系</h4>\n<p>继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。</p>\n<p>在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下图所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/a3076e2833644fef8799a2f806cf0857.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"1326__128\"></a>1.3.2.6 实现关系</h4>\n<p>实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p>\n<p>在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如图 9 所示。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/18c9100e673346a1ae755058457e8d06.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h1><a id=\"_141\"></a>常用设计模式</h1>\n<p><mark>创建者：单例、工厂</mark></p>\n<p><mark>结构型：代理、适配器、装饰者、外观</mark></p>\n<p><mark>行为型：策略、模板、职责链、观察者、发布与订阅</mark></p>\n<h1><a id=\"1__149\"></a>1. 软件设计原则</h1>\n<h2><a id=\"11__151\"></a>1.1 开闭原则</h2>\n<p><strong>对扩展开放，对改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。</p>\n<blockquote>\n<p>想要达到这样的效果，我们需要使用接口和抽象类。</p>\n</blockquote>\n<p>【例】<code>搜狗输入法</code> 的皮肤设计。</p>\n<p>分析：<code>搜狗输入法</code> 的皮肤是输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，也可以从网上下载新的皮肤。这些皮肤有共同的特点，可以为其定义一个抽象类（AbstractSkin），而每个具体的皮肤（DefaultSpecificSkin和HeimaSpecificSkin）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/c1d781a7e69949f58128646fb7d7fd03.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h2><a id=\"12__164\"></a>1.2 里氏代换原则</h2>\n<p>​	里氏代换原则：任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p>\n<pre><code>**子类可以扩展父类的功能，但不能改变父类原有的功能。** 也就是既不能重写父类的方法，也不能重载父类的方法。\n</code></pre>\n<p>【例】</p>\n<p>父类长方形</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.morris.pattern.lsp;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Rectangle</span> </span>{\n\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">int</span> width;\n\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">int</span> height;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Rectangle</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> width, <span class=\"hljs-keyword\">int</span> height)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.width = width;\n        <span class=\"hljs-keyword\">this</span>.height = height;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">calcArea</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> width * height;\n    }\n\n}\n</code></div></pre>\n<p>子类正方形</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.morris.pattern.lsp;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Square</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Rectangle</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Square</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> width, <span class=\"hljs-keyword\">int</span> height)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(width, height);\n    }\n    <span class=\"hljs-meta\">@Override</span> <span class=\"hljs-comment\">//重写了父类计算面积的方法</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">calcArea</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> width * width;\n    }\n\n}\n</code></div></pre>\n<p>测试类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.morris.pattern.lsp;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">App</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        Rectangle rectangle = <span class=\"hljs-keyword\">new</span> Rectangle(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>); <span class=\"hljs-comment\">//长方</span>\n        Rectangle rectangle = <span class=\"hljs-keyword\">new</span> Square(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>); <span class=\"hljs-comment\">//正方形</span>\n        System.out.println(rectangle.calcArea());\n    }\n\n}\n</code></div></pre>\n<p>如果把长方形类Rectangle替换为正方形类Square，那么求出的面积就不正确了，原因是继承的时候重写了父类的getArea方法。这是违背里氏替换原则的。</p>\n<h2><a id=\"13__231\"></a>1.3 依赖倒转原则</h2>\n<p>​		高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p>\n<blockquote>\n<p>个人认为跟开闭原则很像，都是要求面向接口 / 抽象编程。因为对接口编程时，很方便扩展，那么实现类修改了，只要接口不变，使用该接口的类也不需要变。<strong>面向接口编程就能满足两种原则了！</strong></p>\n</blockquote>\n<p>【例】</p>\n<p><strong>之前</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/f133ab2a16df47a6864f45b12f12829b.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<hr />\n<p><strong>之后</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/6dfc0e3ef527423ba7f9c4533a5b3923.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h2><a id=\"14__251\"></a>1.4 接口隔离原则</h2>\n<p>客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在<strong>最小的接口</strong>上。</p>\n<blockquote>\n<p>这里跟数据库的第一范式很相似，就是对于属性的粒度划分要刚刚好，要小到不能划分。</p>\n<p>就像人能拉屎拉尿，也不应该将这两个功能写在同一接口里面，应该分开接口来写，因为有些人是不能拉尿的。</p>\n</blockquote>\n<h2><a id=\"15__259\"></a>1.5 迪米特法则</h2>\n<p><strong>又叫最少知识原则。</strong></p>\n<p>其含义是：如果两个软件实体<strong>无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用</strong>。其目的是降低类之间的耦合度，提高模块的相对独立性。</p>\n<h2><a id=\"16__265\"></a>1.6 合成复用原则</h2>\n<p>合成复用原则是指：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p>\n<p>【例】汽车分类管理程序</p>\n<p>汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。类图如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/efce48a226014b559795ab6e48f879e6.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>从上面类图我们可以看到使用继承复用产生了很多子类，如果现在又有新的动力源或者新的颜色的话，就需要再定义新的类。我们试着将继承复用改为聚合复用看一下。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2d6f81f4cc6440339a8049951949b968.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h1><a id=\"2__281\"></a>2. 创建者模式</h1>\n<p>创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。</p>\n<p>这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。</p>\n<p>创建型模式分为：</p>\n<ul>\n<li>单例模式</li>\n<li>工厂方法模式</li>\n<li>抽象工程模式</li>\n<li>原型模式</li>\n<li>建造者模式</li>\n</ul>\n<h2><a id=\"21__295\"></a>2.1 单例设计模式</h2>\n<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>\n<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>\n<h3><a id=\"211__301\"></a>2.1.1 单例模式的结构</h3>\n<p>单例模式的主要有以下角色：</p>\n<ul>\n<li>单例类。只能创建一个实例的类</li>\n<li>访问类。使用单例类</li>\n</ul>\n<h3><a id=\"212__308\"></a>2.1.2 单例模式的实现</h3>\n<blockquote>\n<p>单例设计模式分类两种：</p>\n<p>​	饿汉式：类加载就会导致该单实例对象被创建</p>\n<p>​	懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p>\n</blockquote>\n<ol>\n<li>\n<p>饿汉式</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">/**\n * 饿汉式\n *      静态变量创建类的对象\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Singleton</span> </span>{\n    <span class=\"hljs-comment\">//私有构造方法</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">Singleton</span><span class=\"hljs-params\">()</span> </span>{}\n\n    <span class=\"hljs-comment\">//在成员位置创建该类的对象</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Singleton instance = <span class=\"hljs-keyword\">new</span> Singleton();\n\n    <span class=\"hljs-comment\">//对外提供静态方法获取该对象</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Singleton <span class=\"hljs-title\">getInstance</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> instance;\n    }\n}\n</code></div></pre>\n</li>\n<li>\n<p>懒汉式</p>\n<p>添加 <code>volatile</code> 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">/**\n * 双重检查方式\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Singleton</span> </span>{\n\n    <span class=\"hljs-comment\">//私有构造方法</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">Singleton</span><span class=\"hljs-params\">()</span> </span>{}\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">volatile</span> Singleton instance;\n\n   <span class=\"hljs-comment\">//对外提供静态方法获取该对象</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Singleton <span class=\"hljs-title\">getInstance</span><span class=\"hljs-params\">()</span> </span>{\n		<span class=\"hljs-comment\">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际</span>\n        <span class=\"hljs-keyword\">if</span>(instance == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">synchronized</span> (Singleton.class) {\n                <span class=\"hljs-comment\">//抢到锁之后再次判断是否为空</span>\n                <span class=\"hljs-keyword\">if</span>(instance == <span class=\"hljs-keyword\">null</span>) {\n                    instance = <span class=\"hljs-keyword\">new</span> Singleton();\n                }\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> instance;\n    }\n}\n</code></div></pre>\n</li>\n<li>\n<p>懒汉式-方式4（静态内部类方式）</p>\n<p>静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性/方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 <code>static</code> 修饰，保证只被实例化一次，并且严格保证实例化顺序。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">/**\n * 静态内部类方式\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Singleton</span> </span>{\n\n    <span class=\"hljs-comment\">//私有构造方法</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">Singleton</span><span class=\"hljs-params\">()</span> </span>{}\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SingletonHolder</span> </span>{\n        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Singleton INSTANCE = <span class=\"hljs-keyword\">new</span> Singleton();\n    }\n\n    <span class=\"hljs-comment\">//对外提供静态方法获取该对象</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Singleton <span class=\"hljs-title\">getInstance</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> SingletonHolder.INSTANCE;\n    }\n}\n</code></div></pre>\n</li>\n<li>\n<p>枚举方式</p>\n<p>枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">/**\n * 枚举方式\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">enum</span> Singleton {\n    INSTANCE;\n}\n</code></div></pre>\n</li>\n</ol>\n<h3><a id=\"213__405\"></a>2.1.3 存在的问题及解决</h3>\n<blockquote>\n<p><em>反序列化破坏单例的解决方式</em></p>\n</blockquote>\n<p>​	在Singleton类中添加<code>readResolve()</code>方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Singleton</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Serializable</span> </span>{\n\n    <span class=\"hljs-comment\">//私有构造方法</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">Singleton</span><span class=\"hljs-params\">()</span> </span>{}\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SingletonHolder</span> </span>{\n        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Singleton INSTANCE = <span class=\"hljs-keyword\">new</span> Singleton();\n    }\n\n    <span class=\"hljs-comment\">//对外提供静态方法获取该对象</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Singleton <span class=\"hljs-title\">getInstance</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> SingletonHolder.INSTANCE;\n    }\n    \n    <span class=\"hljs-comment\">/**\n     * 下面是为了解决序列化反序列化破解单例模式\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> Object <span class=\"hljs-title\">readResolve</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> SingletonHolder.INSTANCE;\n    }\n}\n</code></div></pre>\n<blockquote>\n<p>反射方式破解单例的解决方法</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Singleton</span> </span>{\n\n    <span class=\"hljs-comment\">//私有构造方法</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">Singleton</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">/*\n           反射破解单例模式需要添加的代码\n        */</span>\n        <span class=\"hljs-keyword\">if</span>(instance != <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RuntimeException();\n        }\n    }\n    \n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">volatile</span> Singleton instance;\n\n    <span class=\"hljs-comment\">//对外提供静态方法获取该对象</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Singleton <span class=\"hljs-title\">getInstance</span><span class=\"hljs-params\">()</span> </span>{\n\n        <span class=\"hljs-keyword\">if</span>(instance != <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">return</span> instance;\n        }\n\n        <span class=\"hljs-keyword\">synchronized</span> (Singleton.class) {\n            <span class=\"hljs-keyword\">if</span>(instance != <span class=\"hljs-keyword\">null</span>) {\n                <span class=\"hljs-keyword\">return</span> instance;\n            }\n            instance = <span class=\"hljs-keyword\">new</span> Singleton();\n            <span class=\"hljs-keyword\">return</span> instance;\n        }\n    }\n}\n</code></div></pre>\n<h2><a id=\"22__472\"></a>2.2 工厂模式</h2>\n<p>在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。</p>\n<p>如果<strong>我们使用工厂来生产对象</strong>，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：<strong>解耦</strong>。</p>\n<h3><a id=\"221__478\"></a>2.2.1 简单工厂模式</h3>\n<p>简单工厂不是一种设计模式，反而比较像是一种编程习惯。</p>\n<blockquote>\n<p>结构</p>\n</blockquote>\n<p>简单工厂包含如下角色：</p>\n<ul>\n<li>抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。</li>\n<li>具体产品 ：实现或者继承抽象产品的子类</li>\n<li>具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/71636e5b69354341b5cc24642eec09ec.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<blockquote>\n<p>优缺点</p>\n</blockquote>\n<p><strong>优点：</strong></p>\n<p>封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。</p>\n<p><strong>缺点：</strong></p>\n<p>增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。</p>\n<blockquote>\n<p>扩展</p>\n</blockquote>\n<p><strong>静态工厂</strong></p>\n<p>在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是23种设计模式中的。代码如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SimpleCoffeeFactory</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Coffee <span class=\"hljs-title\">createCoffee</span><span class=\"hljs-params\">(String type)</span> </span>{\n        Coffee coffee = <span class=\"hljs-keyword\">null</span>;\n        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-string\">\"americano\"</span>.equals(type)) {\n            coffee = <span class=\"hljs-keyword\">new</span> AmericanoCoffee();\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-string\">\"latte\"</span>.equals(type)) {\n            coffee = <span class=\"hljs-keyword\">new</span> LatteCoffee();\n        }\n        <span class=\"hljs-keyword\">return</span> coffe;\n    }\n}\n</code></div></pre>\n<h3><a id=\"222__524\"></a>2.2.2 工厂方法模式</h3>\n<blockquote>\n<p>概念</p>\n</blockquote>\n<p>定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。</p>\n<blockquote>\n<p>结构</p>\n</blockquote>\n<p>工厂方法模式的主要角色：</p>\n<ul>\n<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</li>\n<li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>\n<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li>\n<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/d7bc2712a78a4a32857f74e2d7e6d791.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>代码如下：</p>\n<p>抽象工厂：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">CoffeeFactory</span> </span>{\n\n    <span class=\"hljs-function\">Coffee <span class=\"hljs-title\">createCoffee</span><span class=\"hljs-params\">()</span></span>;\n}\n</code></div></pre>\n<p>具体工厂：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LatteCoffeeFactory</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">CoffeeFactory</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Coffee <span class=\"hljs-title\">createCoffee</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> LatteCoffee();\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AmericanCoffeeFactory</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">CoffeeFactory</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Coffee <span class=\"hljs-title\">createCoffee</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> AmericanCoffee();\n    }\n}\n</code></div></pre>\n<p>咖啡店类：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CoffeeStore</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> CoffeeFactory factory;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">CoffeeStore</span><span class=\"hljs-params\">(CoffeeFactory factory)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.factory = factory;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Coffee <span class=\"hljs-title\">orderCoffee</span><span class=\"hljs-params\">(String type)</span> </span>{\n        Coffee coffee = factory.createCoffee();\n        coffee.addMilk();\n        coffee.addsugar();\n        <span class=\"hljs-keyword\">return</span> coffee;\n    }\n}\n</code></div></pre>\n<p>从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点。</p>\n<p>工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。</p>\n<h3><a id=\"223__595\"></a>2.2.3 抽象工厂模式</h3>\n<p>前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、传智播客只培养计算机软件专业的学生等。</p>\n<p>这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。</p>\n<p>本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，下图所示横轴是产品等级，也就是同一类产品；纵轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/669b5f6bcec94e5f8e2b8cc61bd79eba.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>比如：咖啡分美式英式等为同一等级。咖啡、奶茶、果汁为同一族，而应把他们抽象成同一产品族：饮料工厂。</p>\n<blockquote>\n<p>概念</p>\n</blockquote>\n<p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p>\n<blockquote>\n<p>结构</p>\n</blockquote>\n<p>抽象工厂模式的主要角色如下：</p>\n<ul>\n<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</li>\n<li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li>\n<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li>\n<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。</li>\n</ul>\n<blockquote>\n<p>实现</p>\n</blockquote>\n<p>现咖啡店业务发生改变，不仅要生产咖啡还要生产甜点，如提拉米苏、抹茶慕斯等，要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。其中拿铁咖啡、美式咖啡是一个产品等级，都是咖啡；提拉米苏、抹茶慕斯也是一个产品等级；拿铁咖啡和提拉米苏是同一产品族（也就是都属于意大利风味），美式咖啡和抹茶慕斯是同一产品族（也就是都属于美式风味）。所以这个案例可以使用抽象工厂模式实现。类图如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d3354cf0800b4dbd8a21065e6a214c13.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<blockquote>\n<p>优缺点</p>\n</blockquote>\n<p><strong>优点：</strong></p>\n<p>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p>\n<p><strong>缺点：</strong></p>\n<p>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p>\n<h3><a id=\"224__638\"></a>2.2.4 模式扩展</h3>\n<p><strong>简单工厂+配置文件解除耦合</strong></p>\n<p>可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。</p>\n<p>第一步：定义配置文件</p>\n<p>为了演示方便，我们使用properties文件作为配置文件，名称为bean.properties</p>\n<pre><code class=\"lang-properties\">american=com.itheima.pattern.factory.config_factory.AmericanCoffee\nlatte=com.itheima.pattern.factory.config_factory.LatteCoffee\n</code></pre>\n<p>第二步：改进工厂类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CoffeeFactory</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Map&lt;String,Coffee&gt; map = <span class=\"hljs-keyword\">new</span> HashMap();\n\n    <span class=\"hljs-keyword\">static</span> {\n        Properties p = <span class=\"hljs-keyword\">new</span> Properties();\n        InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream(<span class=\"hljs-string\">\"bean.properties\"</span>);\n        <span class=\"hljs-keyword\">try</span> {\n            p.load(is);\n            <span class=\"hljs-comment\">//遍历Properties集合对象</span>\n            Set&lt;Object&gt; keys = p.keySet();\n            <span class=\"hljs-keyword\">for</span> (Object key : keys) {\n                <span class=\"hljs-comment\">//根据键获取值（全类名）</span>\n                String className = p.getProperty((String) key);\n                <span class=\"hljs-comment\">//获取字节码对象</span>\n                Class clazz = Class.forName(className);\n                Coffee obj = (Coffee) clazz.newInstance();\n                map.put((String)key,obj);\n            }\n        } <span class=\"hljs-keyword\">catch</span> (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Coffee <span class=\"hljs-title\">createCoffee</span><span class=\"hljs-params\">(String name)</span> </span>{\n\n        <span class=\"hljs-keyword\">return</span> map.get(name);\n    }\n}\n</code></div></pre>\n<p>静态成员变量用来存储创建的对象（键存储的是名称，值存储的是对应的对象），而读取配置文件以及创建对象写在静态代码块中，目的就是只需要执行一次。</p>\n<h2><a id=\"23__689\"></a>2.3 原型模式</h2>\n<blockquote>\n<p>概述</p>\n</blockquote>\n<p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。</p>\n<blockquote>\n<p>结构</p>\n</blockquote>\n<p>原型模式包含如下角色：</p>\n<ul>\n<li>抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。</li>\n<li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li>\n<li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li>\n</ul>\n<blockquote>\n<p>实现</p>\n</blockquote>\n<p>原型模式的克隆分为浅克隆和深克隆。</p>\n<ul>\n<li>\n<p>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</p>\n<p><mark>克隆后的对象本身地址改变，但是克隆后的对象的成员变量中引用类型的数据的地址仍然与原型对象一致</mark></p>\n</li>\n<li>\n<p>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</p>\n<p><mark>里里外外就是一个新对象</mark></p>\n</li>\n</ul>\n<p>Java中的Object类中提供了 <code>clone()</code> 方法来实现浅克隆。 Cloneable 接口是上面的类图中的抽象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。</p>\n<blockquote>\n<p>浅克隆</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Realizetype</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Cloneable</span> </span>{ <span class=\"hljs-comment\">//实现浅克隆接口</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Realizetype</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"具体的原型对象创建完成！\"</span>);<span class=\"hljs-comment\">//手动new对象用的是构造器，但是clone方法不是用的构造器</span>\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> Realizetype <span class=\"hljs-title\">clone</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> CloneNotSupportedException </span>{\n        System.out.println(<span class=\"hljs-string\">\"具体原型复制成功！\"</span>);\n        <span class=\"hljs-keyword\">return</span> (Realizetype) <span class=\"hljs-keyword\">super</span>.clone();\n    }\n}\n</code></div></pre>\n<blockquote>\n<p>深克隆</p>\n</blockquote>\n<p>通过序列化与反序列化方式完成深克隆，注意：<mark>自定义对象需要实现序列化接口</mark></p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CitationTest1</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        Citation c1 = <span class=\"hljs-keyword\">new</span> Citation();\n        Student stu = <span class=\"hljs-keyword\">new</span> Student(<span class=\"hljs-string\">\"张三\"</span>, <span class=\"hljs-string\">\"西安\"</span>);\n        c1.setStu(stu);\n\n        <span class=\"hljs-comment\">//创建对象输出流对象</span>\n        ObjectOutputStream oos = <span class=\"hljs-keyword\">new</span> ObjectOutputStream(<span class=\"hljs-keyword\">new</span> FileOutputStream(<span class=\"hljs-string\">\"C:\\\\Users\\\\Think\\\\Desktop\\\\b.txt\"</span>));\n        <span class=\"hljs-comment\">//将c1对象写出到文件中</span>\n        oos.writeObject(c1);\n        oos.close();\n\n        <span class=\"hljs-comment\">//创建对象出入流对象</span>\n        ObjectInputStream ois = <span class=\"hljs-keyword\">new</span> ObjectInputStream(<span class=\"hljs-keyword\">new</span> FileInputStream(<span class=\"hljs-string\">\"C:\\\\Users\\\\Think\\\\Desktop\\\\b.txt\"</span>));\n        <span class=\"hljs-comment\">//读取对象</span>\n        Citation c2 = (Citation) ois.readObject();\n        <span class=\"hljs-comment\">//获取c2奖状所属学生对象</span>\n        Student stu1 = c2.getStu();\n        stu1.setName(<span class=\"hljs-string\">\"李四\"</span>);\n\n        <span class=\"hljs-comment\">//判断stu对象和stu1对象是否是同一个对象</span>\n        System.out.println(<span class=\"hljs-string\">\"stu和stu1是同一个对象？\"</span> + (stu == stu1));\n\n        c1.show();\n        c2.show();\n    }\n}\n</code></div></pre>\n<h1><a id=\"3__770\"></a>3. 结构型模式</h1>\n<p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</p>\n<p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p>\n<p>结构型模式分为以下 7 种：</p>\n<ul>\n<li>代理模式</li>\n<li>适配器模式</li>\n<li>装饰者模式</li>\n<li>桥接模式</li>\n<li>外观模式</li>\n<li>组合模式</li>\n<li>享元模式</li>\n</ul>\n<h2><a id=\"31__788\"></a>3.1 代理模式</h2>\n<h3><a id=\"311__790\"></a>3.1.1 概述</h3>\n<p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>\n<p>Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。</p>\n<h3><a id=\"312__796\"></a>3.1.2 结构</h3>\n<p>代理（Proxy）模式分为三种角色：</p>\n<ul>\n<li>抽象主题（Subject）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>\n<li>真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>\n<li>代理（Proxy）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>\n</ul>\n<h3><a id=\"313__804\"></a>3.1.3 静态代理</h3>\n<p>【例】火车站卖票</p>\n<p>如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。类图如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/5320fe83001649cd9a0067e36c60a1a5.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>代码如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//卖票接口</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">SellTickets</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sell</span><span class=\"hljs-params\">()</span></span>;\n}\n\n<span class=\"hljs-comment\">//火车站  火车站具有卖票功能，所以需要实现SellTickets接口</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TrainStation</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">SellTickets</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sell</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"火车站卖票\"</span>);\n    }\n}\n\n<span class=\"hljs-comment\">//代售点</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ProxyPoint</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">SellTickets</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> TrainStation station = <span class=\"hljs-keyword\">new</span> TrainStation();\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sell</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"代理点收取一些服务费用\"</span>);\n        station.sell();\n    }\n}\n\n<span class=\"hljs-comment\">//测试类</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Client</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        ProxyPoint pp = <span class=\"hljs-keyword\">new</span> ProxyPoint();\n        pp.sell();\n    }\n}\n</code></div></pre>\n<p>从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介。同时也对sell方法进行了增强（代理点收取一些服务费用）。</p>\n<h3><a id=\"314_JDK_851\"></a>3.1.4 JDK动态代理</h3>\n<p>代码如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//卖票接口</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">SellTickets</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sell</span><span class=\"hljs-params\">()</span></span>;\n}\n\n<span class=\"hljs-comment\">//火车站  火车站具有卖票功能，所以需要实现SellTickets接口</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TrainStation</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">SellTickets</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sell</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"火车站卖票\"</span>);\n    }\n}\n\n<span class=\"hljs-comment\">//代理工厂，用来创建代理对象</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ProxyFactory</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> TrainStation station = <span class=\"hljs-keyword\">new</span> TrainStation();\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> SellTickets <span class=\"hljs-title\">getProxyObject</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">//使用Proxy获取代理对象</span>\n        <span class=\"hljs-comment\">/*\n            newProxyInstance()方法参数说明：\n                ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可\n                Class&lt;?&gt;[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口\n                InvocationHandler h ： 代理对象的调用处理程序\n         */</span>\n        SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),\n                station.getClass().getInterfaces(),\n                <span class=\"hljs-keyword\">new</span> InvocationHandler() {\n                    <span class=\"hljs-comment\">/*\n                        InvocationHandler中invoke方法参数说明：\n                            proxy ： 代理对象\n                            method ： 对应于在代理对象上调用的接口方法的 Method 实例\n                            args ： 代理对象调用接口方法时传递的实际参数\n                     */</span>\n                    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">invoke</span><span class=\"hljs-params\">(Object proxy, Method method, Object[] args)</span> <span class=\"hljs-keyword\">throws</span> Throwable </span>{\n\n                        System.out.println(<span class=\"hljs-string\">\"代理点收取一些服务费用(JDK动态代理方式)\"</span>);\n                        <span class=\"hljs-comment\">//执行真实对象</span>\n                        Object result = method.invoke(station, args);\n                        <span class=\"hljs-keyword\">return</span> result;\n                    }\n                });\n        <span class=\"hljs-keyword\">return</span> sellTickets;\n    }\n}\n\n<span class=\"hljs-comment\">//测试类</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Client</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        <span class=\"hljs-comment\">//获取代理对象</span>\n        ProxyFactory factory = <span class=\"hljs-keyword\">new</span> ProxyFactory();\n        \n        SellTickets proxyObject = factory.getProxyObject();\n        proxyObject.sell();\n    }\n}\n</code></div></pre>\n<p>执行流程如下：</p>\n<ol>\n<li>在测试类中通过代理对象调用sell()方法</li>\n<li>根据多态的特性，执行的是代理类（$Proxy0）中的sell()方法</li>\n<li>代理类（$Proxy0）中的sell()方法中又调用了InvocationHandler接口的子实现类对象的invoke方法</li>\n<li>invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法</li>\n</ol>\n<h3><a id=\"315_CGLIB_922\"></a>3.1.5 CGLIB动态代理</h3>\n<p>同样是上面的案例，我们再次使用CGLIB代理实现。</p>\n<p>如果没有定义SellTickets接口，只定义了TrainStation(火车站类)。很显然JDK代理是无法使用了，因为JDK动态代理要求必须定义接口，对接口进行代理。</p>\n<p>CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。</p>\n<p>CGLIB是第三方提供的包，所以需要引入jar包的坐标：</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>cglib<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>cglib<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.2.2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<p>代码如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//火车站</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TrainStation</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sell</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"火车站卖票\"</span>);\n    }\n}\n\n<span class=\"hljs-comment\">//代理工厂</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ProxyFactory</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">MethodInterceptor</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> TrainStation target = <span class=\"hljs-keyword\">new</span> TrainStation();\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> TrainStation <span class=\"hljs-title\">getProxyObject</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">//创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数</span>\n        Enhancer enhancer =<span class=\"hljs-keyword\">new</span> Enhancer();\n        <span class=\"hljs-comment\">//设置父类的字节码对象</span>\n        enhancer.setSuperclass(target.getClass());\n        <span class=\"hljs-comment\">//设置回调函数</span>\n        enhancer.setCallback(<span class=\"hljs-keyword\">this</span>);\n        <span class=\"hljs-comment\">//创建代理对象</span>\n        TrainStation obj = (TrainStation) enhancer.create();\n        <span class=\"hljs-keyword\">return</span> obj;\n    }\n\n    <span class=\"hljs-comment\">/*\n        intercept方法参数说明：\n            o ： 代理对象\n            method ： 真实对象中的方法的Method实例\n            args ： 实际参数\n            methodProxy ：代理对象中的方法的method实例\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> TrainStation <span class=\"hljs-title\">intercept</span><span class=\"hljs-params\">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class=\"hljs-keyword\">throws</span> Throwable </span>{\n        System.out.println(<span class=\"hljs-string\">\"代理点收取一些服务费用(CGLIB动态代理方式)\"</span>);\n        TrainStation result = (TrainStation) methodProxy.invokeSuper(o, args);\n        <span class=\"hljs-keyword\">return</span> result;\n    }\n}\n\n<span class=\"hljs-comment\">//测试类</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Client</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        <span class=\"hljs-comment\">//创建代理工厂对象</span>\n        ProxyFactory factory = <span class=\"hljs-keyword\">new</span> ProxyFactory();\n        <span class=\"hljs-comment\">//获取代理对象</span>\n        TrainStation proxyObject = factory.getProxyObject();\n\n        proxyObject.sell();\n    }\n}\n</code></div></pre>\n<h3><a id=\"316__995\"></a>3.1.6 三种代理的对比</h3>\n<ul>\n<li>\n<p>jdk代理和CGLIB代理</p>\n<p>使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。</p>\n<p>在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理。</p>\n</li>\n<li>\n<p>动态代理和静态代理</p>\n<p>动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。</p>\n<p>如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题</p>\n</li>\n</ul>\n<h3><a id=\"317__1011\"></a>3.1.7 优缺点</h3>\n<p><strong>优点：</strong></p>\n<ul>\n<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li>\n<li>代理对象可以扩展目标对象的功能；</li>\n<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>增加了系统的复杂度；</li>\n</ul>\n<h2><a id=\"32__1023\"></a>3.2 适配器模式</h2>\n<h3><a id=\"321__1025\"></a>3.2.1 概述</h3>\n<p>如果去欧洲国家去旅游的话，他们的插座如下图最左边，是欧洲标准。而我们使用的插头如下图最右边的。因此我们的笔记本电脑，手机在当地不能直接充电。所以就需要一个插座转换器，转换器第1面插入当地的插座，第2面供我们充电，这样使得我们的插头在当地能使用。生活中这样的例子很多，手机充电器（将220v转换为5v的电压），读卡器等，其实就是使用到了适配器模式。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/b59606ae4a414f0382d89c3e819d28b2.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>定义：</strong></p>\n<p>​	将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p>\n<p>​	适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p>\n<h3><a id=\"322__1038\"></a>3.2.2 结构</h3>\n<p>适配器模式（Adapter）包含以下主要角色：</p>\n<ul>\n<li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li>\n<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>\n<li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li>\n</ul>\n<blockquote>\n<p>适配器模式分为类适配器与对象适配器，对象适配器跟广泛一些。</p>\n</blockquote>\n<h3><a id=\"323__1049\"></a>3.2.3 对象适配器模式</h3>\n<p>我们有一个 <em>NewMediaPlayer</em> 接口和一个实现了 <em>NewMediaPlayer</em> 接口的实体类 <em>NewMediaPlayerImpl</em>。默认情况下，NewMediaPlayerImpl可以播放 mp3 格式的音频文件。</p>\n<p>我们还有另一个接口 <em>AdvancedMediaPlayer</em> 和实现了 <em>AdvancedMediaPlayer</em> 接口的实体类。该类可以播放 avi和 mp4 格式的文件。</p>\n<p>我们想要让 NewMediaPlayerImpl播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 <em>NewMediaPlayer</em>接口的适配器类 <em>MediaAdapter</em>，并使用 <em>AdvancedMediaPlayer</em> 对象来播放所需的格式。</p>\n<blockquote>\n<p>类图</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/a4dacadcc9dc4590a54d26ce24c1131f.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<blockquote>\n<p>代码</p>\n</blockquote>\n<ol>\n<li>AdvanceMediaPlayer接口代码</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">AdvanceMediaPlayer</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">playMp4</span><span class=\"hljs-params\">(String filename)</span></span>;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">playAvi</span><span class=\"hljs-params\">(String filename)</span></span>;\n}\n</code></div></pre>\n<ol start=\"2\">\n<li>实现AdvanceMediaPlayer接口的类AdvanceMediaPlayerImpl</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AdvanceMediaPlayerImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">AdvanceMediaPlayer</span> </span>{\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">playMp4</span><span class=\"hljs-params\">(String filename)</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"原生播放器播放mp4:\"</span>+filename);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">playAvi</span><span class=\"hljs-params\">(String filename)</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"原生播放器播放Avi:\"</span>+filename);\n    }\n}\n</code></div></pre>\n<ol start=\"3\">\n<li>NewMediaPlayer接口</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">NewMediaPlayer</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">playMp3</span><span class=\"hljs-params\">(String filename)</span></span>;\n}\n</code></div></pre>\n<ol start=\"4\">\n<li>适配器类MediaAdapter</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MediaAdapter</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">NewMediaPlayer</span> </span>{\n<span class=\"hljs-comment\">//    适配器，是为了新播放器能够使用已经有的播放器（MP4，avi），所以使用者只是希望调用旧的播放器来播放</span>\n<span class=\"hljs-comment\">//    因此，使用者只管在适配器中调用新播放器的接口的方法，但适配器实际用的是就播放器，但使用者不关心。</span>\n<span class=\"hljs-comment\">//    为了不混乱，规定某个对象被扩展功能，其则是新播放器，需要为其适配器</span>\n    AdvanceMediaPlayer advanceMediaPlayer;\n\n    <span class=\"hljs-comment\">/**\n     * 注意，这里的方法名有mp3，只是给使用者看的，\n     * 内部透明，但是作为适配器，\n     * 内部实际上调用的是advance播放器接口\n     *\n     * <span class=\"hljs-doctag\">@param</span> filename\n     */</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">playMp3</span><span class=\"hljs-params\">(String filename)</span> </span>{\n        advanceMediaPlayer = <span class=\"hljs-keyword\">new</span> AdvanceMediaPlayerImpl();\n        <span class=\"hljs-keyword\">if</span> (filename.indexOf(<span class=\"hljs-string\">\"mp4\"</span>) &gt; <span class=\"hljs-number\">0</span>) {\n            System.out.print(<span class=\"hljs-string\">\"适配器接手==&gt;\"</span>);\n            advanceMediaPlayer.playMp4(filename);\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (filename.indexOf(<span class=\"hljs-string\">\"avi\"</span>) &gt; <span class=\"hljs-number\">0</span>) {\n            System.out.print(<span class=\"hljs-string\">\"适配器接手==&gt;\"</span>);\n            advanceMediaPlayer.playAvi(filename);\n        }\n    }\n</code></div></pre>\n<ol start=\"5\">\n<li>NewMediaPlayer接口实现类NewMediaPlayerImpl</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NewMediaPlayerImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">NewMediaPlayer</span> </span>{\n    <span class=\"hljs-keyword\">private</span> MediaAdapter mediaAdapter;\n\n    <span class=\"hljs-comment\">/**\n     * 如果是mp3格式，对象本身可以播放，\n     * 但如果是mp4/avi则不支持，\n     * 需要调用适配器中的方法来播放其他格式\n     *\n     * <span class=\"hljs-doctag\">@param</span> filename\n     */</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">playMp3</span><span class=\"hljs-params\">(String filename)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (filename.indexOf(<span class=\"hljs-string\">\"mp3\"</span>) &gt; <span class=\"hljs-number\">0</span>) {\n<span class=\"hljs-comment\">//            对象本身支持mp3</span>\n            System.out.println(<span class=\"hljs-string\">\"新的播放器播放mp3:\"</span> + filename);\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (filename.indexOf(<span class=\"hljs-string\">\"mp4\"</span>) &gt; <span class=\"hljs-number\">0</span> || filename.indexOf(<span class=\"hljs-string\">\"avi\"</span>) &gt; <span class=\"hljs-number\">0</span>) {\n<span class=\"hljs-comment\">//            对象不支持，调用适配器api</span>\n            mediaAdapter = <span class=\"hljs-keyword\">new</span> MediaAdapter();\n            mediaAdapter.playMp3(filename);\n        }\n    }\n\n}\n</code></div></pre>\n<ol start=\"6\">\n<li>测试类</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        NewMediaPlayer newMediaPlayer = <span class=\"hljs-keyword\">new</span> NewMediaPlayerImpl();\n        newMediaPlayer.playMp3(<span class=\"hljs-string\">\"苍井空.mp3\"</span>);\n        newMediaPlayer.playMp3(<span class=\"hljs-string\">\"苍井空.mp4\"</span>);\n        newMediaPlayer.playMp3(<span class=\"hljs-string\">\"苍井空.avi\"</span>);\n\n    }\n}\n</code></div></pre>\n<ol start=\"7\">\n<li>结果</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/e56fe80d00ac4b9dbadd13617828c47b.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h2><a id=\"33__1175\"></a>3.3 装饰者模式***</h2>\n<h3><a id=\"331__1177\"></a>3.3.1 结构</h3>\n<p>装饰（Decorator）模式中的角色：</p>\n<ul>\n<li>抽象构件（Component）角色 ：定义一个抽象接口以规范准备接收附加责任的对象。</li>\n<li>具体构件（Concrete  Component）角色 ：实现抽象构件，通过装饰角色为其添加一些职责。</li>\n<li>抽象装饰（Decorator）角色 ： <mark>继承或实现抽象构件，并包含具体构件的实例</mark>，可以通过其子类扩展具体构件的功能。<mark>妙处所在</mark></li>\n<li>具体装饰（ConcreteDecorator）角色 ：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li>\n</ul>\n<h3><a id=\"332__1186\"></a>3.3.2 案例</h3>\n<p>快餐+配菜。快餐有米饭、面条，配菜有鸡蛋、培根</p>\n<p><img src=\"https://img-blog.csdnimg.cn/c7f9a7b4f78847e6b62a2eaee725d8c6.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<blockquote>\n<p>代码</p>\n</blockquote>\n<p>快餐抽象类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FastFood</span> </span>{\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">float</span> price;\n    <span class=\"hljs-keyword\">private</span> String Description;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">FastFood</span><span class=\"hljs-params\">()</span> </span>{\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">FastFood</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> price, String description)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.price = price;\n        Description = description;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">float</span> <span class=\"hljs-title\">getPrice</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> price;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setPrice</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> price)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.price = price;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">getDescription</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> Description;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setDescription</span><span class=\"hljs-params\">(String description)</span> </span>{\n        Description = description;\n    }\n}\n</code></div></pre>\n<p>快餐实现类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//炒饭</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FriedRice</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">FastFood</span></span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">FriedRice</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">\"炒饭\"</span>);\n    }\n}\n<span class=\"hljs-comment\">//炒面</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FriedNoodles</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">FastFood</span></span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">FriedNoodles</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> price, String description)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(<span class=\"hljs-number\">20</span>, <span class=\"hljs-string\">\"炒面\"</span>);\n    }\n}\n</code></div></pre>\n<p>装饰者抽象类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">/**\n * 装饰者本身既要继承/实现快餐类，并且要聚合被快餐类！\n * 因为鸡蛋培根都是装饰者的子类，该鸡蛋培根的子类是给快餐装饰的，所以鸡蛋培根快餐属于同一族，因此装饰者要继承快餐类，这样子鸡蛋培根就跟快餐同一族，\n * 拥有相同的属性，这样才能凑合。\n * 对于装饰者本身就是属于鸡蛋、培根，但是装饰者的字段是快餐\n *\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Garnish</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">FastFood</span></span>{\n    <span class=\"hljs-keyword\">private</span> FastFood fastFood;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> FastFood <span class=\"hljs-title\">getFastFood</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> fastFood;\n    }\n\n<span class=\"hljs-comment\">//    给子类实现，实例化为鸡蛋、培根，这样装饰者本身是鸡蛋、培根。而FastFood是本来就有的快餐，赋值给装饰者字段</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Garnish</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> price, String description, FastFood fastFood)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(price, description);\n        <span class=\"hljs-keyword\">this</span>.fastFood = fastFood;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">float</span> <span class=\"hljs-title\">cost</span><span class=\"hljs-params\">()</span></span>;\n\n}\n</code></div></pre>\n<p>装饰者的子类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//Garnish实现了FastFood所以才有价格，描述的属性，getPrice只是获取鸡蛋的价格，注意继承类，只是继承类的字段，字段的具体值由子类决定，所以说为什么这里的价格只是鸡蛋的价格。</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Egg</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Garnish</span></span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Egg</span><span class=\"hljs-params\">(FastFood fastFood)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">\"鸡蛋\"</span>, fastFood);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">float</span> <span class=\"hljs-title\">cost</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> getPrice()+ getFastFood().getPrice();\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">getDescription</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">super</span>.getDescription()+getFastFood().getDescription();\n    }\n}\n</code></div></pre>\n<p>测试类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        FastFood rice = <span class=\"hljs-keyword\">new</span> FriedRice();\n        System.out.println(rice.getDescription()+<span class=\"hljs-string\">\"  \"</span>+rice.getPrice());\n<span class=\"hljs-comment\">//        炒饭  10.0</span>\n        Egg egg = <span class=\"hljs-keyword\">new</span> Egg(rice);\n        System.out.println(egg.getDescription()+<span class=\"hljs-string\">\"   \"</span>+egg.cost());\n<span class=\"hljs-comment\">//        鸡蛋炒饭   11.0</span>\n    }\n}\n</code></div></pre>\n<p><strong>好处：</strong></p>\n<ul>\n<li>\n<p>饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任。</p>\n</li>\n<li>\n<p>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>\n</li>\n</ul>\n<h2><a id=\"34__1321\"></a>3.4 桥接模式</h2>\n<h3><a id=\"541__1323\"></a>5.4.1 概述</h3>\n<p>现在有一个需求，需要创建不同的图形，并且每个图形都有可能会有不同的颜色。我们可以利用继承的方式来设计类的关系：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/b8135ce6beda429d880509790cb65f98.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>我们可以发现有很多的类，假如我们再增加一个形状或再增加一种颜色，就需要创建更多的类。</p>\n<p>试想，在一个有多种可能会变化的维度的系统中，用继承方式会造成类爆炸，扩展起来不灵活。每次在一个维度上新增一个具体实现都要增加多个子类。为了更加灵活的设计系统，我们此时可以考虑使用桥接模式。</p>\n<p><strong>定义：</strong></p>\n<p>​	将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p>\n<h3><a id=\"342__1340\"></a>3.4.2 结构</h3>\n<p>桥接（Bridge）模式包含以下主要角色：</p>\n<ul>\n<li>抽象化（Abstraction）角色 ：定义抽象类，并包含一个对实现化对象的引用。</li>\n<li>扩展抽象化（Refined  Abstraction）角色 ：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li>\n<li>实现化（Implementor）角色 ：定义实现化角色的接口，供扩展抽象化角色调用。</li>\n<li>具体实现化（Concrete Implementor）角色 ：给出实现化角色接口的具体实现。</li>\n</ul>\n<h3><a id=\"343__1349\"></a>3.4.3 案例</h3>\n<p>【例】视频播放器</p>\n<p>需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等。该播放器包含了两个维度，适合使用桥接模式。</p>\n<p>类图如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/34cba7a4e76f4da78727d2298754e361.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>代码如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//视频文件</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">VideoFile</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">decode</span><span class=\"hljs-params\">(String fileName)</span></span>;\n}\n\n<span class=\"hljs-comment\">//avi文件</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AVIFile</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">VideoFile</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">decode</span><span class=\"hljs-params\">(String fileName)</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"avi视频文件：\"</span>+ fileName);\n    }\n}\n\n<span class=\"hljs-comment\">//rmvb文件</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">REVBBFile</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">VideoFile</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">decode</span><span class=\"hljs-params\">(String fileName)</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"rmvb文件：\"</span> + fileName);\n    }\n}\n\n<span class=\"hljs-comment\">//操作系统版本</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">OperatingSystemVersion</span> </span>{\n\n    <span class=\"hljs-keyword\">protected</span> VideoFile videoFile;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">OperatingSystemVersion</span><span class=\"hljs-params\">(VideoFile videoFile)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.videoFile = videoFile;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">play</span><span class=\"hljs-params\">(String fileName)</span></span>;\n}\n\n<span class=\"hljs-comment\">//Windows版本</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Windows</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">OperatingSystem</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Windows</span><span class=\"hljs-params\">(VideoFile videoFile)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(videoFile);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">play</span><span class=\"hljs-params\">(String fileName)</span> </span>{\n        videoFile.decode(fileName);\n    }\n}\n\n<span class=\"hljs-comment\">//mac版本</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Mac</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">OperatingSystemVersion</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Mac</span><span class=\"hljs-params\">(VideoFile videoFile)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(videoFile);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">play</span><span class=\"hljs-params\">(String fileName)</span> </span>{\n		videoFile.decode(fileName);\n    }\n}\n\n<span class=\"hljs-comment\">//测试类</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Client</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        OperatingSystem os = <span class=\"hljs-keyword\">new</span> Windows(<span class=\"hljs-keyword\">new</span> AVIFile());\n        os.play(<span class=\"hljs-string\">\"战狼3\"</span>);\n    }\n}\n</code></div></pre>\n<p><strong>好处：</strong></p>\n<ul>\n<li>\n<p>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</p>\n<p>如：如果现在还有一种视频文件类型wmv，我们只需要再定义一个类实现VideoFile接口即可，其他类不需要发生变化。</p>\n</li>\n<li>\n<p>实现细节对客户透明</p>\n</li>\n</ul>\n<h3><a id=\"344__1438\"></a>3.4.4 使用场景</h3>\n<ul>\n<li>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</li>\n<li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</li>\n<li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li>\n</ul>\n<h2><a id=\"35__1444\"></a>3.5 外观模式</h2>\n<h3><a id=\"351__1446\"></a>3.5.1 概述</h3>\n<p>有些人可能炒过股票，但其实大部分人都不太懂，这种没有足够了解证券知识的情况下做股票是很容易亏钱的，刚开始炒股肯定都会想，如果有个懂行的帮帮手就好，其实基金就是个好帮手，支付宝里就有许多的基金，它将投资者分散的资金集中起来，交由专业的经理人进行管理，投资于股票、债券、外汇等领域，而基金投资的收益归持有者所有，管理机构收取一定比例的托管管理费用。</p>\n<p><strong>定义：</strong></p>\n<p>​	又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p>\n<p>​	外观（Facade）模式是“迪米特法则”的典型应用</p>\n<p><img src=\"https://img-blog.csdnimg.cn/0aedecfb7114485c9b0d59c860499b77.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"352__1461\"></a>3.5.2 结构</h3>\n<p>外观（Facade）模式包含以下主要角色：</p>\n<ul>\n<li>外观（Facade）角色：为多个子系统对外提供一个共同的接口。</li>\n<li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li>\n</ul>\n<h3><a id=\"353__1468\"></a>3.5.3 案例</h3>\n<p>【例】智能家电控制</p>\n<p>小明的爷爷已经60岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；操作起来都比较麻烦。所以小明给爷爷买了智能音箱，可以通过语音直接控制这些智能家电的开启和关闭。类图如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d76aca27d02b4f5995cbc5506bcfd117.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>代码如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//灯类</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Light</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">on</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"打开了灯....\"</span>);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">off</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"关闭了灯....\"</span>);\n    }\n}\n\n<span class=\"hljs-comment\">//电视类</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TV</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">on</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"打开了电视....\"</span>);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">off</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"关闭了电视....\"</span>);\n    }\n}\n\n<span class=\"hljs-comment\">//控制类</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AirCondition</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">on</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"打开了空调....\"</span>);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">off</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"关闭了空调....\"</span>);\n    }\n}\n\n<span class=\"hljs-comment\">//智能音箱</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SmartAppliancesFacade</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> Light light;\n    <span class=\"hljs-keyword\">private</span> TV tv;\n    <span class=\"hljs-keyword\">private</span> AirCondition airCondition;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">SmartAppliancesFacade</span><span class=\"hljs-params\">()</span> </span>{\n        light = <span class=\"hljs-keyword\">new</span> Light();\n        tv = <span class=\"hljs-keyword\">new</span> TV();\n        airCondition = <span class=\"hljs-keyword\">new</span> AirCondition();\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">say</span><span class=\"hljs-params\">(String message)</span> </span>{\n        <span class=\"hljs-keyword\">if</span>(message.contains(<span class=\"hljs-string\">\"打开\"</span>)) {\n            on();\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(message.contains(<span class=\"hljs-string\">\"关闭\"</span>)) {\n            off();\n        } <span class=\"hljs-keyword\">else</span> {\n            System.out.println(<span class=\"hljs-string\">\"我还听不懂你说的！！！\"</span>);\n        }\n    }\n\n    <span class=\"hljs-comment\">//起床后一键开电器</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">on</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"起床了\"</span>);\n        light.on();\n        tv.on();\n        airCondition.on();\n    }\n\n    <span class=\"hljs-comment\">//睡觉一键关电器</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">off</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"睡觉了\"</span>);\n        light.off();\n        tv.off();\n        airCondition.off();\n    }\n}\n\n<span class=\"hljs-comment\">//测试类</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Client</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        <span class=\"hljs-comment\">//创建外观对象</span>\n        SmartAppliancesFacade facade = <span class=\"hljs-keyword\">new</span> SmartAppliancesFacade();\n        <span class=\"hljs-comment\">//客户端直接与外观对象进行交互</span>\n        facade.say(<span class=\"hljs-string\">\"打开家电\"</span>);\n        facade.say(<span class=\"hljs-string\">\"关闭家电\"</span>);\n    }\n}\n</code></div></pre>\n<p><strong>好处：</strong></p>\n<ul>\n<li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li>\n<li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>不符合开闭原则，修改很麻烦</li>\n</ul>\n<h3><a id=\"354__1576\"></a>3.5.4 使用场景</h3>\n<ul>\n<li>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</li>\n<li>当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。</li>\n<li>当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。</li>\n</ul>\n<h3><a id=\"355__1584\"></a>3.5.5 源码解析</h3>\n<p>使用tomcat作为web容器时，接收浏览器发送过来的请求，tomcat会将请求信息封装成ServletRequest对象，如下图①处对象。但是大家想想ServletRequest是一个接口，它还有一个子接口HttpServletRequest，而我们知道该request对象肯定是一个HttpServletRequest对象的子实现类对象，到底是哪个类的对象呢？可以通过输出request对象，我们就会发现是一个名为RequestFacade的类的对象。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/7fe45f1701074db582d0ed201b065e09.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>RequestFacade类就使用了外观模式。先看结构图：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/a6a2954b0b504f30a4275377103f9678.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>为什么在此处使用外观模式呢？</strong></p>\n<p>定义 RequestFacade 类，分别实现 ServletRequest ，同时定义私有成员变量 Request ，并且方法的实现调用 Request  的实现。然后，将 RequestFacade上转为 ServletRequest  传给 servlet 的 service 方法，这样即使在 servlet 中被下转为 RequestFacade ，也不能访问私有成员变量对象中的方法。既用了 Request ，又能防止其中方法被不合理的访问。</p>\n<h2><a id=\"36__1600\"></a>3.6 组合模式</h2>\n<h3><a id=\"361__1602\"></a>3.6.1 概述</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/9989fa411d994b33832dadd593a89fab.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>​	对于这个图片肯定会非常熟悉，上图我们可以看做是一个文件系统，对于这样的结构我们称之为树形结构。在树形结构中可以通过调用某个方法来遍历整个树，当我们找到某个叶子节点后，就可以对叶子节点进行相关的操作。可以将这颗树理解成一个大的容器，容器里面包含很多的成员对象，这些成员对象即可是容器对象也可以是叶子对象。但是由于容器对象和叶子对象在功能上面的区别，使得我们在使用的过程中必须要区分容器对象和叶子对象，但是这样就会给客户带来不必要的麻烦，作为客户而已，它始终希望能够一致的对待容器对象和叶子对象。</p>\n<p><strong>定义：</strong></p>\n<p>​	又名部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p>\n<h3><a id=\"362__1613\"></a>3.6.2 结构</h3>\n<p>组合模式主要包含三种角色：</p>\n<ul>\n<li>抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。</li>\n<li>树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。</li>\n<li>叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。</li>\n</ul>\n<h3><a id=\"363__1621\"></a>3.6.3 案例实现</h3>\n<p>【例】软件菜单</p>\n<p>如下图，我们在访问别的一些管理系统时，经常可以看到类似的菜单。一个菜单可以包含菜单项（菜单项是指不再包含其他内容的菜单条目），也可以包含带有其他菜单项的菜单，因此使用组合模式描述菜单就很恰当，我们的需求是针对一个菜单，打印出其包含的所有菜单以及菜单项的名称。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d5465a9b244a4709b3575d1265517d12.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>要实现该案例，我们先画出类图：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/e797c989e5a54ffa9d08c557a90c4b06.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>代码实现：</strong></p>\n<p>不管是菜单还是菜单项，都应该继承自统一的接口，这里姑且将这个统一的接口称为菜单组件。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//菜单组件  不管是菜单还是菜单项，都应该继承该类</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MenuComponent</span> </span>{\n\n    <span class=\"hljs-keyword\">protected</span> String name;\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">int</span> level;\n\n    <span class=\"hljs-comment\">//添加菜单</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(MenuComponent menuComponent)</span></span>{\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> UnsupportedOperationException();\n    }\n\n    <span class=\"hljs-comment\">//移除菜单</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(MenuComponent menuComponent)</span></span>{\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> UnsupportedOperationException();\n    }\n\n    <span class=\"hljs-comment\">//获取指定的子菜单</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> MenuComponent <span class=\"hljs-title\">getChild</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> i)</span></span>{\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> UnsupportedOperationException();\n    }\n\n    <span class=\"hljs-comment\">//获取菜单名称</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">getName</span><span class=\"hljs-params\">()</span></span>{\n        <span class=\"hljs-keyword\">return</span> name;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">()</span></span>{\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> UnsupportedOperationException();\n    }\n}\n</code></div></pre>\n<p>这里的MenuComponent定义为抽象类，因为有一些共有的属性和行为要在该类中实现，Menu和MenuItem类就可以只覆盖自己感兴趣的方法，而不用搭理不需要或者不感兴趣的方法，举例来说，Menu类可以包含子菜单，因此需要覆盖add()、remove()、getChild()方法，但是MenuItem就不应该有这些方法。这里给出的默认实现是抛出异常，你也可以根据自己的需要改写默认实现。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Menu</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">MenuComponent</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> List&lt;MenuComponent&gt; menuComponentList;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Menu</span><span class=\"hljs-params\">(String name,<span class=\"hljs-keyword\">int</span> level)</span></span>{\n        <span class=\"hljs-keyword\">this</span>.level = level;\n        <span class=\"hljs-keyword\">this</span>.name = name;\n        menuComponentList = <span class=\"hljs-keyword\">new</span> ArrayList&lt;MenuComponent&gt;();\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(MenuComponent menuComponent)</span> </span>{\n        menuComponentList.add(menuComponent);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(MenuComponent menuComponent)</span> </span>{\n        menuComponentList.remove(menuComponent);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> MenuComponent <span class=\"hljs-title\">getChild</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> i)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> menuComponentList.get(i);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">()</span> </span>{\n\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; level; i++) {\n            System.out.print(<span class=\"hljs-string\">\"--\"</span>);\n        }\n        System.out.println(name);\n        <span class=\"hljs-keyword\">for</span> (MenuComponent menuComponent : menuComponentList) {\n            menuComponent.print();\n        }\n    }\n}\n</code></div></pre>\n<p>Menu类已经实现了除了getName方法的其他所有方法，因为Menu类具有添加菜单，移除菜单和获取子菜单的功能。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MenuItem</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">MenuComponent</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">MenuItem</span><span class=\"hljs-params\">(String name,<span class=\"hljs-keyword\">int</span> level)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.name = name;\n        <span class=\"hljs-keyword\">this</span>.level = level;\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; level; i++) {\n            System.out.print(<span class=\"hljs-string\">\"--\"</span>);\n        }\n        System.out.println(name);\n    }\n}\n</code></div></pre>\n<p>MenuItem是菜单项，不能再有子菜单，所以添加菜单，移除菜单和获取子菜单的功能并不能实现。</p>\n<h3><a id=\"364__1738\"></a>3.6.4 组合模式的分类</h3>\n<p>在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式。</p>\n<ul>\n<li>\n<p>透明组合模式</p>\n<p>透明组合模式中，抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中 <code>MenuComponent</code> 声明了 <code>add</code>、<code>remove</code> 、<code>getChild</code> 方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。</p>\n<p>透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 add()、remove() 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）</p>\n</li>\n<li>\n<p>安全组合模式</p>\n<p>在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点 <code>Menu</code> 类中声明并实现这些方法。安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/14145de2f378443184306c5c932da46c.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n</li>\n</ul>\n<h3><a id=\"365__1757\"></a>3.6.5 优点</h3>\n<ul>\n<li>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。</li>\n<li>客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。</li>\n<li>在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”。</li>\n<li>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。</li>\n</ul>\n<h3><a id=\"366__1766\"></a>3.6.6 使用场景</h3>\n<p>组合模式正是应树形结构而生，所以组合模式的使用场景就是出现树形结构的地方。比如：文件目录显示，多级目录呈现等树形结构数据的操作。</p>\n<h2><a id=\"37__1769\"></a>3.7 享元模式</h2>\n<h1><a id=\"4__1771\"></a>4. 行为型模式</h1>\n<p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p>\n<p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</p>\n<p>行为型模式分为：</p>\n<ul>\n<li>模板方法模式</li>\n<li>策略模式</li>\n<li>命令模式</li>\n<li>职责链模式</li>\n<li>状态模式</li>\n<li>观察者模式</li>\n<li>中介者模式</li>\n<li>迭代器模式</li>\n<li>访问者模式</li>\n<li>备忘录模式</li>\n<li>解释器模式</li>\n</ul>\n<p>以上 11 种行为型模式，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式。</p>\n<h2><a id=\"41__1793\"></a>4.1 模板方法模式</h2>\n<h3><a id=\"411__1795\"></a>4.1.1 概述</h3>\n<p>在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。</p>\n<p>例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。</p>\n<p><strong>定义：</strong></p>\n<p><mark>定义一个操作中的算法骨架，其实就是方法的执行顺序固定</mark>，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p>\n<h3><a id=\"412__1805\"></a>4.1.2 结构</h3>\n<p>模板方法（Template Method）模式包含以下主要角色：</p>\n<ul>\n<li>\n<p>抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。</p>\n<ul>\n<li>\n<p>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</p>\n</li>\n<li>\n<p>基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：</p>\n<ul>\n<li>\n<p>抽象方法(Abstract Method) ：一个抽象方法由抽象类声明、由其具体子类实现。</p>\n</li>\n<li>\n<p>具体方法(Concrete Method) ：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。</p>\n</li>\n<li>\n<p>钩子方法(Hook Method) ：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</p>\n<p>一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。</p>\n</li>\n</ul>\n<p>【例子】</p>\n<p>学生行为包括：先揉眼睛、看xx、闭上眼睛。但是前后一个都是必经的，所以我们不妨提取出骨架，保证执行顺序，但是具体看什么，由具体类实现具体看什么。比如看书、看电影。</p>\n<blockquote>\n<p>代码</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//学生行为抽象类</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StudentBehavior</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">look</span><span class=\"hljs-params\">()</span></span>;\n\n    <span class=\"hljs-comment\">//这里就是模板方法的算法骨架。我们把骨架放在抽象类（实体类也行，但是抽象类更符合，因为我们要去子类实现骨架中的方法）</span>\n    <span class=\"hljs-comment\">//而look则是由子类实现，子类可以不同方式实现，骨架不动。look()调用，同个类的实例方法调用，完整写法：this.look()，但可以省略的</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">process</span><span class=\"hljs-params\">()</span></span>{\n        System.out.println(<span class=\"hljs-string\">\"先揉眼睛\"</span>);\n        look();\n        System.out.println(<span class=\"hljs-string\">\"闭上眼睛\"</span>);\n    }\n}\n</code></div></pre>\n<p>具体类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StudentBook</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">StudentBehavior</span></span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">look</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"子类在看-&gt;书\"</span>);\n    }\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StudentFilm</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">StudentBehavior</span></span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">look</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"子类在看-&gt;电影\"</span>);\n    }\n}\n</code></div></pre>\n<p>测试：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        StudentBehavior studentBook = <span class=\"hljs-keyword\">new</span> StudentBook();\n        studentBook.process();\n        StudentBehavior studentFilm = <span class=\"hljs-keyword\">new</span> StudentFilm();\n        studentFilm.process();\n       <span class=\"hljs-comment\">/* 先揉眼睛\n            子类在看-&gt;书\n          闭上眼睛\n        =============\n         先揉眼睛\n            子类在看-&gt;电影\n         闭上眼睛*/</span>\n    }\n}\n</code></div></pre>\n<h3><a id=\"413__1883\"></a>4.1.3 优缺点</h3>\n<p><strong>优点：</strong></p>\n<ul>\n<li>\n<p>提高代码复用性</p>\n<p>将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。</p>\n</li>\n<li>\n<p>实现了反向控制</p>\n<p>通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。</p>\n</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li>\n<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li>\n</ul>\n<h3><a id=\"414__1902\"></a>4.1.4 适用场景</h3>\n<ul>\n<li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li>\n<li>需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。</li>\n</ul>\n<h3><a id=\"415_JDK_1907\"></a>4.1.5 JDK源码解析</h3>\n<p>InputStream类就使用了模板方法模式。在InputStream类中定义了多个 <code>read()</code> 方法，如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">InputStream</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Closeable</span> </span>{\n    <span class=\"hljs-comment\">//抽象方法，要求子类必须重写</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">read</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> IOException</span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">read</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">byte</span> b[])</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n        <span class=\"hljs-keyword\">return</span> read(b, <span class=\"hljs-number\">0</span>, b.length);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">read</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">byte</span> b[], <span class=\"hljs-keyword\">int</span> off, <span class=\"hljs-keyword\">int</span> len)</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n        <span class=\"hljs-keyword\">if</span> (b == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> NullPointerException();\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (off &lt; <span class=\"hljs-number\">0</span> || len &lt; <span class=\"hljs-number\">0</span> || len &gt; b.length - off) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IndexOutOfBoundsException();\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (len == <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n        }\n\n        <span class=\"hljs-keyword\">int</span> c = read(); <span class=\"hljs-comment\">//调用了无参的read方法，该方法是每次读取一个字节数据</span>\n        <span class=\"hljs-keyword\">if</span> (c == -<span class=\"hljs-number\">1</span>) {\n            <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;\n        }\n        b[off] = (<span class=\"hljs-keyword\">byte</span>)c;\n\n        <span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-keyword\">for</span> (; i &lt; len ; i++) {\n                c = read();\n                <span class=\"hljs-keyword\">if</span> (c == -<span class=\"hljs-number\">1</span>) {\n                    <span class=\"hljs-keyword\">break</span>;\n                }\n                b[off + i] = (<span class=\"hljs-keyword\">byte</span>)c;\n            }\n        } <span class=\"hljs-keyword\">catch</span> (IOException ee) {\n        }\n        <span class=\"hljs-keyword\">return</span> i;\n    }\n}\n</code></div></pre>\n<p>从上面代码可以看到，无参的 <code>read()</code> 方法是抽象方法，要求子类必须实现。而 <code>read(byte b[])</code> 方法调用了 <code>read(byte b[], int off, int len)</code> 方法，所以在此处重点看的方法是带三个参数的方法。</p>\n<p>在该方法中第18行、27行，可以看到调用了无参的抽象的 <code>read()</code> 方法。</p>\n<p>总结如下： 在InputStream父类中已经定义好了读取一个字节数组数据的方法是每次读取一个字节，并将其存储到数组的第一个索引位置，读取len个字节数据。具体如何读取一个字节数据呢？由子类实现。</p>\n<h2><a id=\"42__1957\"></a>4.2 策略模式</h2>\n<h3><a id=\"421__1959\"></a>4.2.1 概述</h3>\n<p>先看下面的图片，我们去旅游选择出行模式有很多种，可以骑自行车、可以坐汽车、可以坐火车、可以坐飞机。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2e43bbc948ab49e992aa7a11f112fda3.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>定义：</strong></p>\n<p>​	==该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。==策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p>\n<h3><a id=\"422__1972\"></a>4.2.2 结构</h3>\n<p>策略模式的主要角色如下：</p>\n<ul>\n<li>抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li>\n<li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。</li>\n<li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li>\n</ul>\n<p>【例子】</p>\n<blockquote>\n<p>代码</p>\n</blockquote>\n<p>移动接口</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">StrategyMove</span> </span>{    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">move</span><span class=\"hljs-params\">()</span></span>;}\n</code></div></pre>\n<p>移动实现类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StrategyRun</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">StrategyMove</span></span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">move</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"跑步\"</span>);\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StrategyWalk</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">StrategyMove</span></span>{\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">move</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"走路\"</span>);\n    }\n}\n</code></div></pre>\n<p>实现的对象（其实可以抽象化更好）又叫环境角色类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">/*\npublic abstract People implements StrategyMove{\n    @Override\n    public void move() {\n\n    }\n}\n这是反例!\n虽然我们可以理解说接口就是功能，但也不能作用在对象身上，\n因为如果新增People的子类，那就要重写父类方法，有些移动方法在其他对象其实已经写过了。\n如果新增了移动方法，那么所有的对象都要新增，维护成本极大！\n算法的变化不会影响使用算法的客户才行！而不是新增一个移动，就要新增改造对象。\n**希望的是移动方法由客户来替换而不是去改客户的代码！**\n《合成复用原则》\n*/</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">People</span> </span>{\n    StrategyMove strategyMove;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">People</span><span class=\"hljs-params\">(StrategyMove strategyMove)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.strategyMove = strategyMove;\n    }\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">move</span><span class=\"hljs-params\">()</span></span>{\n        strategyMove.move();\n    }\n}\n</code></div></pre>\n<p>测试</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        People people1 = <span class=\"hljs-keyword\">new</span> People(<span class=\"hljs-keyword\">new</span> StrategyRun());\n        people1.move();\n        People people2 = <span class=\"hljs-keyword\">new</span> People(<span class=\"hljs-keyword\">new</span> StrategyWalk());\n        people2.move();\n    }\n}\n</code></div></pre>\n<h3><a id=\"424__2053\"></a>4.2.4 优缺点</h3>\n<p><strong>1，优点：</strong></p>\n<ul>\n<li>\n<p>策略类之间可以自由切换</p>\n<p>由于策略类都实现同一个接口，所以使它们之间可以自由切换。</p>\n</li>\n<li>\n<p>易于扩展</p>\n<p>增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则“</p>\n</li>\n<li>\n<p>避免使用多重条件选择语句（if else），充分体现面向对象设计思想。</p>\n</li>\n</ul>\n<p><strong>2，缺点：</strong></p>\n<ul>\n<li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li>\n<li>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。</li>\n</ul>\n<h3><a id=\"425__2072\"></a>4.2.5 使用场景</h3>\n<ul>\n<li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</li>\n<li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。</li>\n<li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。</li>\n<li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。</li>\n<li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li>\n</ul>\n<h3><a id=\"426_JDK_2080\"></a>4.2.6 JDK源码解析</h3>\n<p><code>Comparator</code> 中的策略模式。在Arrays类中有一个 <code>sort()</code> 方法，如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Arrays</span></span>{\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sort</span><span class=\"hljs-params\">(T[] a, Comparator&lt;? <span class=\"hljs-keyword\">super</span> T&gt; c)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (c == <span class=\"hljs-keyword\">null</span>) {\n            sort(a);\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">if</span> (LegacyMergeSort.userRequested)\n                legacyMergeSort(a, c);\n            <span class=\"hljs-keyword\">else</span>\n                TimSort.sort(a, <span class=\"hljs-number\">0</span>, a.length, c, <span class=\"hljs-keyword\">null</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);\n        }\n    }\n}\n</code></div></pre>\n<p>Arrays就是一个环境角色类，这个sort方法可以传一个新策略让Arrays根据这个策略来进行排序。就比如下面的测试类。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">demo</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n\n        Integer[] data = {<span class=\"hljs-number\">12</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">1</span>};\n        <span class=\"hljs-comment\">// 实现降序排序</span>\n        Arrays.sort(data, <span class=\"hljs-keyword\">new</span> Comparator&lt;Integer&gt;() {\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(Integer o1, Integer o2)</span> </span>{\n                <span class=\"hljs-keyword\">return</span> o2 - o1;\n            }\n        });\n        System.out.println(Arrays.toString(data)); <span class=\"hljs-comment\">//[12, 5, 4, 3, 2, 2, 1]</span>\n    }\n}\n</code></div></pre>\n<p>这里我们在调用Arrays的sort方法时，第二个参数传递的是Comparator接口的子实现类对象。所以Comparator充当的是抽象策略角色，而具体的子实现类充当的是具体策略角色。环境角色类（Arrays）应该持有抽象策略的引用来调用。那么，Arrays类的sort方法到底有没有使用Comparator子实现类中的 <code>compare()</code> 方法吗？让我们继续查看TimSort类的 <code>sort()</code> 方法，代码如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TimSort</span>&lt;<span class=\"hljs-title\">T</span>&gt; </span>{\n    <span class=\"hljs-keyword\">static</span> &lt;T&gt; <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sort</span><span class=\"hljs-params\">(T[] a, <span class=\"hljs-keyword\">int</span> lo, <span class=\"hljs-keyword\">int</span> hi, Comparator&lt;? <span class=\"hljs-keyword\">super</span> T&gt; c,\n                         T[] work, <span class=\"hljs-keyword\">int</span> workBase, <span class=\"hljs-keyword\">int</span> workLen)</span> </span>{\n        <span class=\"hljs-keyword\">assert</span> c != <span class=\"hljs-keyword\">null</span> &amp;&amp; a != <span class=\"hljs-keyword\">null</span> &amp;&amp; lo &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;\n\n        <span class=\"hljs-keyword\">int</span> nRemaining  = hi - lo;\n        <span class=\"hljs-keyword\">if</span> (nRemaining &lt; <span class=\"hljs-number\">2</span>)\n            <span class=\"hljs-keyword\">return</span>;  <span class=\"hljs-comment\">// Arrays of size 0 and 1 are always sorted</span>\n\n        <span class=\"hljs-comment\">// If array is small, do a \"mini-TimSort\" with no merges</span>\n        <span class=\"hljs-keyword\">if</span> (nRemaining &lt; MIN_MERGE) {\n            <span class=\"hljs-keyword\">int</span> initRunLen = countRunAndMakeAscending(a, lo, hi, c);\n            binarySort(a, lo, hi, lo + initRunLen, c);\n            <span class=\"hljs-keyword\">return</span>;\n        }\n        ...\n    }   \n        \n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">countRunAndMakeAscending</span><span class=\"hljs-params\">(T[] a, <span class=\"hljs-keyword\">int</span> lo, <span class=\"hljs-keyword\">int</span> hi,Comparator&lt;? <span class=\"hljs-keyword\">super</span> T&gt; c)</span> </span>{\n        <span class=\"hljs-keyword\">assert</span> lo &lt; hi;\n        <span class=\"hljs-keyword\">int</span> runHi = lo + <span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-keyword\">if</span> (runHi == hi)\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n\n        <span class=\"hljs-comment\">// Find end of run, and reverse range if descending</span>\n        <span class=\"hljs-keyword\">if</span> (c.compare(a[runHi++], a[lo]) &lt; <span class=\"hljs-number\">0</span>) { <span class=\"hljs-comment\">// Descending</span>\n            <span class=\"hljs-keyword\">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class=\"hljs-number\">1</span>]) &lt; <span class=\"hljs-number\">0</span>)\n                runHi++;\n            reverseRange(a, lo, runHi);\n        } <span class=\"hljs-keyword\">else</span> {                              <span class=\"hljs-comment\">// Ascending</span>\n            <span class=\"hljs-keyword\">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class=\"hljs-number\">1</span>]) &gt;= <span class=\"hljs-number\">0</span>)\n                runHi++;\n        }\n\n        <span class=\"hljs-keyword\">return</span> runHi - lo;\n    }\n}\n</code></div></pre>\n<p>上面的代码中最终会跑到 <code>countRunAndMakeAscending()</code> 这个方法中。我们可以看见，只用了compare方法，所以在调用Arrays.sort方法只传具体compare重写方法的类对象就行，这也是Comparator接口中必须要子类实现的一个方法。</p>\n<h2><a id=\"43__2161\"></a>4.3 命令模式</h2>\n<h3><a id=\"431__2163\"></a>4.3.1 概述</h3>\n<p>日常生活中，我们出去吃饭都会遇到下面的场景。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/5086452cfc0449e4a79b2a9e2ca8d3e2.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>定义：</strong></p>\n<p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。</p>\n<h3><a id=\"432__2176\"></a>4.3.2 结构</h3>\n<p>命令模式包含以下主要角色：</p>\n<ul>\n<li>抽象命令类（Command）角色： 定义命令的接口，声明执行的方法。</li>\n<li>具体命令（Concrete  Command）角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。</li>\n<li>实现者/接收者（Receiver）角色： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。</li>\n<li>调用者/请求者（Invoker）角色： 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。</li>\n</ul>\n<h3><a id=\"433__2187\"></a>4.3.3 案例实现</h3>\n<p>将上面的案例用代码实现，那我们就需要分析命令模式的角色在该案例中由谁来充当。</p>\n<p>服务员： 就是调用者角色，由她来发起命令。</p>\n<p>资深大厨： 就是接收者角色，真正命令执行的对象。</p>\n<p>订单： 命令中包含订单。</p>\n<p>类图如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/ad057e08769a4ec4abab4d39368fbbec.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>代码如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">Command</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">execute</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//只需要定义一个统一的执行方法</span>\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">OrderCommand</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Command</span> </span>{\n\n    <span class=\"hljs-comment\">//持有接受者对象</span>\n    <span class=\"hljs-keyword\">private</span> SeniorChef receiver;\n    <span class=\"hljs-keyword\">private</span> Order order;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">OrderCommand</span><span class=\"hljs-params\">(SeniorChef receiver, Order order)</span></span>{\n        <span class=\"hljs-keyword\">this</span>.receiver = receiver;\n        <span class=\"hljs-keyword\">this</span>.order = order;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">execute</span><span class=\"hljs-params\">()</span>  </span>{\n        System.out.println(order.getDiningTable() + <span class=\"hljs-string\">\"桌的订单：\"</span>);\n        Set&lt;String&gt; keys = order.getFoodDic().keySet();\n        <span class=\"hljs-keyword\">for</span> (String key : keys) {\n            receiver.makeFood(order.getFoodDic().get(key),key);\n        }\n\n        <span class=\"hljs-keyword\">try</span> {\n            Thread.sleep(<span class=\"hljs-number\">100</span>);<span class=\"hljs-comment\">//停顿一下 模拟做饭的过程</span>\n        } <span class=\"hljs-keyword\">catch</span> (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n\n        System.out.println(order.getDiningTable() + <span class=\"hljs-string\">\"桌的饭弄好了\"</span>);\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Order</span> </span>{\n    <span class=\"hljs-comment\">// 餐桌号码</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> diningTable;\n\n    <span class=\"hljs-comment\">// 用来存储餐名并记录份数</span>\n    <span class=\"hljs-keyword\">private</span> Map&lt;String, Integer&gt; foodDic = <span class=\"hljs-keyword\">new</span> HashMap&lt;String, Integer&gt;();\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getDiningTable</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> diningTable;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setDiningTable</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> diningTable)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.diningTable = diningTable;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Map&lt;String, Integer&gt; <span class=\"hljs-title\">getFoodDic</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> foodDic;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setFoodDic</span><span class=\"hljs-params\">(String name, <span class=\"hljs-keyword\">int</span> num)</span> </span>{\n        foodDic.put(name,num);\n    }\n}\n\n<span class=\"hljs-comment\">// 资深大厨类 是命令的Receiver</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SeniorChef</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">makeFood</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> num,String foodName)</span> </span>{\n        System.out.println(num + <span class=\"hljs-string\">\"份\"</span> + foodName);\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Waitor</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> ArrayList&lt;Command&gt; commands;<span class=\"hljs-comment\">//可以持有很多的命令对象</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Waitor</span><span class=\"hljs-params\">()</span> </span>{\n        commands = <span class=\"hljs-keyword\">new</span> ArrayList();\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setCommand</span><span class=\"hljs-params\">(Command cmd)</span></span>{\n        commands.add(cmd);\n    }\n\n    <span class=\"hljs-comment\">// 发出命令 喊 订单来了，厨师开始执行</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">orderUp</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"美女服务员：叮咚，大厨，新订单来了.......\"</span>);\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; commands.size(); i++) {\n            Command cmd = commands.get(i);\n            <span class=\"hljs-keyword\">if</span> (cmd != <span class=\"hljs-keyword\">null</span>) {\n                cmd.execute();\n            }\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Client</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        <span class=\"hljs-comment\">//创建2个order</span>\n        Order order1 = <span class=\"hljs-keyword\">new</span> Order();\n        order1.setDiningTable(<span class=\"hljs-number\">1</span>);\n        order1.getFoodDic().put(<span class=\"hljs-string\">\"西红柿鸡蛋面\"</span>,<span class=\"hljs-number\">1</span>);\n        order1.getFoodDic().put(<span class=\"hljs-string\">\"小杯可乐\"</span>,<span class=\"hljs-number\">2</span>);\n\n        Order order2 = <span class=\"hljs-keyword\">new</span> Order();\n        order2.setDiningTable(<span class=\"hljs-number\">3</span>);\n        order2.getFoodDic().put(<span class=\"hljs-string\">\"尖椒肉丝盖饭\"</span>,<span class=\"hljs-number\">1</span>);\n        order2.getFoodDic().put(<span class=\"hljs-string\">\"小杯雪碧\"</span>,<span class=\"hljs-number\">1</span>);\n\n        <span class=\"hljs-comment\">//创建接收者</span>\n        SeniorChef receiver=<span class=\"hljs-keyword\">new</span> SeniorChef();\n        <span class=\"hljs-comment\">//将订单和接收者封装成命令对象</span>\n        OrderCommand cmd1 = <span class=\"hljs-keyword\">new</span> OrderCommand(receiver, order1);\n        OrderCommand cmd2 = <span class=\"hljs-keyword\">new</span> OrderCommand(receiver, order2);\n        <span class=\"hljs-comment\">//创建调用者 waitor</span>\n        Waitor invoker = <span class=\"hljs-keyword\">new</span> Waitor();\n        invoker.setCommand(cmd1);\n        invoker.setCommand(cmd2);\n\n        <span class=\"hljs-comment\">//将订单带到柜台 并向厨师喊 订单来了</span>\n        invoker.orderUp();\n    }\n}\n</code></div></pre>\n<h3><a id=\"434__2325\"></a>4.3.4 优缺点</h3>\n<p><strong>1，优点：</strong></p>\n<ul>\n<li>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。</li>\n<li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。</li>\n<li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</li>\n<li>方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。</li>\n</ul>\n<p><strong>2，缺点：</strong></p>\n<ul>\n<li>使用命令模式可能会导致某些系统有过多的具体命令类。</li>\n<li>系统结构更加复杂。</li>\n</ul>\n<h3><a id=\"435__2341\"></a>4.3.5 使用场景</h3>\n<ul>\n<li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li>\n<li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li>\n<li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</li>\n</ul>\n<h3><a id=\"436_JDK_2349\"></a>4.3.6 JDK源码解析</h3>\n<p>Runable是一个典型命令模式，Runnable担当命令的角色，Thread充当的是调用者，start方法就是其执行方法</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//命令接口(抽象命令角色)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">Runnable</span> </span>{\n	<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span>;\n}\n\n<span class=\"hljs-comment\">//调用者</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Thread</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Runnable</span> </span>{\n    <span class=\"hljs-keyword\">private</span> Runnable target;\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (threadStatus != <span class=\"hljs-number\">0</span>)\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalThreadStateException();\n\n        group.add(<span class=\"hljs-keyword\">this</span>);\n\n        <span class=\"hljs-keyword\">boolean</span> started = <span class=\"hljs-keyword\">false</span>;\n        <span class=\"hljs-keyword\">try</span> {\n            start0();\n            started = <span class=\"hljs-keyword\">true</span>;\n        } <span class=\"hljs-keyword\">finally</span> {\n            <span class=\"hljs-keyword\">try</span> {\n                <span class=\"hljs-keyword\">if</span> (!started) {\n                    group.threadStartFailed(<span class=\"hljs-keyword\">this</span>);\n                }\n            } <span class=\"hljs-keyword\">catch</span> (Throwable ignore) {\n            }\n        }\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">native</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">start0</span><span class=\"hljs-params\">()</span></span>;\n}\n</code></div></pre>\n<p>会调用一个native方法start0(),调用系统方法，开启一个线程。而接收者是对程序员开放的，可以自己定义接收者。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">/**\n * jdk Runnable 命令模式\n *		TurnOffThread ： 属于具体\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TurnOffThread</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Runnable</span></span>{\n     <span class=\"hljs-keyword\">private</span> Receiver receiver;\n    \n     <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">TurnOffThread</span><span class=\"hljs-params\">(Receiver receiver)</span> </span>{\n     	<span class=\"hljs-keyword\">this</span>.receiver = receiver;\n     }\n     <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>{\n     	receiver.turnOFF();\n     }\n}\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">/**\n * 测试类\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Demo</span> </span>{\n     <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n         Receiver receiver = <span class=\"hljs-keyword\">new</span> Receiver();\n         TurnOffThread turnOffThread = <span class=\"hljs-keyword\">new</span> TurnOffThread(receiver);\n         Thread thread = <span class=\"hljs-keyword\">new</span> Thread(turnOffThread);\n         thread.start();\n     }\n}\n</code></div></pre>\n<h2><a id=\"44__2420\"></a>4.4 责任链模式</h2>\n<h3><a id=\"441__2422\"></a>4.4.1 概述</h3>\n<p>在现实生活中，常常会出现这样的事例：一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。例如，公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这增加了难度。这样的例子还有很多，如找领导出差报销、生活中的“击鼓传花”游戏等。</p>\n<p><strong>定义：</strong></p>\n<p>又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p>\n<h3><a id=\"442__2432\"></a>4.4.2 结构</h3>\n<p>职责链模式主要包含以下角色:</p>\n<ul>\n<li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li>\n<li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li>\n<li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li>\n</ul>\n<h3><a id=\"443__2442\"></a>4.4.3 案例实现</h3>\n<p>一人想要借钱，有三个老板可以提供借钱，A老板最多借50元，B老板最多借钱100元，C老板最多借钱200元。</p>\n<blockquote>\n<p>代码</p>\n</blockquote>\n<p>抽象老板类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AbstractBoss</span> </span>{\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> MONEY_50=<span class=\"hljs-number\">50</span>;\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> MONEY_100=<span class=\"hljs-number\">100</span>;\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> MONEY_200=<span class=\"hljs-number\">200</span>;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> hasMoney;\n    <span class=\"hljs-keyword\">private</span> AbstractBoss nextBoss;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">AbstractBoss</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> hasMoney)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.hasMoney = hasMoney;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getHasMoney</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> hasMoney;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setAbstractBoss</span><span class=\"hljs-params\">(AbstractBoss nextBoss)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.nextBoss = nextBoss;\n    }\n\n    <span class=\"hljs-comment\">//不允许子类重写，属于结构型模式中模板方法模式，process是骨架,抽象lend由子类实现。</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">process</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> needMoney)</span></span>{\n        <span class=\"hljs-keyword\">if</span> (needMoney&lt;=<span class=\"hljs-keyword\">this</span>.hasMoney){\n            lend(needMoney);\n        }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">null</span>!=<span class=\"hljs-keyword\">this</span>.nextBoss){\n            <span class=\"hljs-keyword\">this</span>.nextBoss.process(needMoney);\n        }\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">lend</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> needMoney)</span></span>;\n}\n</code></div></pre>\n<p>具体老板类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BossA</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractBoss</span></span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">BossA</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> hasMoney)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(hasMoney);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">lend</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> needMoney)</span> </span>{\n        System.out.print(<span class=\"hljs-string\">\"A老板借出去\"</span>+needMoney+<span class=\"hljs-string\">\"元\"</span>);\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BossB</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractBoss</span></span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">BossB</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> hasMoney)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(hasMoney);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">lend</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> needMoney)</span> </span>{\n        System.out.print(<span class=\"hljs-string\">\"B老板借出去\"</span>+needMoney+<span class=\"hljs-string\">\"元\"</span>);\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BossC</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractBoss</span></span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">BossC</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> hasMoney)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(hasMoney);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">lend</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> needMoney)</span> </span>{\n        System.out.print(<span class=\"hljs-string\">\"C老板借出去\"</span>+needMoney+<span class=\"hljs-string\">\"元\"</span>);\n    }\n}\n</code></div></pre>\n<p>测试类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        AbstractBoss bossA = <span class=\"hljs-keyword\">new</span> BossA(AbstractBoss.MONEY_50);\n        AbstractBoss bossB = <span class=\"hljs-keyword\">new</span> BossB(AbstractBoss.MONEY_100);\n        AbstractBoss bossC = <span class=\"hljs-keyword\">new</span> BossC(AbstractBoss.MONEY_200);\n\n        <span class=\"hljs-comment\">//职责链从低层向上引用！确保钱被最佳化处理</span>\n        bossA.setAbstractBoss(bossB);\n        bossB.setAbstractBoss(bossC);\n\n        bossA.process(<span class=\"hljs-number\">49</span>);System.out.println(<span class=\"hljs-string\">\"(over)\"</span>);\n        bossA.process(<span class=\"hljs-number\">99</span>);System.out.println(<span class=\"hljs-string\">\"(over)\"</span>);\n        bossA.process(<span class=\"hljs-number\">199</span>);System.out.println(<span class=\"hljs-string\">\"(over)\"</span>);\n        bossA.process(<span class=\"hljs-number\">201</span>);System.out.println(<span class=\"hljs-string\">\"(over)\"</span>);\n\n    }\n}\nA老板借出去<span class=\"hljs-number\">49</span>元(over)\nB老板借出去<span class=\"hljs-number\">99</span>元(over)\nC老板借出去<span class=\"hljs-number\">199</span>元(over)\n(over)\n</code></div></pre>\n<h2><a id=\"45__2548\"></a>4.5 观察者模式</h2>\n<h3><a id=\"451__2550\"></a>4.5.1 概述</h3>\n<p><strong>定义：</strong></p>\n<p>又被称为发布-订阅（Publish/Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p>\n<h3><a id=\"452__2558\"></a>4.5.2 结构</h3>\n<p>在观察者模式中有如下角色：</p>\n<ul>\n<li>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</li>\n<li>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</li>\n<li>Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</li>\n<li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li>\n</ul>\n<h3><a id=\"453__2567\"></a>4.5.3 案例实现</h3>\n<p>【例】微信公众号</p>\n<p>在使用微信公众号时，大家都会有这样的体验，当你关注的公众号中有新内容更新的话，它就会推送给关注公众号的微信用户端。我们使用观察者模式来模拟这样的场景，微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了程序猿这个公众号。</p>\n<p>类图如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d9bf7fee5021423b972cd645ea0d32f7.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>代码如下：</p>\n<p>定义抽象观察者类，里面定义一个更新的方法</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">Observer</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">update</span><span class=\"hljs-params\">(String message)</span></span>;\n}\n</code></div></pre>\n<p>定义具体观察者类，微信用户是观察者，里面实现了更新的方法</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">WeixinUser</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Observer</span> </span>{\n    <span class=\"hljs-comment\">// 微信用户名</span>\n    <span class=\"hljs-keyword\">private</span> String name;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">WeixinUser</span><span class=\"hljs-params\">(String name)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.name = name;\n    }\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">update</span><span class=\"hljs-params\">(String message)</span> </span>{\n        System.out.println(name + <span class=\"hljs-string\">\"-\"</span> + message);\n    }\n}\n</code></div></pre>\n<p>定义抽象主题类，提供了attach、detach、notify三个方法</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">Subject</span> </span>{\n    <span class=\"hljs-comment\">//增加订阅者</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">attach</span><span class=\"hljs-params\">(Observer observer)</span></span>;\n\n    <span class=\"hljs-comment\">//删除订阅者</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">detach</span><span class=\"hljs-params\">(Observer observer)</span></span>;\n    \n    <span class=\"hljs-comment\">//通知订阅者更新消息</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">notify</span><span class=\"hljs-params\">(String message)</span></span>;\n}\n\n</code></div></pre>\n<p>微信公众号是具体主题（具体被观察者），里面存储了订阅该公众号的微信用户，并实现了抽象主题中的方法</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SubscriptionSubject</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Subject</span> </span>{\n    <span class=\"hljs-comment\">//储存订阅公众号的微信用户</span>\n    <span class=\"hljs-keyword\">private</span> List&lt;Observer&gt; weixinUserlist = <span class=\"hljs-keyword\">new</span> ArrayList&lt;Observer&gt;();\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">attach</span><span class=\"hljs-params\">(Observer observer)</span> </span>{\n        weixinUserlist.add(observer);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">detach</span><span class=\"hljs-params\">(Observer observer)</span> </span>{\n        weixinUserlist.remove(observer);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">notify</span><span class=\"hljs-params\">(String message)</span> </span>{\n        <span class=\"hljs-keyword\">for</span> (Observer observer : weixinUserlist) {\n            observer.update(message);\n        }\n    }\n}\n</code></div></pre>\n<p>客户端程序</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Client</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        SubscriptionSubject mSubscriptionSubject=<span class=\"hljs-keyword\">new</span> SubscriptionSubject();\n        <span class=\"hljs-comment\">//创建微信用户</span>\n        WeixinUser user1=<span class=\"hljs-keyword\">new</span> WeixinUser(<span class=\"hljs-string\">\"孙悟空\"</span>);\n        WeixinUser user2=<span class=\"hljs-keyword\">new</span> WeixinUser(<span class=\"hljs-string\">\"猪悟能\"</span>);\n        WeixinUser user3=<span class=\"hljs-keyword\">new</span> WeixinUser(<span class=\"hljs-string\">\"沙悟净\"</span>);\n        <span class=\"hljs-comment\">//订阅公众号</span>\n        mSubscriptionSubject.attach(user1);\n        mSubscriptionSubject.attach(user2);\n        mSubscriptionSubject.attach(user3);\n        <span class=\"hljs-comment\">//公众号更新发出消息给订阅的微信用户</span>\n        mSubscriptionSubject.notify(<span class=\"hljs-string\">\"传智黑马的专栏更新了\"</span>);\n    }\n}\n\n</code></div></pre>\n<h3><a id=\"454__2668\"></a>4.5.4 使用场景</h3>\n<ul>\n<li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</li>\n<li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面时。</li>\n</ul>\n<h3><a id=\"455_JDK_2673\"></a>4.5.5 JDK实现</h3>\n<p>在 Java 中，通过 java.util.Observable 类和 java.util.Observer 接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。</p>\n<p><strong>1，Observable类</strong></p>\n<p>Observable 类是抽象目标类（被观察者），它有一个 Vector 集合成员变量，用于保存所有要通知的观察者对象，下面来介绍它最重要的 3 个方法。</p>\n<ul>\n<li>\n<p>void addObserver(Observer o) 方法：用于将新的观察者对象添加到集合中。</p>\n</li>\n<li>\n<p>void notifyObservers(Object arg) 方法：调用集合中的所有观察者对象的 update方法，通知它们数据发生改变。通常越晚加入集合的观察者越先得到通知。</p>\n</li>\n<li>\n<p>void setChange() 方法：用来设置一个 boolean 类型的内部标志，注明目标对象发生了变化。当它为true时，notifyObservers() 才会通知观察者。</p>\n</li>\n</ul>\n<p><strong>2，Observer 接口</strong></p>\n<p>Observer 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 update 方法，进行相应的工作。</p>\n<p>【例子】</p>\n<p>多个警察抓一个小偷。</p>\n<p>警察</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//实现了这个接口 只是单单说明了警察是观察者。update是回调函数。</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Police</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Observer</span> </span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">update</span><span class=\"hljs-params\">(Observable o, Object arg)</span> </span>{\n        Thief o1 = (Thief) o;\n        System.out.println(<span class=\"hljs-string\">\"成功抓获小偷：\"</span>+o1.getName());\n    }\n}\n</code></div></pre>\n<p>小偷</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//小偷继承Observable表示是可以被观察的类。</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Thief</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Observable</span> </span>{\n    <span class=\"hljs-keyword\">private</span> String name;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">getName</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> name;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setName</span><span class=\"hljs-params\">(String name)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.name = name;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Thief</span><span class=\"hljs-params\">()</span> </span>{\n        setChanged();\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">steal</span><span class=\"hljs-params\">()</span></span>{\n        System.out.println(<span class=\"hljs-string\">\"小偷正在偷东西！\"</span>);\n        notifyObservers();<span class=\"hljs-comment\">//底层遍历了所有观察者并逐个执行其update方法。</span>\n    }\n\n}\n</code></div></pre>\n<p>测试类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        Thief thief = <span class=\"hljs-keyword\">new</span> Thief();\n        Police police = <span class=\"hljs-keyword\">new</span> Police();\n\n        thief.setName(<span class=\"hljs-string\">\"肥莫\"</span>);\n<span class=\"hljs-comment\">//        添加为小偷的观察者，才能使得警察的观察有作用，也就是update可以被调用了</span>\n        thief.addObserver(police);\n\n        thief.steal();\n    }\n}\n</code></div></pre>\n<h2><a id=\"46__2751\"></a>4.6 状态模式</h2>\n<h2><a id=\"47__2753\"></a>4.7 中介者模式</h2>\n<h2><a id=\"48__2755\"></a>4.8 迭代器模式</h2>\n<h2><a id=\"49__2757\"></a>4.9 访问者模式</h2>\n<h2><a id=\"410__2759\"></a>4.10 备忘录模式</h2>\n<h2><a id=\"411__2761\"></a>4.11 解释器模式</h2>\n',1405916999732707352),(1521822769621684226,'\n\n\n# 1. 类图概述\n统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。\n\nUML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图。\n\n类图(Class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。\n\n## 1.2 类图的作用\n\n* 在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解；\n* 类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。\n\n## 1.3 类图表示法\n\n### 1.3.1 类的表示方式\n\n在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name,age和address这3个属性，以及work()方法。 \n\n\n属性/方法名称前加的加号和减号表示了这个属性/方法的可见性，UML类图中表示可见性的符号有三种：\n\n* +：表示public\n\n* -：表示private\n\n* #：表示protected\n\n属性的完整表示方式是： **可见性  名称 ：类型 [ = 缺省值]**  \n\n方法的完整表示方式是： **可见性  名称(参数列表) [ ： 返回类型]**\n\n> 注意：\n>\n> 1，中括号中的内容表示是可选的\n>\n> 2，也有将类型放在变量名前面，返回值类型放在方法名前面\n\n**举个栗子：**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/04fd7b0a2dd048adb179e927ba586dad.png#pic_center)\n\n\n上图Demo类定义了三个方法：\n\n* method()方法：修饰符为public，没有参数，没有返回值。\n* method1()方法：修饰符为private，没有参数，返回值类型为String。\n* method2()方法：修饰符为protected，接收两个参数，第一个参数类型为int，第二个参数类型为String，返回值类型是int。\n\n### 1.3.2 类与类之间关系的表示方式\n\n#### 1.3.2.1 关联关系\n\n关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。\n\n关联又可以分为单向关联，双向关联，自关联。\n\n**1，单向关联**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d636bca3668743b08aea2ded7d8af0ff.png#pic_center)\n\n\n在UML类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。\n\n**2，双向关联**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/fd2544a1ba7248fab799c931fa589a1d.png#pic_center)\n\n\n从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。\n\n在UML类图中，双向关联用一个不带箭头的直线表示。上图中在Customer类中维护一个List\\<Product>，表示一个顾客可以购买多个商品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。\n\n**3，自关联**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6406fb400c2149a482547f3a6cbb21cb.png#pic_center)\n\n\n自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。\n\n\n\n#### 1.3.2.2 聚合关系\n\n聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。\n\n聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。\n\n在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。下图所示是大学和教师的关系图：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c17e7163c4da46c39c7564d9222f371f.png#pic_center)\n\n\n#### 1.3.2.3 组合关系\n\n组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。\n\n在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。\n\n在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。下图所示是头和嘴的关系图：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/0a9262e57101450d87e9295c8a7d78ab.png#pic_center)\n\n\n\n\n#### 1.3.2.4 依赖关系\n\n依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。\n\n在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是司机和汽车的关系图，司机驾驶汽车：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ef2a51cf0d714b4e807e2d7145d32ebb.png#pic_center)\n\n\n#### 1.3.2.5 继承关系\n\n继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。\n\n在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下图所示：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a3076e2833644fef8799a2f806cf0857.png#pic_center)\n\n\n\n\n#### 1.3.2.6 实现关系\n\n实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。\n\n在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如图 9 所示。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/18c9100e673346a1ae755058457e8d06.png#pic_center)\n\n\n\n\n\n\n# 常用设计模式\n\n==创建者：单例、工厂==\n\n==结构型：代理、适配器、装饰者、外观==\n\n==行为型：策略、模板、职责链、观察者、发布与订阅==\n\n# 1. 软件设计原则\n\n## 1.1 开闭原则\n\n**对扩展开放，对改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。\n\n> 想要达到这样的效果，我们需要使用接口和抽象类。\n\n【例】`搜狗输入法` 的皮肤设计。\n\n分析：`搜狗输入法` 的皮肤是输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，也可以从网上下载新的皮肤。这些皮肤有共同的特点，可以为其定义一个抽象类（AbstractSkin），而每个具体的皮肤（DefaultSpecificSkin和HeimaSpecificSkin）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。\n\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/c1d781a7e69949f58128646fb7d7fd03.png#pic_center)\n\n\n## 1.2 里氏代换原则\n\n​	里氏代换原则：任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。\n\n 	**子类可以扩展父类的功能，但不能改变父类原有的功能。** 也就是既不能重写父类的方法，也不能重载父类的方法。\n\n【例】\n\n父类长方形\n\n```java\npackage com.morris.pattern.lsp;\n\npublic class Rectangle {\n\n    protected int width;\n\n    protected int height;\n\n    public Rectangle(int width, int height) {\n        this.width = width;\n        this.height = height;\n    }\n\n    public int calcArea() {\n        return width * height;\n    }\n\n}\n```\n\n子类正方形\n\n```java\npackage com.morris.pattern.lsp;\n\npublic class Square extends Rectangle {\n\n    public Square(int width, int height) {\n        super(width, height);\n    }\n    @Override //重写了父类计算面积的方法\n    public int calcArea() {\n        return width * width;\n    }\n\n}\n```\n\n测试类\n\n```java\npackage com.morris.pattern.lsp;\n\npublic class App {\n\n    public static void main(String[] args) {\n        Rectangle rectangle = new Rectangle(10, 20); //长方\n        Rectangle rectangle = new Square(10, 20); //正方形\n        System.out.println(rectangle.calcArea());\n    }\n\n}\n```\n\n如果把长方形类Rectangle替换为正方形类Square，那么求出的面积就不正确了，原因是继承的时候重写了父类的getArea方法。这是违背里氏替换原则的。 \n\n## 1.3 依赖倒转原则\n\n​		高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\n\n> 个人认为跟开闭原则很像，都是要求面向接口 / 抽象编程。因为对接口编程时，很方便扩展，那么实现类修改了，只要接口不变，使用该接口的类也不需要变。**面向接口编程就能满足两种原则了！**\n\n【例】\n\n**之前**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/f133ab2a16df47a6864f45b12f12829b.png#pic_center)\n\n\n------------\n\n**之后**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6dfc0e3ef527423ba7f9c4533a5b3923.png#pic_center)\n\n\n## 1.4 接口隔离原则\n\n客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在**最小的接口**上。\n\n> 这里跟数据库的第一范式很相似，就是对于属性的粒度划分要刚刚好，要小到不能划分。\n>\n> 就像人能拉屎拉尿，也不应该将这两个功能写在同一接口里面，应该分开接口来写，因为有些人是不能拉尿的。\n\n## 1.5 迪米特法则\n\n**又叫最少知识原则。**\n\n其含义是：如果两个软件实体**无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用**。其目的是降低类之间的耦合度，提高模块的相对独立性。\n\n## 1.6 合成复用原则\n\n合成复用原则是指：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。\n\n【例】汽车分类管理程序\n\n汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。类图如下： \n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/efce48a226014b559795ab6e48f879e6.png#pic_center)\n\n\n从上面类图我们可以看到使用继承复用产生了很多子类，如果现在又有新的动力源或者新的颜色的话，就需要再定义新的类。我们试着将继承复用改为聚合复用看一下。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2d6f81f4cc6440339a8049951949b968.png#pic_center)\n\n\n# 2. 创建者模式\n\n创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。\n\n这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。\n\n创建型模式分为：\n\n* 单例模式\n* 工厂方法模式\n* 抽象工程模式\n* 原型模式\n* 建造者模式\n\n## 2.1 单例设计模式\n\n单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n\n这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\n\n### 2.1.1 单例模式的结构\n\n单例模式的主要有以下角色：\n\n* 单例类。只能创建一个实例的类\n* 访问类。使用单例类\n\n### 2.1.2 单例模式的实现\n\n> 单例设计模式分类两种：\n>\n> ​	饿汉式：类加载就会导致该单实例对象被创建	\n>\n> ​	懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建\n\n1. 饿汉式\n\n   ```java\n   /**\n    * 饿汉式\n    *      静态变量创建类的对象\n    */\n   public class Singleton {\n       //私有构造方法\n       private Singleton() {}\n   \n       //在成员位置创建该类的对象\n       private static Singleton instance = new Singleton();\n   \n       //对外提供静态方法获取该对象\n       public static Singleton getInstance() {\n           return instance;\n       }\n   }\n   ```\n\n2. 懒汉式\n\n   添加 `volatile` 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。\n\n   ```java\n   /**\n    * 双重检查方式\n    */\n   public class Singleton {\n   \n       //私有构造方法\n       private Singleton() {}\n   \n       private static volatile Singleton instance;\n   \n      //对外提供静态方法获取该对象\n       public static Singleton getInstance() {\n   		//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际\n           if(instance == null) {\n               synchronized (Singleton.class) {\n                   //抢到锁之后再次判断是否为空\n                   if(instance == null) {\n                       instance = new Singleton();\n                   }\n               }\n           }\n           return instance;\n       }\n   }\n   ```\n\n3. 懒汉式-方式4（静态内部类方式）\n\n   静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性/方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 `static` 修饰，保证只被实例化一次，并且严格保证实例化顺序。\n\n   ```java\n   /**\n    * 静态内部类方式\n    */\n   public class Singleton {\n   \n       //私有构造方法\n       private Singleton() {}\n   \n       private static class SingletonHolder {\n           private static final Singleton INSTANCE = new Singleton();\n       }\n   \n       //对外提供静态方法获取该对象\n       public static Singleton getInstance() {\n           return SingletonHolder.INSTANCE;\n       }\n   }\n   ```\n\n4. 枚举方式\n\n   枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。\n\n   ```java\n   /**\n    * 枚举方式\n    */\n   public enum Singleton {\n       INSTANCE;\n   }\n   ```\n\n### 2.1.3 存在的问题及解决\n\n>  *反序列化破坏单例的解决方式* \n\n​	在Singleton类中添加`readResolve()`方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。 \n\n\n```java\npublic class Singleton implements Serializable {\n\n    //私有构造方法\n    private Singleton() {}\n\n    private static class SingletonHolder {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n\n    //对外提供静态方法获取该对象\n    public static Singleton getInstance() {\n        return SingletonHolder.INSTANCE;\n    }\n    \n    /**\n     * 下面是为了解决序列化反序列化破解单例模式\n     */\n    private Object readResolve() {\n        return SingletonHolder.INSTANCE;\n    }\n}\n```\n\n> 反射方式破解单例的解决方法\n>\n\n```java\npublic class Singleton {\n\n    //私有构造方法\n    private Singleton() {\n        /*\n           反射破解单例模式需要添加的代码\n        */\n        if(instance != null) {\n            throw new RuntimeException();\n        }\n    }\n    \n    private static volatile Singleton instance;\n\n    //对外提供静态方法获取该对象\n    public static Singleton getInstance() {\n\n        if(instance != null) {\n            return instance;\n        }\n\n        synchronized (Singleton.class) {\n            if(instance != null) {\n                return instance;\n            }\n            instance = new Singleton();\n            return instance;\n        }\n    }\n}\n```\n\n## 2.2 工厂模式\n\n在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。\n\n如果**我们使用工厂来生产对象**，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：**解耦**。\n\n### 2.2.1 简单工厂模式\n\n简单工厂不是一种设计模式，反而比较像是一种编程习惯。\n\n>  结构\n\n简单工厂包含如下角色：\n\n* 抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。\n* 具体产品 ：实现或者继承抽象产品的子类\n* 具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/71636e5b69354341b5cc24642eec09ec.png#pic_center)\n\n\n> 优缺点\n\n**优点：**\n\n封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。\n\n**缺点：**\n\n增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。\n\n> 扩展\n\n**静态工厂**\n\n在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是23种设计模式中的。代码如下：\n\n```java\npublic class SimpleCoffeeFactory {\n\n    public static Coffee createCoffee(String type) {\n        Coffee coffee = null;\n        if(\"americano\".equals(type)) {\n            coffee = new AmericanoCoffee();\n        } else if(\"latte\".equals(type)) {\n            coffee = new LatteCoffee();\n        }\n        return coffe;\n    }\n}\n```\n\n### 2.2.2 工厂方法模式\n\n>  概念\n\n定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。\n\n> 结构\n\n工厂方法模式的主要角色：\n\n* 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。\n* 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。\n* 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。\n* 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d7bc2712a78a4a32857f74e2d7e6d791.png#pic_center)\n\n\n代码如下：\n\n抽象工厂：\n\n```java\npublic interface CoffeeFactory {\n\n    Coffee createCoffee();\n}\n```\n\n具体工厂：\n\n```java\npublic class LatteCoffeeFactory implements CoffeeFactory {\n\n    public Coffee createCoffee() {\n        return new LatteCoffee();\n    }\n}\n\npublic class AmericanCoffeeFactory implements CoffeeFactory {\n\n    public Coffee createCoffee() {\n        return new AmericanCoffee();\n    }\n}\n```\n\n咖啡店类：\n\n```java\npublic class CoffeeStore {\n\n    private CoffeeFactory factory;\n\n    public CoffeeStore(CoffeeFactory factory) {\n        this.factory = factory;\n    }\n\n    public Coffee orderCoffee(String type) {\n        Coffee coffee = factory.createCoffee();\n        coffee.addMilk();\n        coffee.addsugar();\n        return coffee;\n    }\n}\n```\n\n从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点。\n\n工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。\n\n### 2.2.3 抽象工厂模式\n\n前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、传智播客只培养计算机软件专业的学生等。\n\n这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。\n\n本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，下图所示横轴是产品等级，也就是同一类产品；纵轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/669b5f6bcec94e5f8e2b8cc61bd79eba.png#pic_center)\n\n\n比如：咖啡分美式英式等为同一等级。咖啡、奶茶、果汁为同一族，而应把他们抽象成同一产品族：饮料工厂。\n\n> 概念\n\n抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。\n\n>  结构\n\n抽象工厂模式的主要角色如下：\n\n* 抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。\n* 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。\n* 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。\n* 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。\n\n> 实现\n\n现咖啡店业务发生改变，不仅要生产咖啡还要生产甜点，如提拉米苏、抹茶慕斯等，要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。其中拿铁咖啡、美式咖啡是一个产品等级，都是咖啡；提拉米苏、抹茶慕斯也是一个产品等级；拿铁咖啡和提拉米苏是同一产品族（也就是都属于意大利风味），美式咖啡和抹茶慕斯是同一产品族（也就是都属于美式风味）。所以这个案例可以使用抽象工厂模式实现。类图如下：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d3354cf0800b4dbd8a21065e6a214c13.png#pic_center)\n\n\n> 优缺点\n\n**优点：**\n\n当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。\n\n**缺点：**\n\n当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。\n\n###  2.2.4 模式扩展\n\n**简单工厂+配置文件解除耦合**\n\n可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。\n\n第一步：定义配置文件\n\n为了演示方便，我们使用properties文件作为配置文件，名称为bean.properties\n\n```properties\namerican=com.itheima.pattern.factory.config_factory.AmericanCoffee\nlatte=com.itheima.pattern.factory.config_factory.LatteCoffee\n```\n\n第二步：改进工厂类\n\n```java\npublic class CoffeeFactory {\n\n    private static Map<String,Coffee> map = new HashMap();\n\n    static {\n        Properties p = new Properties();\n        InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream(\"bean.properties\");\n        try {\n            p.load(is);\n            //遍历Properties集合对象\n            Set<Object> keys = p.keySet();\n            for (Object key : keys) {\n                //根据键获取值（全类名）\n                String className = p.getProperty((String) key);\n                //获取字节码对象\n                Class clazz = Class.forName(className);\n                Coffee obj = (Coffee) clazz.newInstance();\n                map.put((String)key,obj);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static Coffee createCoffee(String name) {\n\n        return map.get(name);\n    }\n}\n```\n\n静态成员变量用来存储创建的对象（键存储的是名称，值存储的是对应的对象），而读取配置文件以及创建对象写在静态代码块中，目的就是只需要执行一次。\n\n## 2.3 原型模式\n\n> 概述\n\n用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。\n\n> 结构\n\n原型模式包含如下角色：\n\n* 抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。\n* 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。\n* 访问类：使用具体原型类中的 clone() 方法来复制新的对象。\n\n> 实现\n>\n\n原型模式的克隆分为浅克隆和深克隆。\n\n- 浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。\n\n  ==克隆后的对象本身地址改变，但是克隆后的对象的成员变量中引用类型的数据的地址仍然与原型对象一致==\n\n- 深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。\n\n  ==里里外外就是一个新对象==\n\nJava中的Object类中提供了 `clone()` 方法来实现浅克隆。 Cloneable 接口是上面的类图中的抽象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。\n\n> 浅克隆\n\n```java\npublic class Realizetype implements Cloneable { //实现浅克隆接口\n\n    public Realizetype() {\n        System.out.println(\"具体的原型对象创建完成！\");//手动new对象用的是构造器，但是clone方法不是用的构造器\n    }\n\n    @Override\n    protected Realizetype clone() throws CloneNotSupportedException {\n        System.out.println(\"具体原型复制成功！\");\n        return (Realizetype) super.clone();\n    }\n}\n```\n\n> 深克隆\n>\n\n通过序列化与反序列化方式完成深克隆，注意：==自定义对象需要实现序列化接口==\n\n```java\npublic class CitationTest1 {\n    public static void main(String[] args) throws Exception {\n        Citation c1 = new Citation();\n        Student stu = new Student(\"张三\", \"西安\");\n        c1.setStu(stu);\n\n        //创建对象输出流对象\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"C:\\\\Users\\\\Think\\\\Desktop\\\\b.txt\"));\n        //将c1对象写出到文件中\n        oos.writeObject(c1);\n        oos.close();\n\n        //创建对象出入流对象\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"C:\\\\Users\\\\Think\\\\Desktop\\\\b.txt\"));\n        //读取对象\n        Citation c2 = (Citation) ois.readObject();\n        //获取c2奖状所属学生对象\n        Student stu1 = c2.getStu();\n        stu1.setName(\"李四\");\n\n        //判断stu对象和stu1对象是否是同一个对象\n        System.out.println(\"stu和stu1是同一个对象？\" + (stu == stu1));\n\n        c1.show();\n        c2.show();\n    }\n}\n```\n\n# 3. 结构型模式\n\n结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。\n\n由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。\n\n结构型模式分为以下 7 种：\n\n* 代理模式\n* 适配器模式\n* 装饰者模式\n* 桥接模式\n* 外观模式\n* 组合模式\n* 享元模式\n\n\n\n## 3.1 代理模式\n\n### 3.1.1 概述\n\n由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\n\nJava中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。\n\n### 3.1.2 结构\n\n代理（Proxy）模式分为三种角色：\n\n* 抽象主题（Subject）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n* 真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n* 代理（Proxy）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n### 3.1.3 静态代理\n\n【例】火车站卖票\n\n如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。类图如下：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/5320fe83001649cd9a0067e36c60a1a5.png#pic_center)\n\n\n代码如下：\n\n```java\n//卖票接口\npublic interface SellTickets {\n    void sell();\n}\n\n//火车站  火车站具有卖票功能，所以需要实现SellTickets接口\npublic class TrainStation implements SellTickets {\n\n    public void sell() {\n        System.out.println(\"火车站卖票\");\n    }\n}\n\n//代售点\npublic class ProxyPoint implements SellTickets {\n\n    private TrainStation station = new TrainStation();\n\n    public void sell() {\n        System.out.println(\"代理点收取一些服务费用\");\n        station.sell();\n    }\n}\n\n//测试类\npublic class Client {\n    public static void main(String[] args) {\n        ProxyPoint pp = new ProxyPoint();\n        pp.sell();\n    }\n}\n```\n\n从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介。同时也对sell方法进行了增强（代理点收取一些服务费用）。\n\n### 3.1.4 JDK动态代理\n\n代码如下：\n\n```java\n//卖票接口\npublic interface SellTickets {\n    void sell();\n}\n\n//火车站  火车站具有卖票功能，所以需要实现SellTickets接口\npublic class TrainStation implements SellTickets {\n\n    public void sell() {\n        System.out.println(\"火车站卖票\");\n    }\n}\n\n//代理工厂，用来创建代理对象\npublic class ProxyFactory {\n\n    private TrainStation station = new TrainStation();\n\n    public SellTickets getProxyObject() {\n        //使用Proxy获取代理对象\n        /*\n            newProxyInstance()方法参数说明：\n                ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可\n                Class<?>[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口\n                InvocationHandler h ： 代理对象的调用处理程序\n         */\n        SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),\n                station.getClass().getInterfaces(),\n                new InvocationHandler() {\n                    /*\n                        InvocationHandler中invoke方法参数说明：\n                            proxy ： 代理对象\n                            method ： 对应于在代理对象上调用的接口方法的 Method 实例\n                            args ： 代理对象调用接口方法时传递的实际参数\n                     */\n                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\n                        System.out.println(\"代理点收取一些服务费用(JDK动态代理方式)\");\n                        //执行真实对象\n                        Object result = method.invoke(station, args);\n                        return result;\n                    }\n                });\n        return sellTickets;\n    }\n}\n\n//测试类\npublic class Client {\n    public static void main(String[] args) {\n        //获取代理对象\n        ProxyFactory factory = new ProxyFactory();\n        \n        SellTickets proxyObject = factory.getProxyObject();\n        proxyObject.sell();\n    }\n}\n```\n\n执行流程如下：\n\n  1. 在测试类中通过代理对象调用sell()方法\n  2. 根据多态的特性，执行的是代理类（$Proxy0）中的sell()方法\n  3. 代理类（$Proxy0）中的sell()方法中又调用了InvocationHandler接口的子实现类对象的invoke方法\n  4. invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法\n\n### 3.1.5 CGLIB动态代理\n\n同样是上面的案例，我们再次使用CGLIB代理实现。\n\n如果没有定义SellTickets接口，只定义了TrainStation(火车站类)。很显然JDK代理是无法使用了，因为JDK动态代理要求必须定义接口，对接口进行代理。\n\nCGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。\n\nCGLIB是第三方提供的包，所以需要引入jar包的坐标：\n\n```xml\n<dependency>\n    <groupId>cglib</groupId>\n    <artifactId>cglib</artifactId>\n    <version>2.2.2</version>\n</dependency>\n```\n\n代码如下：\n\n```java\n//火车站\npublic class TrainStation {\n\n    public void sell() {\n        System.out.println(\"火车站卖票\");\n    }\n}\n\n//代理工厂\npublic class ProxyFactory implements MethodInterceptor {\n\n    private TrainStation target = new TrainStation();\n\n    public TrainStation getProxyObject() {\n        //创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数\n        Enhancer enhancer =new Enhancer();\n        //设置父类的字节码对象\n        enhancer.setSuperclass(target.getClass());\n        //设置回调函数\n        enhancer.setCallback(this);\n        //创建代理对象\n        TrainStation obj = (TrainStation) enhancer.create();\n        return obj;\n    }\n\n    /*\n        intercept方法参数说明：\n            o ： 代理对象\n            method ： 真实对象中的方法的Method实例\n            args ： 实际参数\n            methodProxy ：代理对象中的方法的method实例\n     */\n    public TrainStation intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n        System.out.println(\"代理点收取一些服务费用(CGLIB动态代理方式)\");\n        TrainStation result = (TrainStation) methodProxy.invokeSuper(o, args);\n        return result;\n    }\n}\n\n//测试类\npublic class Client {\n    public static void main(String[] args) {\n        //创建代理工厂对象\n        ProxyFactory factory = new ProxyFactory();\n        //获取代理对象\n        TrainStation proxyObject = factory.getProxyObject();\n\n        proxyObject.sell();\n    }\n}\n```\n\n### 3.1.6 三种代理的对比\n\n* jdk代理和CGLIB代理\n\n  使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。\n\n  在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理。\n\n* 动态代理和静态代理\n\n  动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。\n\n  如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题\n\n\n\n### 3.1.7 优缺点\n\n**优点：**\n\n- 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n- 代理对象可以扩展目标对象的功能；\n- 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；\n\n**缺点：**\n\n* 增加了系统的复杂度；\n\n## 3.2 适配器模式\n\n### 3.2.1 概述\n\n 如果去欧洲国家去旅游的话，他们的插座如下图最左边，是欧洲标准。而我们使用的插头如下图最右边的。因此我们的笔记本电脑，手机在当地不能直接充电。所以就需要一个插座转换器，转换器第1面插入当地的插座，第2面供我们充电，这样使得我们的插头在当地能使用。生活中这样的例子很多，手机充电器（将220v转换为5v的电压），读卡器等，其实就是使用到了适配器模式。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b59606ae4a414f0382d89c3e819d28b2.png#pic_center)\n\n\n**定义：**\n\n​	将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。\n\n​	适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。\n\n### 3.2.2 结构\n\n适配器模式（Adapter）包含以下主要角色：\n\n* 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。\n* 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。\n* 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。\n\n> 适配器模式分为类适配器与对象适配器，对象适配器跟广泛一些。\n>\n\n### 3.2.3 对象适配器模式\n\n我们有一个 *NewMediaPlayer* 接口和一个实现了 *NewMediaPlayer* 接口的实体类 *NewMediaPlayerImpl*。默认情况下，NewMediaPlayerImpl可以播放 mp3 格式的音频文件。\n\n我们还有另一个接口 *AdvancedMediaPlayer* 和实现了 *AdvancedMediaPlayer* 接口的实体类。该类可以播放 avi和 mp4 格式的文件。\n\n我们想要让 NewMediaPlayerImpl播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 *NewMediaPlayer*接口的适配器类 *MediaAdapter*，并使用 *AdvancedMediaPlayer* 对象来播放所需的格式。\n\n> 类图\n>\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a4dacadcc9dc4590a54d26ce24c1131f.png#pic_center)\n\n\n> 代码\n\n1. AdvanceMediaPlayer接口代码\n\n```java\npublic interface AdvanceMediaPlayer {\n    void playMp4(String filename);\n    void playAvi(String filename);\n}\n```\n\n2. 实现AdvanceMediaPlayer接口的类AdvanceMediaPlayerImpl\n\n```java\npublic class AdvanceMediaPlayerImpl implements AdvanceMediaPlayer {\n\n    @Override\n    public void playMp4(String filename) {\n        System.out.println(\"原生播放器播放mp4:\"+filename);\n    }\n\n    @Override\n    public void playAvi(String filename) {\n        System.out.println(\"原生播放器播放Avi:\"+filename);\n    }\n}\n```\n\n3. NewMediaPlayer接口\n\n```java\npublic interface NewMediaPlayer {\n    void playMp3(String filename);\n}\n```\n\n4. 适配器类MediaAdapter\n\n```java\npublic class MediaAdapter implements NewMediaPlayer {\n//    适配器，是为了新播放器能够使用已经有的播放器（MP4，avi），所以使用者只是希望调用旧的播放器来播放\n//    因此，使用者只管在适配器中调用新播放器的接口的方法，但适配器实际用的是就播放器，但使用者不关心。\n//    为了不混乱，规定某个对象被扩展功能，其则是新播放器，需要为其适配器\n    AdvanceMediaPlayer advanceMediaPlayer;\n\n    /**\n     * 注意，这里的方法名有mp3，只是给使用者看的，\n     * 内部透明，但是作为适配器，\n     * 内部实际上调用的是advance播放器接口\n     *\n     * @param filename\n     */\n    @Override\n    public void playMp3(String filename) {\n        advanceMediaPlayer = new AdvanceMediaPlayerImpl();\n        if (filename.indexOf(\"mp4\") > 0) {\n            System.out.print(\"适配器接手==>\");\n            advanceMediaPlayer.playMp4(filename);\n        } else if (filename.indexOf(\"avi\") > 0) {\n            System.out.print(\"适配器接手==>\");\n            advanceMediaPlayer.playAvi(filename);\n        }\n    }\n```\n\n5. NewMediaPlayer接口实现类NewMediaPlayerImpl\n\n```java\npublic class NewMediaPlayerImpl implements NewMediaPlayer {\n    private MediaAdapter mediaAdapter;\n\n    /**\n     * 如果是mp3格式，对象本身可以播放，\n     * 但如果是mp4/avi则不支持，\n     * 需要调用适配器中的方法来播放其他格式\n     *\n     * @param filename\n     */\n    @Override\n    public void playMp3(String filename) {\n        if (filename.indexOf(\"mp3\") > 0) {\n//            对象本身支持mp3\n            System.out.println(\"新的播放器播放mp3:\" + filename);\n        } else if (filename.indexOf(\"mp4\") > 0 || filename.indexOf(\"avi\") > 0) {\n//            对象不支持，调用适配器api\n            mediaAdapter = new MediaAdapter();\n            mediaAdapter.playMp3(filename);\n        }\n    }\n\n}\n```\n\n6. 测试类\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        NewMediaPlayer newMediaPlayer = new NewMediaPlayerImpl();\n        newMediaPlayer.playMp3(\"苍井空.mp3\");\n        newMediaPlayer.playMp3(\"苍井空.mp4\");\n        newMediaPlayer.playMp3(\"苍井空.avi\");\n\n    }\n}\n```\n\n7. 结果\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e56fe80d00ac4b9dbadd13617828c47b.png#pic_center)\n\n\n## 3.3 装饰者模式\\*\\*\\*\n\n### 3.3.1 结构\n\n装饰（Decorator）模式中的角色：\n\n* 抽象构件（Component）角色 ：定义一个抽象接口以规范准备接收附加责任的对象。\n* 具体构件（Concrete  Component）角色 ：实现抽象构件，通过装饰角色为其添加一些职责。\n* 抽象装饰（Decorator）角色 ： ==继承或实现抽象构件，并包含具体构件的实例==，可以通过其子类扩展具体构件的功能。==妙处所在==\n* 具体装饰（ConcreteDecorator）角色 ：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。\n\n### 3.3.2 案例\n\n快餐+配菜。快餐有米饭、面条，配菜有鸡蛋、培根\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c7f9a7b4f78847e6b62a2eaee725d8c6.png#pic_center)\n\n\n\n\n> 代码\n>\n\n快餐抽象类\n\n```java\npublic abstract class FastFood {\n    private float price;\n    private String Description;\n\n    public FastFood() {\n    }\n\n    public FastFood(float price, String description) {\n        this.price = price;\n        Description = description;\n    }\n\n    public float getPrice() {\n        return price;\n    }\n\n    public void setPrice(float price) {\n        this.price = price;\n    }\n\n    public String getDescription() {\n        return Description;\n    }\n\n    public void setDescription(String description) {\n        Description = description;\n    }\n}\n```\n\n快餐实现类\n\n```java\n//炒饭\npublic class FriedRice extends FastFood{\n    public FriedRice() {\n        super(10, \"炒饭\");\n    }\n}\n//炒面\npublic class FriedNoodles extends FastFood{\n    public FriedNoodles(float price, String description) {\n        super(20, \"炒面\");\n    }\n}\n```\n\n装饰者抽象类\n\n```java\n/**\n * 装饰者本身既要继承/实现快餐类，并且要聚合被快餐类！\n * 因为鸡蛋培根都是装饰者的子类，该鸡蛋培根的子类是给快餐装饰的，所以鸡蛋培根快餐属于同一族，因此装饰者要继承快餐类，这样子鸡蛋培根就跟快餐同一族，\n * 拥有相同的属性，这样才能凑合。\n * 对于装饰者本身就是属于鸡蛋、培根，但是装饰者的字段是快餐\n *\n */\npublic abstract class Garnish extends FastFood{\n    private FastFood fastFood;\n\n    public FastFood getFastFood() {\n        return fastFood;\n    }\n\n//    给子类实现，实例化为鸡蛋、培根，这样装饰者本身是鸡蛋、培根。而FastFood是本来就有的快餐，赋值给装饰者字段\n    public Garnish(float price, String description, FastFood fastFood) {\n        super(price, description);\n        this.fastFood = fastFood;\n    }\n\n    public abstract float cost();\n\n}\n```\n\n装饰者的子类\n\n```java\n//Garnish实现了FastFood所以才有价格，描述的属性，getPrice只是获取鸡蛋的价格，注意继承类，只是继承类的字段，字段的具体值由子类决定，所以说为什么这里的价格只是鸡蛋的价格。\npublic class Egg extends Garnish{\n\n    public Egg(FastFood fastFood) {\n        super(1, \"鸡蛋\", fastFood);\n    }\n\n    @Override\n    public float cost() {\n        return getPrice()+ getFastFood().getPrice();\n    }\n\n    @Override\n    public String getDescription() {\n        return super.getDescription()+getFastFood().getDescription();\n    }\n}\n```\n\n测试类\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        FastFood rice = new FriedRice();\n        System.out.println(rice.getDescription()+\"  \"+rice.getPrice());\n//        炒饭  10.0\n        Egg egg = new Egg(rice);\n        System.out.println(egg.getDescription()+\"   \"+egg.cost());\n//        鸡蛋炒饭   11.0\n    }\n}\n```\n\n\n\n**好处：**\n\n* 饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任。\n\n* 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。\n\n## 3.4 桥接模式\n\n### 5.4.1 概述\n\n现在有一个需求，需要创建不同的图形，并且每个图形都有可能会有不同的颜色。我们可以利用继承的方式来设计类的关系：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b8135ce6beda429d880509790cb65f98.png#pic_center)\n\n\n我们可以发现有很多的类，假如我们再增加一个形状或再增加一种颜色，就需要创建更多的类。\n\n试想，在一个有多种可能会变化的维度的系统中，用继承方式会造成类爆炸，扩展起来不灵活。每次在一个维度上新增一个具体实现都要增加多个子类。为了更加灵活的设计系统，我们此时可以考虑使用桥接模式。\n\n**定义：**\n\n​	将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。\n\n\n\n### 3.4.2 结构\n\n桥接（Bridge）模式包含以下主要角色：\n\n* 抽象化（Abstraction）角色 ：定义抽象类，并包含一个对实现化对象的引用。\n* 扩展抽象化（Refined  Abstraction）角色 ：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。\n* 实现化（Implementor）角色 ：定义实现化角色的接口，供扩展抽象化角色调用。\n* 具体实现化（Concrete Implementor）角色 ：给出实现化角色接口的具体实现。\n\n### 3.4.3 案例\n\n【例】视频播放器\n\n需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等。该播放器包含了两个维度，适合使用桥接模式。\n\n类图如下：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/34cba7a4e76f4da78727d2298754e361.png#pic_center)\n\n\n\n\n代码如下：\n\n```java\n//视频文件\npublic interface VideoFile {\n    void decode(String fileName);\n}\n\n//avi文件\npublic class AVIFile implements VideoFile {\n    public void decode(String fileName) {\n        System.out.println(\"avi视频文件：\"+ fileName);\n    }\n}\n\n//rmvb文件\npublic class REVBBFile implements VideoFile {\n\n    public void decode(String fileName) {\n        System.out.println(\"rmvb文件：\" + fileName);\n    }\n}\n\n//操作系统版本\npublic abstract class OperatingSystemVersion {\n\n    protected VideoFile videoFile;\n\n    public OperatingSystemVersion(VideoFile videoFile) {\n        this.videoFile = videoFile;\n    }\n\n    public abstract void play(String fileName);\n}\n\n//Windows版本\npublic class Windows extends OperatingSystem {\n\n    public Windows(VideoFile videoFile) {\n        super(videoFile);\n    }\n\n    public void play(String fileName) {\n        videoFile.decode(fileName);\n    }\n}\n\n//mac版本\npublic class Mac extends OperatingSystemVersion {\n\n    public Mac(VideoFile videoFile) {\n        super(videoFile);\n    }\n\n    public void play(String fileName) {\n		videoFile.decode(fileName);\n    }\n}\n\n//测试类\npublic class Client {\n    public static void main(String[] args) {\n        OperatingSystem os = new Windows(new AVIFile());\n        os.play(\"战狼3\");\n    }\n}\n```\n\n**好处：**\n\n* 桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。\n\n  如：如果现在还有一种视频文件类型wmv，我们只需要再定义一个类实现VideoFile接口即可，其他类不需要发生变化。\n\n* 实现细节对客户透明\n\n### 3.4.4 使用场景\n\n* 当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。\n* 当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。\n* 当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。\n\n## 3.5 外观模式\n\n### 3.5.1 概述\n\n有些人可能炒过股票，但其实大部分人都不太懂，这种没有足够了解证券知识的情况下做股票是很容易亏钱的，刚开始炒股肯定都会想，如果有个懂行的帮帮手就好，其实基金就是个好帮手，支付宝里就有许多的基金，它将投资者分散的资金集中起来，交由专业的经理人进行管理，投资于股票、债券、外汇等领域，而基金投资的收益归持有者所有，管理机构收取一定比例的托管管理费用。\n\n**定义：**\n\n​	又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。\n\n​	外观（Facade）模式是“迪米特法则”的典型应用\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/0aedecfb7114485c9b0d59c860499b77.png#pic_center)\n\n\n\n\n### 3.5.2 结构\n\n外观（Facade）模式包含以下主要角色：\n\n* 外观（Facade）角色：为多个子系统对外提供一个共同的接口。\n* 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。\n\n### 3.5.3 案例\n\n【例】智能家电控制\n\n小明的爷爷已经60岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；操作起来都比较麻烦。所以小明给爷爷买了智能音箱，可以通过语音直接控制这些智能家电的开启和关闭。类图如下：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d76aca27d02b4f5995cbc5506bcfd117.png#pic_center)\n\n\n代码如下：\n\n```java\n//灯类\npublic class Light {\n    public void on() {\n        System.out.println(\"打开了灯....\");\n    }\n\n    public void off() {\n        System.out.println(\"关闭了灯....\");\n    }\n}\n\n//电视类\npublic class TV {\n    public void on() {\n        System.out.println(\"打开了电视....\");\n    }\n\n    public void off() {\n        System.out.println(\"关闭了电视....\");\n    }\n}\n\n//控制类\npublic class AirCondition {\n    public void on() {\n        System.out.println(\"打开了空调....\");\n    }\n\n    public void off() {\n        System.out.println(\"关闭了空调....\");\n    }\n}\n\n//智能音箱\npublic class SmartAppliancesFacade {\n\n    private Light light;\n    private TV tv;\n    private AirCondition airCondition;\n\n    public SmartAppliancesFacade() {\n        light = new Light();\n        tv = new TV();\n        airCondition = new AirCondition();\n    }\n\n    public void say(String message) {\n        if(message.contains(\"打开\")) {\n            on();\n        } else if(message.contains(\"关闭\")) {\n            off();\n        } else {\n            System.out.println(\"我还听不懂你说的！！！\");\n        }\n    }\n\n    //起床后一键开电器\n    private void on() {\n        System.out.println(\"起床了\");\n        light.on();\n        tv.on();\n        airCondition.on();\n    }\n\n    //睡觉一键关电器\n    private void off() {\n        System.out.println(\"睡觉了\");\n        light.off();\n        tv.off();\n        airCondition.off();\n    }\n}\n\n//测试类\npublic class Client {\n    public static void main(String[] args) {\n        //创建外观对象\n        SmartAppliancesFacade facade = new SmartAppliancesFacade();\n        //客户端直接与外观对象进行交互\n        facade.say(\"打开家电\");\n        facade.say(\"关闭家电\");\n    }\n}\n```\n\n**好处：**\n\n* 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。\n* 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。\n\n**缺点：**\n\n* 不符合开闭原则，修改很麻烦\n\n\n\n### 3.5.4 使用场景\n\n* 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。\n* 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。\n* 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。\n\n\n\n### 3.5.5 源码解析\n\n使用tomcat作为web容器时，接收浏览器发送过来的请求，tomcat会将请求信息封装成ServletRequest对象，如下图①处对象。但是大家想想ServletRequest是一个接口，它还有一个子接口HttpServletRequest，而我们知道该request对象肯定是一个HttpServletRequest对象的子实现类对象，到底是哪个类的对象呢？可以通过输出request对象，我们就会发现是一个名为RequestFacade的类的对象。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7fe45f1701074db582d0ed201b065e09.png#pic_center)\n\n\nRequestFacade类就使用了外观模式。先看结构图：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a6a2954b0b504f30a4275377103f9678.png#pic_center)\n\n\n**为什么在此处使用外观模式呢？**\n\n定义 RequestFacade 类，分别实现 ServletRequest ，同时定义私有成员变量 Request ，并且方法的实现调用 Request  的实现。然后，将 RequestFacade上转为 ServletRequest  传给 servlet 的 service 方法，这样即使在 servlet 中被下转为 RequestFacade ，也不能访问私有成员变量对象中的方法。既用了 Request ，又能防止其中方法被不合理的访问。\n\n## 3.6 组合模式\n\n### 3.6.1 概述\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/9989fa411d994b33832dadd593a89fab.png#pic_center)\n\n\n​	对于这个图片肯定会非常熟悉，上图我们可以看做是一个文件系统，对于这样的结构我们称之为树形结构。在树形结构中可以通过调用某个方法来遍历整个树，当我们找到某个叶子节点后，就可以对叶子节点进行相关的操作。可以将这颗树理解成一个大的容器，容器里面包含很多的成员对象，这些成员对象即可是容器对象也可以是叶子对象。但是由于容器对象和叶子对象在功能上面的区别，使得我们在使用的过程中必须要区分容器对象和叶子对象，但是这样就会给客户带来不必要的麻烦，作为客户而已，它始终希望能够一致的对待容器对象和叶子对象。\n\n**定义：**\n\n​	又名部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。\n\n### 3.6.2 结构\n\n组合模式主要包含三种角色：\n\n* 抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。\n* 树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。\n* 叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。\n\n### 3.6.3 案例实现\n\n【例】软件菜单\n\n如下图，我们在访问别的一些管理系统时，经常可以看到类似的菜单。一个菜单可以包含菜单项（菜单项是指不再包含其他内容的菜单条目），也可以包含带有其他菜单项的菜单，因此使用组合模式描述菜单就很恰当，我们的需求是针对一个菜单，打印出其包含的所有菜单以及菜单项的名称。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d5465a9b244a4709b3575d1265517d12.png#pic_center)\n\n\n要实现该案例，我们先画出类图：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e797c989e5a54ffa9d08c557a90c4b06.png#pic_center)\n\n\n**代码实现：**\n\n不管是菜单还是菜单项，都应该继承自统一的接口，这里姑且将这个统一的接口称为菜单组件。\n\n```java\n//菜单组件  不管是菜单还是菜单项，都应该继承该类\npublic abstract class MenuComponent {\n\n    protected String name;\n    protected int level;\n\n    //添加菜单\n    public void add(MenuComponent menuComponent){\n        throw new UnsupportedOperationException();\n    }\n\n    //移除菜单\n    public void remove(MenuComponent menuComponent){\n        throw new UnsupportedOperationException();\n    }\n\n    //获取指定的子菜单\n    public MenuComponent getChild(int i){\n        throw new UnsupportedOperationException();\n    }\n\n    //获取菜单名称\n    public String getName(){\n        return name;\n    }\n\n    public void print(){\n        throw new UnsupportedOperationException();\n    }\n}\n```\n\n这里的MenuComponent定义为抽象类，因为有一些共有的属性和行为要在该类中实现，Menu和MenuItem类就可以只覆盖自己感兴趣的方法，而不用搭理不需要或者不感兴趣的方法，举例来说，Menu类可以包含子菜单，因此需要覆盖add()、remove()、getChild()方法，但是MenuItem就不应该有这些方法。这里给出的默认实现是抛出异常，你也可以根据自己的需要改写默认实现。\n\n```java\npublic class Menu extends MenuComponent {\n\n    private List<MenuComponent> menuComponentList;\n\n    public Menu(String name,int level){\n        this.level = level;\n        this.name = name;\n        menuComponentList = new ArrayList<MenuComponent>();\n    }\n\n    @Override\n    public void add(MenuComponent menuComponent) {\n        menuComponentList.add(menuComponent);\n    }\n\n    @Override\n    public void remove(MenuComponent menuComponent) {\n        menuComponentList.remove(menuComponent);\n    }\n\n    @Override\n    public MenuComponent getChild(int i) {\n        return menuComponentList.get(i);\n    }\n\n    @Override\n    public void print() {\n\n        for (int i = 1; i < level; i++) {\n            System.out.print(\"--\");\n        }\n        System.out.println(name);\n        for (MenuComponent menuComponent : menuComponentList) {\n            menuComponent.print();\n        }\n    }\n}\n```\n\nMenu类已经实现了除了getName方法的其他所有方法，因为Menu类具有添加菜单，移除菜单和获取子菜单的功能。\n\n```java\npublic class MenuItem extends MenuComponent {\n\n    public MenuItem(String name,int level) {\n        this.name = name;\n        this.level = level;\n    }\n\n    @Override\n    public void print() {\n        for (int i = 1; i < level; i++) {\n            System.out.print(\"--\");\n        }\n        System.out.println(name);\n    }\n}\n```\n\nMenuItem是菜单项，不能再有子菜单，所以添加菜单，移除菜单和获取子菜单的功能并不能实现。\n\n\n\n### 3.6.4 组合模式的分类\n\n在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式。\n\n* 透明组合模式\n\n  透明组合模式中，抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中 `MenuComponent` 声明了 `add`、`remove` 、`getChild` 方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。\n\n  透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 add()、remove() 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）\n\n* 安全组合模式\n\n  在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点 `Menu` 类中声明并实现这些方法。安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。\n\n  ![在这里插入图片描述](https://img-blog.csdnimg.cn/14145de2f378443184306c5c932da46c.png#pic_center)\n\n\n\n\n### 3.6.5 优点\n\n* 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。\n* 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。\n* 在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”。\n* 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。\n\n\n\n### 3.6.6 使用场景\n\n组合模式正是应树形结构而生，所以组合模式的使用场景就是出现树形结构的地方。比如：文件目录显示，多级目录呈现等树形结构数据的操作。\n## 3.7 享元模式\n\n# 4. 行为型模式\n\n行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。\n\n行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。\n\n行为型模式分为：\n\n* 模板方法模式\n* 策略模式\n* 命令模式\n* 职责链模式\n* 状态模式\n* 观察者模式\n* 中介者模式\n* 迭代器模式\n* 访问者模式\n* 备忘录模式\n* 解释器模式\n\n以上 11 种行为型模式，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式。\n\n## 4.1 模板方法模式\n\n### 4.1.1 概述\n\n在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。\n\n例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。\n\n**定义：**\n\n==定义一个操作中的算法骨架，其实就是方法的执行顺序固定==，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。\n\n###  4.1.2 结构\n\n模板方法（Template Method）模式包含以下主要角色：\n\n* 抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。\n\n  * 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。\n\n  * 基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：\n\n    * 抽象方法(Abstract Method) ：一个抽象方法由抽象类声明、由其具体子类实现。\n\n    * 具体方法(Concrete Method) ：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。\n\n    * 钩子方法(Hook Method) ：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。\n\n      一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。\n\n* 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。\n\n【例子】\n\n学生行为包括：先揉眼睛、看xx、闭上眼睛。但是前后一个都是必经的，所以我们不妨提取出骨架，保证执行顺序，但是具体看什么，由具体类实现具体看什么。比如看书、看电影。\n\n> 代码\n\n```java\n//学生行为抽象类\npublic abstract class StudentBehavior {\n    abstract void look();\n\n    //这里就是模板方法的算法骨架。我们把骨架放在抽象类（实体类也行，但是抽象类更符合，因为我们要去子类实现骨架中的方法）\n    //而look则是由子类实现，子类可以不同方式实现，骨架不动。look()调用，同个类的实例方法调用，完整写法：this.look()，但可以省略的\n    public void process(){\n        System.out.println(\"先揉眼睛\");\n        look();\n        System.out.println(\"闭上眼睛\");\n    }\n}\n```\n\n具体类\n\n```java\npublic class StudentBook extends StudentBehavior{\n    @Override\n    public void look() {\n        System.out.println(\"子类在看->书\");\n    }\n}\npublic class StudentFilm extends StudentBehavior{\n    @Override\n    void look() {\n        System.out.println(\"子类在看->电影\");\n    }\n}\n```\n\n测试：\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        StudentBehavior studentBook = new StudentBook();\n        studentBook.process();\n        StudentBehavior studentFilm = new StudentFilm();\n        studentFilm.process();\n       /* 先揉眼睛\n            子类在看->书\n          闭上眼睛\n        =============\n         先揉眼睛\n            子类在看->电影\n         闭上眼睛*/\n    }\n}\n```\n\n### 4.1.3 优缺点\n\n**优点：**\n\n* 提高代码复用性\n\n  将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。\n\n* 实现了反向控制\n\n  通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。\n\n**缺点：**\n\n* 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。\n* 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。\n\n\n\n### 4.1.4 适用场景\n\n* 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\n* 需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。\n\n### 4.1.5 JDK源码解析\n\nInputStream类就使用了模板方法模式。在InputStream类中定义了多个 `read()` 方法，如下：\n\n```java\npublic abstract class InputStream implements Closeable {\n    //抽象方法，要求子类必须重写\n    public abstract int read() throws IOException;\n\n    public int read(byte b[]) throws IOException {\n        return read(b, 0, b.length);\n    }\n\n    public int read(byte b[], int off, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (off < 0 || len < 0 || len > b.length - off) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        }\n\n        int c = read(); //调用了无参的read方法，该方法是每次读取一个字节数据\n        if (c == -1) {\n            return -1;\n        }\n        b[off] = (byte)c;\n\n        int i = 1;\n        try {\n            for (; i < len ; i++) {\n                c = read();\n                if (c == -1) {\n                    break;\n                }\n                b[off + i] = (byte)c;\n            }\n        } catch (IOException ee) {\n        }\n        return i;\n    }\n}\n```\n\n从上面代码可以看到，无参的 `read()` 方法是抽象方法，要求子类必须实现。而 `read(byte b[])` 方法调用了 `read(byte b[], int off, int len)` 方法，所以在此处重点看的方法是带三个参数的方法。 \n\n在该方法中第18行、27行，可以看到调用了无参的抽象的 `read()` 方法。\n\n总结如下： 在InputStream父类中已经定义好了读取一个字节数组数据的方法是每次读取一个字节，并将其存储到数组的第一个索引位置，读取len个字节数据。具体如何读取一个字节数据呢？由子类实现。\n\n## 4.2 策略模式\n\n### 4.2.1 概述\n\n先看下面的图片，我们去旅游选择出行模式有很多种，可以骑自行车、可以坐汽车、可以坐火车、可以坐飞机。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2e43bbc948ab49e992aa7a11f112fda3.png#pic_center)\n\n\n\n\n**定义：**\n\n​	==该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。==策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。\n\n### 4.2.2 结构\n\n策略模式的主要角色如下：\n\n* 抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。\n* 具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。\n* 环境（Context）类：持有一个策略类的引用，最终给客户端调用。\n\n【例子】\n\n> 代码\n\n移动接口\n\n```java\npublic interface StrategyMove {    void move();}\n```\n\n移动实现类\n\n```java\npublic class StrategyRun implements StrategyMove{\n    @Override\n    public void move() {\n        System.out.println(\"跑步\");\n    }\n}\n\npublic class StrategyWalk implements StrategyMove{\n\n    @Override\n    public void move() {\n        System.out.println(\"走路\");\n    }\n}\n```\n\n实现的对象（其实可以抽象化更好）又叫环境角色类\n\n```java\n/*\npublic abstract People implements StrategyMove{\n    @Override\n    public void move() {\n\n    }\n}\n这是反例!\n虽然我们可以理解说接口就是功能，但也不能作用在对象身上，\n因为如果新增People的子类，那就要重写父类方法，有些移动方法在其他对象其实已经写过了。\n如果新增了移动方法，那么所有的对象都要新增，维护成本极大！\n算法的变化不会影响使用算法的客户才行！而不是新增一个移动，就要新增改造对象。\n**希望的是移动方法由客户来替换而不是去改客户的代码！**\n《合成复用原则》\n*/\n\npublic class People {\n    StrategyMove strategyMove;\n\n    public People(StrategyMove strategyMove) {\n        this.strategyMove = strategyMove;\n    }\n    public void move(){\n        strategyMove.move();\n    }\n}\n```\n\n测试\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        People people1 = new People(new StrategyRun());\n        people1.move();\n        People people2 = new People(new StrategyWalk());\n        people2.move();\n    }\n}\n```\n\n### 4.2.4 优缺点\n\n**1，优点：**\n\n* 策略类之间可以自由切换\n\n  由于策略类都实现同一个接口，所以使它们之间可以自由切换。\n\n* 易于扩展\n\n  增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则“\n\n* 避免使用多重条件选择语句（if else），充分体现面向对象设计思想。\n\n**2，缺点：**\n\n* 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。\n* 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。\n\n### 4.2.5 使用场景\n\n* 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\n* 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\n* 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\n* 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。\n* 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\n\n### 4.2.6 JDK源码解析\n\n`Comparator` 中的策略模式。在Arrays类中有一个 `sort()` 方法，如下：\n\n```java\npublic class Arrays{\n    public static <T> void sort(T[] a, Comparator<? super T> c) {\n        if (c == null) {\n            sort(a);\n        } else {\n            if (LegacyMergeSort.userRequested)\n                legacyMergeSort(a, c);\n            else\n                TimSort.sort(a, 0, a.length, c, null, 0, 0);\n        }\n    }\n}\n```\n\nArrays就是一个环境角色类，这个sort方法可以传一个新策略让Arrays根据这个策略来进行排序。就比如下面的测试类。\n\n```java\npublic class demo {\n    public static void main(String[] args) {\n\n        Integer[] data = {12, 2, 3, 2, 4, 5, 1};\n        // 实现降序排序\n        Arrays.sort(data, new Comparator<Integer>() {\n            public int compare(Integer o1, Integer o2) {\n                return o2 - o1;\n            }\n        });\n        System.out.println(Arrays.toString(data)); //[12, 5, 4, 3, 2, 2, 1]\n    }\n}\n```\n\n这里我们在调用Arrays的sort方法时，第二个参数传递的是Comparator接口的子实现类对象。所以Comparator充当的是抽象策略角色，而具体的子实现类充当的是具体策略角色。环境角色类（Arrays）应该持有抽象策略的引用来调用。那么，Arrays类的sort方法到底有没有使用Comparator子实现类中的 `compare()` 方法吗？让我们继续查看TimSort类的 `sort()` 方法，代码如下：\n\n```java\nclass TimSort<T> {\n    static <T> void sort(T[] a, int lo, int hi, Comparator<? super T> c,\n                         T[] work, int workBase, int workLen) {\n        assert c != null && a != null && lo >= 0 && lo <= hi && hi <= a.length;\n\n        int nRemaining  = hi - lo;\n        if (nRemaining < 2)\n            return;  // Arrays of size 0 and 1 are always sorted\n\n        // If array is small, do a \"mini-TimSort\" with no merges\n        if (nRemaining < MIN_MERGE) {\n            int initRunLen = countRunAndMakeAscending(a, lo, hi, c);\n            binarySort(a, lo, hi, lo + initRunLen, c);\n            return;\n        }\n        ...\n    }   \n        \n    private static <T> int countRunAndMakeAscending(T[] a, int lo, int hi,Comparator<? super T> c) {\n        assert lo < hi;\n        int runHi = lo + 1;\n        if (runHi == hi)\n            return 1;\n\n        // Find end of run, and reverse range if descending\n        if (c.compare(a[runHi++], a[lo]) < 0) { // Descending\n            while (runHi < hi && c.compare(a[runHi], a[runHi - 1]) < 0)\n                runHi++;\n            reverseRange(a, lo, runHi);\n        } else {                              // Ascending\n            while (runHi < hi && c.compare(a[runHi], a[runHi - 1]) >= 0)\n                runHi++;\n        }\n\n        return runHi - lo;\n    }\n}\n```\n\n上面的代码中最终会跑到 `countRunAndMakeAscending()` 这个方法中。我们可以看见，只用了compare方法，所以在调用Arrays.sort方法只传具体compare重写方法的类对象就行，这也是Comparator接口中必须要子类实现的一个方法。\n\n## 4.3 命令模式\n\n### 4.3.1 概述\n\n日常生活中，我们出去吃饭都会遇到下面的场景。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/5086452cfc0449e4a79b2a9e2ca8d3e2.png#pic_center)\n\n\n**定义：**\n\n将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。\n\n\n\n### 4.3.2 结构\n\n命令模式包含以下主要角色：\n\n* 抽象命令类（Command）角色： 定义命令的接口，声明执行的方法。\n* 具体命令（Concrete  Command）角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。\n* 实现者/接收者（Receiver）角色： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。\n* 调用者/请求者（Invoker）角色： 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。\n\n\n\n### 4.3.3 案例实现\n\n将上面的案例用代码实现，那我们就需要分析命令模式的角色在该案例中由谁来充当。\n\n服务员： 就是调用者角色，由她来发起命令。\n\n资深大厨： 就是接收者角色，真正命令执行的对象。\n\n订单： 命令中包含订单。\n\n类图如下：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ad057e08769a4ec4abab4d39368fbbec.png#pic_center)\n\n\n代码如下：\n\n```java\npublic interface Command {\n    void execute();//只需要定义一个统一的执行方法\n}\n\npublic class OrderCommand implements Command {\n\n    //持有接受者对象\n    private SeniorChef receiver;\n    private Order order;\n\n    public OrderCommand(SeniorChef receiver, Order order){\n        this.receiver = receiver;\n        this.order = order;\n    }\n\n    public void execute()  {\n        System.out.println(order.getDiningTable() + \"桌的订单：\");\n        Set<String> keys = order.getFoodDic().keySet();\n        for (String key : keys) {\n            receiver.makeFood(order.getFoodDic().get(key),key);\n        }\n\n        try {\n            Thread.sleep(100);//停顿一下 模拟做饭的过程\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n\n        System.out.println(order.getDiningTable() + \"桌的饭弄好了\");\n    }\n}\n\npublic class Order {\n    // 餐桌号码\n    private int diningTable;\n\n    // 用来存储餐名并记录份数\n    private Map<String, Integer> foodDic = new HashMap<String, Integer>();\n\n    public int getDiningTable() {\n        return diningTable;\n    }\n\n    public void setDiningTable(int diningTable) {\n        this.diningTable = diningTable;\n    }\n\n    public Map<String, Integer> getFoodDic() {\n        return foodDic;\n    }\n\n    public void setFoodDic(String name, int num) {\n        foodDic.put(name,num);\n    }\n}\n\n// 资深大厨类 是命令的Receiver\npublic class SeniorChef {\n\n    public void makeFood(int num,String foodName) {\n        System.out.println(num + \"份\" + foodName);\n    }\n}\n\npublic class Waitor {\n\n    private ArrayList<Command> commands;//可以持有很多的命令对象\n\n    public Waitor() {\n        commands = new ArrayList();\n    }\n    \n    public void setCommand(Command cmd){\n        commands.add(cmd);\n    }\n\n    // 发出命令 喊 订单来了，厨师开始执行\n    public void orderUp() {\n        System.out.println(\"美女服务员：叮咚，大厨，新订单来了.......\");\n        for (int i = 0; i < commands.size(); i++) {\n            Command cmd = commands.get(i);\n            if (cmd != null) {\n                cmd.execute();\n            }\n        }\n    }\n}\n\npublic class Client {\n    public static void main(String[] args) {\n        //创建2个order\n        Order order1 = new Order();\n        order1.setDiningTable(1);\n        order1.getFoodDic().put(\"西红柿鸡蛋面\",1);\n        order1.getFoodDic().put(\"小杯可乐\",2);\n\n        Order order2 = new Order();\n        order2.setDiningTable(3);\n        order2.getFoodDic().put(\"尖椒肉丝盖饭\",1);\n        order2.getFoodDic().put(\"小杯雪碧\",1);\n\n        //创建接收者\n        SeniorChef receiver=new SeniorChef();\n        //将订单和接收者封装成命令对象\n        OrderCommand cmd1 = new OrderCommand(receiver, order1);\n        OrderCommand cmd2 = new OrderCommand(receiver, order2);\n        //创建调用者 waitor\n        Waitor invoker = new Waitor();\n        invoker.setCommand(cmd1);\n        invoker.setCommand(cmd2);\n\n        //将订单带到柜台 并向厨师喊 订单来了\n        invoker.orderUp();\n    }\n}\n```\n\n\n\n### 4.3.4 优缺点\n\n**1，优点：**\n\n* 降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。\n* 增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。\n* 可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。\n* 方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。\n\n**2，缺点：**\n\n* 使用命令模式可能会导致某些系统有过多的具体命令类。\n* 系统结构更加复杂。\n\n\n\n### 4.3.5 使用场景\n\n* 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。\n* 系统需要在不同的时间指定请求、将请求排队和执行请求。\n* 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。\n\n\n\n### 4.3.6 JDK源码解析\n\nRunable是一个典型命令模式，Runnable担当命令的角色，Thread充当的是调用者，start方法就是其执行方法\n\n```java\n//命令接口(抽象命令角色)\npublic interface Runnable {\n	public abstract void run();\n}\n\n//调用者\npublic class Thread implements Runnable {\n    private Runnable target;\n    \n    public synchronized void start() {\n        if (threadStatus != 0)\n            throw new IllegalThreadStateException();\n\n        group.add(this);\n\n        boolean started = false;\n        try {\n            start0();\n            started = true;\n        } finally {\n            try {\n                if (!started) {\n                    group.threadStartFailed(this);\n                }\n            } catch (Throwable ignore) {\n            }\n        }\n    }\n    \n    private native void start0();\n}\n```\n\n会调用一个native方法start0(),调用系统方法，开启一个线程。而接收者是对程序员开放的，可以自己定义接收者。\n\n```java\n/**\n * jdk Runnable 命令模式\n *		TurnOffThread ： 属于具体\n */\npublic class TurnOffThread implements Runnable{\n     private Receiver receiver;\n    \n     public TurnOffThread(Receiver receiver) {\n     	this.receiver = receiver;\n     }\n     public void run() {\n     	receiver.turnOFF();\n     }\n}\n```\n\n```java\n/**\n * 测试类\n */\npublic class Demo {\n     public static void main(String[] args) {\n         Receiver receiver = new Receiver();\n         TurnOffThread turnOffThread = new TurnOffThread(receiver);\n         Thread thread = new Thread(turnOffThread);\n         thread.start();\n     }\n}\n```\n\n## 4.4 责任链模式\n\n### 4.4.1 概述\n\n在现实生活中，常常会出现这样的事例：一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。例如，公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这增加了难度。这样的例子还有很多，如找领导出差报销、生活中的“击鼓传花”游戏等。\n\n**定义：**\n\n又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。\n\n\n\n### 4.4.2 结构\n\n职责链模式主要包含以下角色:\n\n* 抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。\n* 具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。\n* 客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。\n\n\n\n### 4.4.3 案例实现\n\n一人想要借钱，有三个老板可以提供借钱，A老板最多借50元，B老板最多借钱100元，C老板最多借钱200元。\n\n> 代码\n>\n\n抽象老板类\n\n```java\npublic abstract class AbstractBoss {\n    protected static final int MONEY_50=50;\n    protected static final int MONEY_100=100;\n    protected static final int MONEY_200=200;\n\n    private int hasMoney;\n    private AbstractBoss nextBoss;\n\n    public AbstractBoss(int hasMoney) {\n        this.hasMoney = hasMoney;\n    }\n\n    public int getHasMoney() {\n        return hasMoney;\n    }\n\n    public void setAbstractBoss(AbstractBoss nextBoss) {\n        this.nextBoss = nextBoss;\n    }\n\n    //不允许子类重写，属于结构型模式中模板方法模式，process是骨架,抽象lend由子类实现。\n    public final void process(int needMoney){\n        if (needMoney<=this.hasMoney){\n            lend(needMoney);\n        }else if (null!=this.nextBoss){\n            this.nextBoss.process(needMoney);\n        }\n    }\n\n    protected abstract void lend(int needMoney);\n}\n```\n\n具体老板类\n\n```java\npublic class BossA extends AbstractBoss{\n    public BossA(int hasMoney) {\n        super(hasMoney);\n    }\n\n    @Override\n    protected void lend(int needMoney) {\n        System.out.print(\"A老板借出去\"+needMoney+\"元\");\n    }\n}\n\npublic class BossB extends AbstractBoss{\n    public BossB(int hasMoney) {\n        super(hasMoney);\n    }\n\n    @Override\n    protected void lend(int needMoney) {\n        System.out.print(\"B老板借出去\"+needMoney+\"元\");\n    }\n}\n\npublic class BossC extends AbstractBoss{\n    public BossC(int hasMoney) {\n        super(hasMoney);\n    }\n\n    @Override\n    protected void lend(int needMoney) {\n        System.out.print(\"C老板借出去\"+needMoney+\"元\");\n    }\n}\n```\n\n测试类\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        AbstractBoss bossA = new BossA(AbstractBoss.MONEY_50);\n        AbstractBoss bossB = new BossB(AbstractBoss.MONEY_100);\n        AbstractBoss bossC = new BossC(AbstractBoss.MONEY_200);\n\n        //职责链从低层向上引用！确保钱被最佳化处理\n        bossA.setAbstractBoss(bossB);\n        bossB.setAbstractBoss(bossC);\n\n        bossA.process(49);System.out.println(\"(over)\");\n        bossA.process(99);System.out.println(\"(over)\");\n        bossA.process(199);System.out.println(\"(over)\");\n        bossA.process(201);System.out.println(\"(over)\");\n\n    }\n}\nA老板借出去49元(over)\nB老板借出去99元(over)\nC老板借出去199元(over)\n(over)\n```\n\n## 4.5 观察者模式\n\n### 4.5.1 概述\n\n**定义：**\n\n又被称为发布-订阅（Publish/Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。\n\n\n\n### 4.5.2 结构\n\n在观察者模式中有如下角色：\n\n* Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。\n* ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。\n* Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。\n* ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。\n\n### 4.5.3 案例实现\n\n【例】微信公众号\n\n在使用微信公众号时，大家都会有这样的体验，当你关注的公众号中有新内容更新的话，它就会推送给关注公众号的微信用户端。我们使用观察者模式来模拟这样的场景，微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了程序猿这个公众号。\n\n类图如下：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d9bf7fee5021423b972cd645ea0d32f7.png#pic_center)\n\n\n代码如下：\n\n定义抽象观察者类，里面定义一个更新的方法\n\n```java\npublic interface Observer {\n    void update(String message);\n}\n```\n\n定义具体观察者类，微信用户是观察者，里面实现了更新的方法\n\n```java\npublic class WeixinUser implements Observer {\n    // 微信用户名\n    private String name;\n\n    public WeixinUser(String name) {\n        this.name = name;\n    }\n    @Override\n    public void update(String message) {\n        System.out.println(name + \"-\" + message);\n    }\n}\n```\n\n定义抽象主题类，提供了attach、detach、notify三个方法\n\n```java\npublic interface Subject {\n    //增加订阅者\n    public void attach(Observer observer);\n\n    //删除订阅者\n    public void detach(Observer observer);\n    \n    //通知订阅者更新消息\n    public void notify(String message);\n}\n\n```\n\n微信公众号是具体主题（具体被观察者），里面存储了订阅该公众号的微信用户，并实现了抽象主题中的方法\n\n```java\npublic class SubscriptionSubject implements Subject {\n    //储存订阅公众号的微信用户\n    private List<Observer> weixinUserlist = new ArrayList<Observer>();\n\n    @Override\n    public void attach(Observer observer) {\n        weixinUserlist.add(observer);\n    }\n\n    @Override\n    public void detach(Observer observer) {\n        weixinUserlist.remove(observer);\n    }\n\n    @Override\n    public void notify(String message) {\n        for (Observer observer : weixinUserlist) {\n            observer.update(message);\n        }\n    }\n}\n```\n\n客户端程序\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        SubscriptionSubject mSubscriptionSubject=new SubscriptionSubject();\n        //创建微信用户\n        WeixinUser user1=new WeixinUser(\"孙悟空\");\n        WeixinUser user2=new WeixinUser(\"猪悟能\");\n        WeixinUser user3=new WeixinUser(\"沙悟净\");\n        //订阅公众号\n        mSubscriptionSubject.attach(user1);\n        mSubscriptionSubject.attach(user2);\n        mSubscriptionSubject.attach(user3);\n        //公众号更新发出消息给订阅的微信用户\n        mSubscriptionSubject.notify(\"传智黑马的专栏更新了\");\n    }\n}\n\n```\n\n### 4.5.4 使用场景\n\n* 对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。\n* 当一个抽象模型有两个方面，其中一个方面依赖于另一方面时。\n\n### 4.5.5 JDK实现\n\n在 Java 中，通过 java.util.Observable 类和 java.util.Observer 接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。\n\n**1，Observable类**\n\nObservable 类是抽象目标类（被观察者），它有一个 Vector 集合成员变量，用于保存所有要通知的观察者对象，下面来介绍它最重要的 3 个方法。\n\n* void addObserver(Observer o) 方法：用于将新的观察者对象添加到集合中。\n\n* void notifyObservers(Object arg) 方法：调用集合中的所有观察者对象的 update方法，通知它们数据发生改变。通常越晚加入集合的观察者越先得到通知。\n\n* void setChange() 方法：用来设置一个 boolean 类型的内部标志，注明目标对象发生了变化。当它为true时，notifyObservers() 才会通知观察者。\n\n**2，Observer 接口**\n\nObserver 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 update 方法，进行相应的工作。\n\n【例子】\n\n多个警察抓一个小偷。\n\n警察\n\n```java\n//实现了这个接口 只是单单说明了警察是观察者。update是回调函数。\npublic class Police implements Observer {\n    @Override\n    public void update(Observable o, Object arg) {\n        Thief o1 = (Thief) o;\n        System.out.println(\"成功抓获小偷：\"+o1.getName());\n    }\n}\n```\n\n小偷\n\n```java\n//小偷继承Observable表示是可以被观察的类。\npublic class Thief extends Observable {\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Thief() {\n        setChanged();\n    }\n\n    protected void steal(){\n        System.out.println(\"小偷正在偷东西！\");\n        notifyObservers();//底层遍历了所有观察者并逐个执行其update方法。\n    }\n\n}\n```\n\n测试类\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        Thief thief = new Thief();\n        Police police = new Police();\n\n        thief.setName(\"肥莫\");\n//        添加为小偷的观察者，才能使得警察的观察有作用，也就是update可以被调用了\n        thief.addObserver(police);\n\n        thief.steal();\n    }\n}\n```\n## 4.6 状态模式\n\n## 4.7 中介者模式\n\n## 4.8 迭代器模式\n\n## 4.9 访问者模式\n\n## 4.10 备忘录模式\n\n## 4.11 解释器模式\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n','<h1><a id=\"1__3\"></a>1. 类图概述</h1>\n<p>统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。</p>\n<p>UML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图。</p>\n<p>类图(Class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。</p>\n<h2><a id=\"12__10\"></a>1.2 类图的作用</h2>\n<ul>\n<li>在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解；</li>\n<li>类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。</li>\n</ul>\n<h2><a id=\"13__15\"></a>1.3 类图表示法</h2>\n<h3><a id=\"131__17\"></a>1.3.1 类的表示方式</h3>\n<p>在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name,age和address这3个属性，以及work()方法。</p>\n<p>属性/方法名称前加的加号和减号表示了这个属性/方法的可见性，UML类图中表示可见性的符号有三种：</p>\n<ul>\n<li>\n<p>+：表示public</p>\n</li>\n<li>\n<p>-：表示private</p>\n</li>\n<li>\n<p>#：表示protected</p>\n</li>\n</ul>\n<p>属性的完整表示方式是： <strong>可见性  名称 ：类型 [ = 缺省值]</strong></p>\n<p>方法的完整表示方式是： <strong>可见性  名称(参数列表) [ ： 返回类型]</strong></p>\n<blockquote>\n<p>注意：</p>\n<p>1，中括号中的内容表示是可选的</p>\n<p>2，也有将类型放在变量名前面，返回值类型放在方法名前面</p>\n</blockquote>\n<p><strong>举个栗子：</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/04fd7b0a2dd048adb179e927ba586dad.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>上图Demo类定义了三个方法：</p>\n<ul>\n<li>method()方法：修饰符为public，没有参数，没有返回值。</li>\n<li>method1()方法：修饰符为private，没有参数，返回值类型为String。</li>\n<li>method2()方法：修饰符为protected，接收两个参数，第一个参数类型为int，第二个参数类型为String，返回值类型是int。</li>\n</ul>\n<h3><a id=\"132__51\"></a>1.3.2 类与类之间关系的表示方式</h3>\n<h4><a id=\"1321__53\"></a>1.3.2.1 关联关系</h4>\n<p>关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。</p>\n<p>关联又可以分为单向关联，双向关联，自关联。</p>\n<p><strong>1，单向关联</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/d636bca3668743b08aea2ded7d8af0ff.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>在UML类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。</p>\n<p><strong>2，双向关联</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/fd2544a1ba7248fab799c931fa589a1d.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。</p>\n<p>在UML类图中，双向关联用一个不带箭头的直线表示。上图中在Customer类中维护一个List&lt;Product&gt;，表示一个顾客可以购买多个商品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。</p>\n<p><strong>3，自关联</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/6406fb400c2149a482547f3a6cbb21cb.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。</p>\n<h4><a id=\"1322__84\"></a>1.3.2.2 聚合关系</h4>\n<p>聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。</p>\n<p>聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。</p>\n<p>在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。下图所示是大学和教师的关系图：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/c17e7163c4da46c39c7564d9222f371f.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"1323__95\"></a>1.3.2.3 组合关系</h4>\n<p>组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。</p>\n<p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。</p>\n<p>在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。下图所示是头和嘴的关系图：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/0a9262e57101450d87e9295c8a7d78ab.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"1324__108\"></a>1.3.2.4 依赖关系</h4>\n<p>依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。</p>\n<p>在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是司机和汽车的关系图，司机驾驶汽车：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/ef2a51cf0d714b4e807e2d7145d32ebb.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"1325__117\"></a>1.3.2.5 继承关系</h4>\n<p>继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。</p>\n<p>在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下图所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/a3076e2833644fef8799a2f806cf0857.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h4><a id=\"1326__128\"></a>1.3.2.6 实现关系</h4>\n<p>实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p>\n<p>在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如图 9 所示。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/18c9100e673346a1ae755058457e8d06.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h1><a id=\"_141\"></a>常用设计模式</h1>\n<p><mark>创建者：单例、工厂</mark></p>\n<p><mark>结构型：代理、适配器、装饰者、外观</mark></p>\n<p><mark>行为型：策略、模板、职责链、观察者、发布与订阅</mark></p>\n<h1><a id=\"1__149\"></a>1. 软件设计原则</h1>\n<h2><a id=\"11__151\"></a>1.1 开闭原则</h2>\n<p><strong>对扩展开放，对改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。</p>\n<blockquote>\n<p>想要达到这样的效果，我们需要使用接口和抽象类。</p>\n</blockquote>\n<p>【例】<code>搜狗输入法</code> 的皮肤设计。</p>\n<p>分析：<code>搜狗输入法</code> 的皮肤是输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，也可以从网上下载新的皮肤。这些皮肤有共同的特点，可以为其定义一个抽象类（AbstractSkin），而每个具体的皮肤（DefaultSpecificSkin和HeimaSpecificSkin）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/c1d781a7e69949f58128646fb7d7fd03.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h2><a id=\"12__164\"></a>1.2 里氏代换原则</h2>\n<p>​	里氏代换原则：任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p>\n<pre><code>**子类可以扩展父类的功能，但不能改变父类原有的功能。** 也就是既不能重写父类的方法，也不能重载父类的方法。\n</code></pre>\n<p>【例】</p>\n<p>父类长方形</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.morris.pattern.lsp;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Rectangle</span> </span>{\n\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">int</span> width;\n\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">int</span> height;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Rectangle</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> width, <span class=\"hljs-keyword\">int</span> height)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.width = width;\n        <span class=\"hljs-keyword\">this</span>.height = height;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">calcArea</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> width * height;\n    }\n\n}\n</code></div></pre>\n<p>子类正方形</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.morris.pattern.lsp;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Square</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Rectangle</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Square</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> width, <span class=\"hljs-keyword\">int</span> height)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(width, height);\n    }\n    <span class=\"hljs-meta\">@Override</span> <span class=\"hljs-comment\">//重写了父类计算面积的方法</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">calcArea</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> width * width;\n    }\n\n}\n</code></div></pre>\n<p>测试类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.morris.pattern.lsp;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">App</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        Rectangle rectangle = <span class=\"hljs-keyword\">new</span> Rectangle(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>); <span class=\"hljs-comment\">//长方</span>\n        Rectangle rectangle = <span class=\"hljs-keyword\">new</span> Square(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>); <span class=\"hljs-comment\">//正方形</span>\n        System.out.println(rectangle.calcArea());\n    }\n\n}\n</code></div></pre>\n<p>如果把长方形类Rectangle替换为正方形类Square，那么求出的面积就不正确了，原因是继承的时候重写了父类的getArea方法。这是违背里氏替换原则的。</p>\n<h2><a id=\"13__231\"></a>1.3 依赖倒转原则</h2>\n<p>​		高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p>\n<blockquote>\n<p>个人认为跟开闭原则很像，都是要求面向接口 / 抽象编程。因为对接口编程时，很方便扩展，那么实现类修改了，只要接口不变，使用该接口的类也不需要变。<strong>面向接口编程就能满足两种原则了！</strong></p>\n</blockquote>\n<p>【例】</p>\n<p><strong>之前</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/f133ab2a16df47a6864f45b12f12829b.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<hr />\n<p><strong>之后</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/6dfc0e3ef527423ba7f9c4533a5b3923.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h2><a id=\"14__251\"></a>1.4 接口隔离原则</h2>\n<p>客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在<strong>最小的接口</strong>上。</p>\n<blockquote>\n<p>这里跟数据库的第一范式很相似，就是对于属性的粒度划分要刚刚好，要小到不能划分。</p>\n<p>就像人能拉屎拉尿，也不应该将这两个功能写在同一接口里面，应该分开接口来写，因为有些人是不能拉尿的。</p>\n</blockquote>\n<h2><a id=\"15__259\"></a>1.5 迪米特法则</h2>\n<p><strong>又叫最少知识原则。</strong></p>\n<p>其含义是：如果两个软件实体<strong>无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用</strong>。其目的是降低类之间的耦合度，提高模块的相对独立性。</p>\n<h2><a id=\"16__265\"></a>1.6 合成复用原则</h2>\n<p>合成复用原则是指：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p>\n<p>【例】汽车分类管理程序</p>\n<p>汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。类图如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/efce48a226014b559795ab6e48f879e6.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>从上面类图我们可以看到使用继承复用产生了很多子类，如果现在又有新的动力源或者新的颜色的话，就需要再定义新的类。我们试着将继承复用改为聚合复用看一下。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2d6f81f4cc6440339a8049951949b968.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h1><a id=\"2__281\"></a>2. 创建者模式</h1>\n<p>创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。</p>\n<p>这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。</p>\n<p>创建型模式分为：</p>\n<ul>\n<li>单例模式</li>\n<li>工厂方法模式</li>\n<li>抽象工程模式</li>\n<li>原型模式</li>\n<li>建造者模式</li>\n</ul>\n<h2><a id=\"21__295\"></a>2.1 单例设计模式</h2>\n<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>\n<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>\n<h3><a id=\"211__301\"></a>2.1.1 单例模式的结构</h3>\n<p>单例模式的主要有以下角色：</p>\n<ul>\n<li>单例类。只能创建一个实例的类</li>\n<li>访问类。使用单例类</li>\n</ul>\n<h3><a id=\"212__308\"></a>2.1.2 单例模式的实现</h3>\n<blockquote>\n<p>单例设计模式分类两种：</p>\n<p>​	饿汉式：类加载就会导致该单实例对象被创建</p>\n<p>​	懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p>\n</blockquote>\n<ol>\n<li>\n<p>饿汉式</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">/**\n * 饿汉式\n *      静态变量创建类的对象\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Singleton</span> </span>{\n    <span class=\"hljs-comment\">//私有构造方法</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">Singleton</span><span class=\"hljs-params\">()</span> </span>{}\n\n    <span class=\"hljs-comment\">//在成员位置创建该类的对象</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Singleton instance = <span class=\"hljs-keyword\">new</span> Singleton();\n\n    <span class=\"hljs-comment\">//对外提供静态方法获取该对象</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Singleton <span class=\"hljs-title\">getInstance</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> instance;\n    }\n}\n</code></div></pre>\n</li>\n<li>\n<p>懒汉式</p>\n<p>添加 <code>volatile</code> 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">/**\n * 双重检查方式\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Singleton</span> </span>{\n\n    <span class=\"hljs-comment\">//私有构造方法</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">Singleton</span><span class=\"hljs-params\">()</span> </span>{}\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">volatile</span> Singleton instance;\n\n   <span class=\"hljs-comment\">//对外提供静态方法获取该对象</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Singleton <span class=\"hljs-title\">getInstance</span><span class=\"hljs-params\">()</span> </span>{\n		<span class=\"hljs-comment\">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际</span>\n        <span class=\"hljs-keyword\">if</span>(instance == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">synchronized</span> (Singleton.class) {\n                <span class=\"hljs-comment\">//抢到锁之后再次判断是否为空</span>\n                <span class=\"hljs-keyword\">if</span>(instance == <span class=\"hljs-keyword\">null</span>) {\n                    instance = <span class=\"hljs-keyword\">new</span> Singleton();\n                }\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> instance;\n    }\n}\n</code></div></pre>\n</li>\n<li>\n<p>懒汉式-方式4（静态内部类方式）</p>\n<p>静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性/方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 <code>static</code> 修饰，保证只被实例化一次，并且严格保证实例化顺序。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">/**\n * 静态内部类方式\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Singleton</span> </span>{\n\n    <span class=\"hljs-comment\">//私有构造方法</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">Singleton</span><span class=\"hljs-params\">()</span> </span>{}\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SingletonHolder</span> </span>{\n        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Singleton INSTANCE = <span class=\"hljs-keyword\">new</span> Singleton();\n    }\n\n    <span class=\"hljs-comment\">//对外提供静态方法获取该对象</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Singleton <span class=\"hljs-title\">getInstance</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> SingletonHolder.INSTANCE;\n    }\n}\n</code></div></pre>\n</li>\n<li>\n<p>枚举方式</p>\n<p>枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">/**\n * 枚举方式\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">enum</span> Singleton {\n    INSTANCE;\n}\n</code></div></pre>\n</li>\n</ol>\n<h3><a id=\"213__405\"></a>2.1.3 存在的问题及解决</h3>\n<blockquote>\n<p><em>反序列化破坏单例的解决方式</em></p>\n</blockquote>\n<p>​	在Singleton类中添加<code>readResolve()</code>方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Singleton</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Serializable</span> </span>{\n\n    <span class=\"hljs-comment\">//私有构造方法</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">Singleton</span><span class=\"hljs-params\">()</span> </span>{}\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SingletonHolder</span> </span>{\n        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Singleton INSTANCE = <span class=\"hljs-keyword\">new</span> Singleton();\n    }\n\n    <span class=\"hljs-comment\">//对外提供静态方法获取该对象</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Singleton <span class=\"hljs-title\">getInstance</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> SingletonHolder.INSTANCE;\n    }\n    \n    <span class=\"hljs-comment\">/**\n     * 下面是为了解决序列化反序列化破解单例模式\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> Object <span class=\"hljs-title\">readResolve</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> SingletonHolder.INSTANCE;\n    }\n}\n</code></div></pre>\n<blockquote>\n<p>反射方式破解单例的解决方法</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Singleton</span> </span>{\n\n    <span class=\"hljs-comment\">//私有构造方法</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">Singleton</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">/*\n           反射破解单例模式需要添加的代码\n        */</span>\n        <span class=\"hljs-keyword\">if</span>(instance != <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RuntimeException();\n        }\n    }\n    \n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">volatile</span> Singleton instance;\n\n    <span class=\"hljs-comment\">//对外提供静态方法获取该对象</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Singleton <span class=\"hljs-title\">getInstance</span><span class=\"hljs-params\">()</span> </span>{\n\n        <span class=\"hljs-keyword\">if</span>(instance != <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">return</span> instance;\n        }\n\n        <span class=\"hljs-keyword\">synchronized</span> (Singleton.class) {\n            <span class=\"hljs-keyword\">if</span>(instance != <span class=\"hljs-keyword\">null</span>) {\n                <span class=\"hljs-keyword\">return</span> instance;\n            }\n            instance = <span class=\"hljs-keyword\">new</span> Singleton();\n            <span class=\"hljs-keyword\">return</span> instance;\n        }\n    }\n}\n</code></div></pre>\n<h2><a id=\"22__472\"></a>2.2 工厂模式</h2>\n<p>在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。</p>\n<p>如果<strong>我们使用工厂来生产对象</strong>，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：<strong>解耦</strong>。</p>\n<h3><a id=\"221__478\"></a>2.2.1 简单工厂模式</h3>\n<p>简单工厂不是一种设计模式，反而比较像是一种编程习惯。</p>\n<blockquote>\n<p>结构</p>\n</blockquote>\n<p>简单工厂包含如下角色：</p>\n<ul>\n<li>抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。</li>\n<li>具体产品 ：实现或者继承抽象产品的子类</li>\n<li>具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/71636e5b69354341b5cc24642eec09ec.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<blockquote>\n<p>优缺点</p>\n</blockquote>\n<p><strong>优点：</strong></p>\n<p>封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。</p>\n<p><strong>缺点：</strong></p>\n<p>增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。</p>\n<blockquote>\n<p>扩展</p>\n</blockquote>\n<p><strong>静态工厂</strong></p>\n<p>在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是23种设计模式中的。代码如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SimpleCoffeeFactory</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Coffee <span class=\"hljs-title\">createCoffee</span><span class=\"hljs-params\">(String type)</span> </span>{\n        Coffee coffee = <span class=\"hljs-keyword\">null</span>;\n        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-string\">\"americano\"</span>.equals(type)) {\n            coffee = <span class=\"hljs-keyword\">new</span> AmericanoCoffee();\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-string\">\"latte\"</span>.equals(type)) {\n            coffee = <span class=\"hljs-keyword\">new</span> LatteCoffee();\n        }\n        <span class=\"hljs-keyword\">return</span> coffe;\n    }\n}\n</code></div></pre>\n<h3><a id=\"222__524\"></a>2.2.2 工厂方法模式</h3>\n<blockquote>\n<p>概念</p>\n</blockquote>\n<p>定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。</p>\n<blockquote>\n<p>结构</p>\n</blockquote>\n<p>工厂方法模式的主要角色：</p>\n<ul>\n<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</li>\n<li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>\n<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li>\n<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/d7bc2712a78a4a32857f74e2d7e6d791.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>代码如下：</p>\n<p>抽象工厂：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">CoffeeFactory</span> </span>{\n\n    <span class=\"hljs-function\">Coffee <span class=\"hljs-title\">createCoffee</span><span class=\"hljs-params\">()</span></span>;\n}\n</code></div></pre>\n<p>具体工厂：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LatteCoffeeFactory</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">CoffeeFactory</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Coffee <span class=\"hljs-title\">createCoffee</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> LatteCoffee();\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AmericanCoffeeFactory</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">CoffeeFactory</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Coffee <span class=\"hljs-title\">createCoffee</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> AmericanCoffee();\n    }\n}\n</code></div></pre>\n<p>咖啡店类：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CoffeeStore</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> CoffeeFactory factory;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">CoffeeStore</span><span class=\"hljs-params\">(CoffeeFactory factory)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.factory = factory;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Coffee <span class=\"hljs-title\">orderCoffee</span><span class=\"hljs-params\">(String type)</span> </span>{\n        Coffee coffee = factory.createCoffee();\n        coffee.addMilk();\n        coffee.addsugar();\n        <span class=\"hljs-keyword\">return</span> coffee;\n    }\n}\n</code></div></pre>\n<p>从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点。</p>\n<p>工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。</p>\n<h3><a id=\"223__595\"></a>2.2.3 抽象工厂模式</h3>\n<p>前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、传智播客只培养计算机软件专业的学生等。</p>\n<p>这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。</p>\n<p>本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，下图所示横轴是产品等级，也就是同一类产品；纵轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/669b5f6bcec94e5f8e2b8cc61bd79eba.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>比如：咖啡分美式英式等为同一等级。咖啡、奶茶、果汁为同一族，而应把他们抽象成同一产品族：饮料工厂。</p>\n<blockquote>\n<p>概念</p>\n</blockquote>\n<p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p>\n<blockquote>\n<p>结构</p>\n</blockquote>\n<p>抽象工厂模式的主要角色如下：</p>\n<ul>\n<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</li>\n<li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li>\n<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li>\n<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。</li>\n</ul>\n<blockquote>\n<p>实现</p>\n</blockquote>\n<p>现咖啡店业务发生改变，不仅要生产咖啡还要生产甜点，如提拉米苏、抹茶慕斯等，要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。其中拿铁咖啡、美式咖啡是一个产品等级，都是咖啡；提拉米苏、抹茶慕斯也是一个产品等级；拿铁咖啡和提拉米苏是同一产品族（也就是都属于意大利风味），美式咖啡和抹茶慕斯是同一产品族（也就是都属于美式风味）。所以这个案例可以使用抽象工厂模式实现。类图如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d3354cf0800b4dbd8a21065e6a214c13.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<blockquote>\n<p>优缺点</p>\n</blockquote>\n<p><strong>优点：</strong></p>\n<p>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p>\n<p><strong>缺点：</strong></p>\n<p>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p>\n<h3><a id=\"224__638\"></a>2.2.4 模式扩展</h3>\n<p><strong>简单工厂+配置文件解除耦合</strong></p>\n<p>可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。</p>\n<p>第一步：定义配置文件</p>\n<p>为了演示方便，我们使用properties文件作为配置文件，名称为bean.properties</p>\n<pre><code class=\"lang-properties\">american=com.itheima.pattern.factory.config_factory.AmericanCoffee\nlatte=com.itheima.pattern.factory.config_factory.LatteCoffee\n</code></pre>\n<p>第二步：改进工厂类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CoffeeFactory</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Map&lt;String,Coffee&gt; map = <span class=\"hljs-keyword\">new</span> HashMap();\n\n    <span class=\"hljs-keyword\">static</span> {\n        Properties p = <span class=\"hljs-keyword\">new</span> Properties();\n        InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream(<span class=\"hljs-string\">\"bean.properties\"</span>);\n        <span class=\"hljs-keyword\">try</span> {\n            p.load(is);\n            <span class=\"hljs-comment\">//遍历Properties集合对象</span>\n            Set&lt;Object&gt; keys = p.keySet();\n            <span class=\"hljs-keyword\">for</span> (Object key : keys) {\n                <span class=\"hljs-comment\">//根据键获取值（全类名）</span>\n                String className = p.getProperty((String) key);\n                <span class=\"hljs-comment\">//获取字节码对象</span>\n                Class clazz = Class.forName(className);\n                Coffee obj = (Coffee) clazz.newInstance();\n                map.put((String)key,obj);\n            }\n        } <span class=\"hljs-keyword\">catch</span> (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Coffee <span class=\"hljs-title\">createCoffee</span><span class=\"hljs-params\">(String name)</span> </span>{\n\n        <span class=\"hljs-keyword\">return</span> map.get(name);\n    }\n}\n</code></div></pre>\n<p>静态成员变量用来存储创建的对象（键存储的是名称，值存储的是对应的对象），而读取配置文件以及创建对象写在静态代码块中，目的就是只需要执行一次。</p>\n<h2><a id=\"23__689\"></a>2.3 原型模式</h2>\n<blockquote>\n<p>概述</p>\n</blockquote>\n<p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。</p>\n<blockquote>\n<p>结构</p>\n</blockquote>\n<p>原型模式包含如下角色：</p>\n<ul>\n<li>抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。</li>\n<li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li>\n<li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li>\n</ul>\n<blockquote>\n<p>实现</p>\n</blockquote>\n<p>原型模式的克隆分为浅克隆和深克隆。</p>\n<ul>\n<li>\n<p>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</p>\n<p><mark>克隆后的对象本身地址改变，但是克隆后的对象的成员变量中引用类型的数据的地址仍然与原型对象一致</mark></p>\n</li>\n<li>\n<p>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</p>\n<p><mark>里里外外就是一个新对象</mark></p>\n</li>\n</ul>\n<p>Java中的Object类中提供了 <code>clone()</code> 方法来实现浅克隆。 Cloneable 接口是上面的类图中的抽象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。</p>\n<blockquote>\n<p>浅克隆</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Realizetype</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Cloneable</span> </span>{ <span class=\"hljs-comment\">//实现浅克隆接口</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Realizetype</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"具体的原型对象创建完成！\"</span>);<span class=\"hljs-comment\">//手动new对象用的是构造器，但是clone方法不是用的构造器</span>\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> Realizetype <span class=\"hljs-title\">clone</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> CloneNotSupportedException </span>{\n        System.out.println(<span class=\"hljs-string\">\"具体原型复制成功！\"</span>);\n        <span class=\"hljs-keyword\">return</span> (Realizetype) <span class=\"hljs-keyword\">super</span>.clone();\n    }\n}\n</code></div></pre>\n<blockquote>\n<p>深克隆</p>\n</blockquote>\n<p>通过序列化与反序列化方式完成深克隆，注意：<mark>自定义对象需要实现序列化接口</mark></p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CitationTest1</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        Citation c1 = <span class=\"hljs-keyword\">new</span> Citation();\n        Student stu = <span class=\"hljs-keyword\">new</span> Student(<span class=\"hljs-string\">\"张三\"</span>, <span class=\"hljs-string\">\"西安\"</span>);\n        c1.setStu(stu);\n\n        <span class=\"hljs-comment\">//创建对象输出流对象</span>\n        ObjectOutputStream oos = <span class=\"hljs-keyword\">new</span> ObjectOutputStream(<span class=\"hljs-keyword\">new</span> FileOutputStream(<span class=\"hljs-string\">\"C:\\\\Users\\\\Think\\\\Desktop\\\\b.txt\"</span>));\n        <span class=\"hljs-comment\">//将c1对象写出到文件中</span>\n        oos.writeObject(c1);\n        oos.close();\n\n        <span class=\"hljs-comment\">//创建对象出入流对象</span>\n        ObjectInputStream ois = <span class=\"hljs-keyword\">new</span> ObjectInputStream(<span class=\"hljs-keyword\">new</span> FileInputStream(<span class=\"hljs-string\">\"C:\\\\Users\\\\Think\\\\Desktop\\\\b.txt\"</span>));\n        <span class=\"hljs-comment\">//读取对象</span>\n        Citation c2 = (Citation) ois.readObject();\n        <span class=\"hljs-comment\">//获取c2奖状所属学生对象</span>\n        Student stu1 = c2.getStu();\n        stu1.setName(<span class=\"hljs-string\">\"李四\"</span>);\n\n        <span class=\"hljs-comment\">//判断stu对象和stu1对象是否是同一个对象</span>\n        System.out.println(<span class=\"hljs-string\">\"stu和stu1是同一个对象？\"</span> + (stu == stu1));\n\n        c1.show();\n        c2.show();\n    }\n}\n</code></div></pre>\n<h1><a id=\"3__770\"></a>3. 结构型模式</h1>\n<p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</p>\n<p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p>\n<p>结构型模式分为以下 7 种：</p>\n<ul>\n<li>代理模式</li>\n<li>适配器模式</li>\n<li>装饰者模式</li>\n<li>桥接模式</li>\n<li>外观模式</li>\n<li>组合模式</li>\n<li>享元模式</li>\n</ul>\n<h2><a id=\"31__788\"></a>3.1 代理模式</h2>\n<h3><a id=\"311__790\"></a>3.1.1 概述</h3>\n<p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>\n<p>Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。</p>\n<h3><a id=\"312__796\"></a>3.1.2 结构</h3>\n<p>代理（Proxy）模式分为三种角色：</p>\n<ul>\n<li>抽象主题（Subject）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>\n<li>真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>\n<li>代理（Proxy）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>\n</ul>\n<h3><a id=\"313__804\"></a>3.1.3 静态代理</h3>\n<p>【例】火车站卖票</p>\n<p>如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。类图如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/5320fe83001649cd9a0067e36c60a1a5.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>代码如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//卖票接口</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">SellTickets</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sell</span><span class=\"hljs-params\">()</span></span>;\n}\n\n<span class=\"hljs-comment\">//火车站  火车站具有卖票功能，所以需要实现SellTickets接口</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TrainStation</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">SellTickets</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sell</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"火车站卖票\"</span>);\n    }\n}\n\n<span class=\"hljs-comment\">//代售点</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ProxyPoint</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">SellTickets</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> TrainStation station = <span class=\"hljs-keyword\">new</span> TrainStation();\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sell</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"代理点收取一些服务费用\"</span>);\n        station.sell();\n    }\n}\n\n<span class=\"hljs-comment\">//测试类</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Client</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        ProxyPoint pp = <span class=\"hljs-keyword\">new</span> ProxyPoint();\n        pp.sell();\n    }\n}\n</code></div></pre>\n<p>从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介。同时也对sell方法进行了增强（代理点收取一些服务费用）。</p>\n<h3><a id=\"314_JDK_851\"></a>3.1.4 JDK动态代理</h3>\n<p>代码如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//卖票接口</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">SellTickets</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sell</span><span class=\"hljs-params\">()</span></span>;\n}\n\n<span class=\"hljs-comment\">//火车站  火车站具有卖票功能，所以需要实现SellTickets接口</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TrainStation</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">SellTickets</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sell</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"火车站卖票\"</span>);\n    }\n}\n\n<span class=\"hljs-comment\">//代理工厂，用来创建代理对象</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ProxyFactory</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> TrainStation station = <span class=\"hljs-keyword\">new</span> TrainStation();\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> SellTickets <span class=\"hljs-title\">getProxyObject</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">//使用Proxy获取代理对象</span>\n        <span class=\"hljs-comment\">/*\n            newProxyInstance()方法参数说明：\n                ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可\n                Class&lt;?&gt;[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口\n                InvocationHandler h ： 代理对象的调用处理程序\n         */</span>\n        SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),\n                station.getClass().getInterfaces(),\n                <span class=\"hljs-keyword\">new</span> InvocationHandler() {\n                    <span class=\"hljs-comment\">/*\n                        InvocationHandler中invoke方法参数说明：\n                            proxy ： 代理对象\n                            method ： 对应于在代理对象上调用的接口方法的 Method 实例\n                            args ： 代理对象调用接口方法时传递的实际参数\n                     */</span>\n                    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">invoke</span><span class=\"hljs-params\">(Object proxy, Method method, Object[] args)</span> <span class=\"hljs-keyword\">throws</span> Throwable </span>{\n\n                        System.out.println(<span class=\"hljs-string\">\"代理点收取一些服务费用(JDK动态代理方式)\"</span>);\n                        <span class=\"hljs-comment\">//执行真实对象</span>\n                        Object result = method.invoke(station, args);\n                        <span class=\"hljs-keyword\">return</span> result;\n                    }\n                });\n        <span class=\"hljs-keyword\">return</span> sellTickets;\n    }\n}\n\n<span class=\"hljs-comment\">//测试类</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Client</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        <span class=\"hljs-comment\">//获取代理对象</span>\n        ProxyFactory factory = <span class=\"hljs-keyword\">new</span> ProxyFactory();\n        \n        SellTickets proxyObject = factory.getProxyObject();\n        proxyObject.sell();\n    }\n}\n</code></div></pre>\n<p>执行流程如下：</p>\n<ol>\n<li>在测试类中通过代理对象调用sell()方法</li>\n<li>根据多态的特性，执行的是代理类（$Proxy0）中的sell()方法</li>\n<li>代理类（$Proxy0）中的sell()方法中又调用了InvocationHandler接口的子实现类对象的invoke方法</li>\n<li>invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法</li>\n</ol>\n<h3><a id=\"315_CGLIB_922\"></a>3.1.5 CGLIB动态代理</h3>\n<p>同样是上面的案例，我们再次使用CGLIB代理实现。</p>\n<p>如果没有定义SellTickets接口，只定义了TrainStation(火车站类)。很显然JDK代理是无法使用了，因为JDK动态代理要求必须定义接口，对接口进行代理。</p>\n<p>CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。</p>\n<p>CGLIB是第三方提供的包，所以需要引入jar包的坐标：</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>cglib<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>cglib<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.2.2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<p>代码如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//火车站</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TrainStation</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sell</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"火车站卖票\"</span>);\n    }\n}\n\n<span class=\"hljs-comment\">//代理工厂</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ProxyFactory</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">MethodInterceptor</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> TrainStation target = <span class=\"hljs-keyword\">new</span> TrainStation();\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> TrainStation <span class=\"hljs-title\">getProxyObject</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">//创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数</span>\n        Enhancer enhancer =<span class=\"hljs-keyword\">new</span> Enhancer();\n        <span class=\"hljs-comment\">//设置父类的字节码对象</span>\n        enhancer.setSuperclass(target.getClass());\n        <span class=\"hljs-comment\">//设置回调函数</span>\n        enhancer.setCallback(<span class=\"hljs-keyword\">this</span>);\n        <span class=\"hljs-comment\">//创建代理对象</span>\n        TrainStation obj = (TrainStation) enhancer.create();\n        <span class=\"hljs-keyword\">return</span> obj;\n    }\n\n    <span class=\"hljs-comment\">/*\n        intercept方法参数说明：\n            o ： 代理对象\n            method ： 真实对象中的方法的Method实例\n            args ： 实际参数\n            methodProxy ：代理对象中的方法的method实例\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> TrainStation <span class=\"hljs-title\">intercept</span><span class=\"hljs-params\">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class=\"hljs-keyword\">throws</span> Throwable </span>{\n        System.out.println(<span class=\"hljs-string\">\"代理点收取一些服务费用(CGLIB动态代理方式)\"</span>);\n        TrainStation result = (TrainStation) methodProxy.invokeSuper(o, args);\n        <span class=\"hljs-keyword\">return</span> result;\n    }\n}\n\n<span class=\"hljs-comment\">//测试类</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Client</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        <span class=\"hljs-comment\">//创建代理工厂对象</span>\n        ProxyFactory factory = <span class=\"hljs-keyword\">new</span> ProxyFactory();\n        <span class=\"hljs-comment\">//获取代理对象</span>\n        TrainStation proxyObject = factory.getProxyObject();\n\n        proxyObject.sell();\n    }\n}\n</code></div></pre>\n<h3><a id=\"316__995\"></a>3.1.6 三种代理的对比</h3>\n<ul>\n<li>\n<p>jdk代理和CGLIB代理</p>\n<p>使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。</p>\n<p>在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理。</p>\n</li>\n<li>\n<p>动态代理和静态代理</p>\n<p>动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。</p>\n<p>如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题</p>\n</li>\n</ul>\n<h3><a id=\"317__1011\"></a>3.1.7 优缺点</h3>\n<p><strong>优点：</strong></p>\n<ul>\n<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li>\n<li>代理对象可以扩展目标对象的功能；</li>\n<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>增加了系统的复杂度；</li>\n</ul>\n<h2><a id=\"32__1023\"></a>3.2 适配器模式</h2>\n<h3><a id=\"321__1025\"></a>3.2.1 概述</h3>\n<p>如果去欧洲国家去旅游的话，他们的插座如下图最左边，是欧洲标准。而我们使用的插头如下图最右边的。因此我们的笔记本电脑，手机在当地不能直接充电。所以就需要一个插座转换器，转换器第1面插入当地的插座，第2面供我们充电，这样使得我们的插头在当地能使用。生活中这样的例子很多，手机充电器（将220v转换为5v的电压），读卡器等，其实就是使用到了适配器模式。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/b59606ae4a414f0382d89c3e819d28b2.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>定义：</strong></p>\n<p>​	将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p>\n<p>​	适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p>\n<h3><a id=\"322__1038\"></a>3.2.2 结构</h3>\n<p>适配器模式（Adapter）包含以下主要角色：</p>\n<ul>\n<li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li>\n<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>\n<li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li>\n</ul>\n<blockquote>\n<p>适配器模式分为类适配器与对象适配器，对象适配器跟广泛一些。</p>\n</blockquote>\n<h3><a id=\"323__1049\"></a>3.2.3 对象适配器模式</h3>\n<p>我们有一个 <em>NewMediaPlayer</em> 接口和一个实现了 <em>NewMediaPlayer</em> 接口的实体类 <em>NewMediaPlayerImpl</em>。默认情况下，NewMediaPlayerImpl可以播放 mp3 格式的音频文件。</p>\n<p>我们还有另一个接口 <em>AdvancedMediaPlayer</em> 和实现了 <em>AdvancedMediaPlayer</em> 接口的实体类。该类可以播放 avi和 mp4 格式的文件。</p>\n<p>我们想要让 NewMediaPlayerImpl播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 <em>NewMediaPlayer</em>接口的适配器类 <em>MediaAdapter</em>，并使用 <em>AdvancedMediaPlayer</em> 对象来播放所需的格式。</p>\n<blockquote>\n<p>类图</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/a4dacadcc9dc4590a54d26ce24c1131f.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<blockquote>\n<p>代码</p>\n</blockquote>\n<ol>\n<li>AdvanceMediaPlayer接口代码</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">AdvanceMediaPlayer</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">playMp4</span><span class=\"hljs-params\">(String filename)</span></span>;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">playAvi</span><span class=\"hljs-params\">(String filename)</span></span>;\n}\n</code></div></pre>\n<ol start=\"2\">\n<li>实现AdvanceMediaPlayer接口的类AdvanceMediaPlayerImpl</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AdvanceMediaPlayerImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">AdvanceMediaPlayer</span> </span>{\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">playMp4</span><span class=\"hljs-params\">(String filename)</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"原生播放器播放mp4:\"</span>+filename);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">playAvi</span><span class=\"hljs-params\">(String filename)</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"原生播放器播放Avi:\"</span>+filename);\n    }\n}\n</code></div></pre>\n<ol start=\"3\">\n<li>NewMediaPlayer接口</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">NewMediaPlayer</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">playMp3</span><span class=\"hljs-params\">(String filename)</span></span>;\n}\n</code></div></pre>\n<ol start=\"4\">\n<li>适配器类MediaAdapter</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MediaAdapter</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">NewMediaPlayer</span> </span>{\n<span class=\"hljs-comment\">//    适配器，是为了新播放器能够使用已经有的播放器（MP4，avi），所以使用者只是希望调用旧的播放器来播放</span>\n<span class=\"hljs-comment\">//    因此，使用者只管在适配器中调用新播放器的接口的方法，但适配器实际用的是就播放器，但使用者不关心。</span>\n<span class=\"hljs-comment\">//    为了不混乱，规定某个对象被扩展功能，其则是新播放器，需要为其适配器</span>\n    AdvanceMediaPlayer advanceMediaPlayer;\n\n    <span class=\"hljs-comment\">/**\n     * 注意，这里的方法名有mp3，只是给使用者看的，\n     * 内部透明，但是作为适配器，\n     * 内部实际上调用的是advance播放器接口\n     *\n     * <span class=\"hljs-doctag\">@param</span> filename\n     */</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">playMp3</span><span class=\"hljs-params\">(String filename)</span> </span>{\n        advanceMediaPlayer = <span class=\"hljs-keyword\">new</span> AdvanceMediaPlayerImpl();\n        <span class=\"hljs-keyword\">if</span> (filename.indexOf(<span class=\"hljs-string\">\"mp4\"</span>) &gt; <span class=\"hljs-number\">0</span>) {\n            System.out.print(<span class=\"hljs-string\">\"适配器接手==&gt;\"</span>);\n            advanceMediaPlayer.playMp4(filename);\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (filename.indexOf(<span class=\"hljs-string\">\"avi\"</span>) &gt; <span class=\"hljs-number\">0</span>) {\n            System.out.print(<span class=\"hljs-string\">\"适配器接手==&gt;\"</span>);\n            advanceMediaPlayer.playAvi(filename);\n        }\n    }\n</code></div></pre>\n<ol start=\"5\">\n<li>NewMediaPlayer接口实现类NewMediaPlayerImpl</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NewMediaPlayerImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">NewMediaPlayer</span> </span>{\n    <span class=\"hljs-keyword\">private</span> MediaAdapter mediaAdapter;\n\n    <span class=\"hljs-comment\">/**\n     * 如果是mp3格式，对象本身可以播放，\n     * 但如果是mp4/avi则不支持，\n     * 需要调用适配器中的方法来播放其他格式\n     *\n     * <span class=\"hljs-doctag\">@param</span> filename\n     */</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">playMp3</span><span class=\"hljs-params\">(String filename)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (filename.indexOf(<span class=\"hljs-string\">\"mp3\"</span>) &gt; <span class=\"hljs-number\">0</span>) {\n<span class=\"hljs-comment\">//            对象本身支持mp3</span>\n            System.out.println(<span class=\"hljs-string\">\"新的播放器播放mp3:\"</span> + filename);\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (filename.indexOf(<span class=\"hljs-string\">\"mp4\"</span>) &gt; <span class=\"hljs-number\">0</span> || filename.indexOf(<span class=\"hljs-string\">\"avi\"</span>) &gt; <span class=\"hljs-number\">0</span>) {\n<span class=\"hljs-comment\">//            对象不支持，调用适配器api</span>\n            mediaAdapter = <span class=\"hljs-keyword\">new</span> MediaAdapter();\n            mediaAdapter.playMp3(filename);\n        }\n    }\n\n}\n</code></div></pre>\n<ol start=\"6\">\n<li>测试类</li>\n</ol>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        NewMediaPlayer newMediaPlayer = <span class=\"hljs-keyword\">new</span> NewMediaPlayerImpl();\n        newMediaPlayer.playMp3(<span class=\"hljs-string\">\"苍井空.mp3\"</span>);\n        newMediaPlayer.playMp3(<span class=\"hljs-string\">\"苍井空.mp4\"</span>);\n        newMediaPlayer.playMp3(<span class=\"hljs-string\">\"苍井空.avi\"</span>);\n\n    }\n}\n</code></div></pre>\n<ol start=\"7\">\n<li>结果</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/e56fe80d00ac4b9dbadd13617828c47b.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h2><a id=\"33__1175\"></a>3.3 装饰者模式***</h2>\n<h3><a id=\"331__1177\"></a>3.3.1 结构</h3>\n<p>装饰（Decorator）模式中的角色：</p>\n<ul>\n<li>抽象构件（Component）角色 ：定义一个抽象接口以规范准备接收附加责任的对象。</li>\n<li>具体构件（Concrete  Component）角色 ：实现抽象构件，通过装饰角色为其添加一些职责。</li>\n<li>抽象装饰（Decorator）角色 ： <mark>继承或实现抽象构件，并包含具体构件的实例</mark>，可以通过其子类扩展具体构件的功能。<mark>妙处所在</mark></li>\n<li>具体装饰（ConcreteDecorator）角色 ：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li>\n</ul>\n<h3><a id=\"332__1186\"></a>3.3.2 案例</h3>\n<p>快餐+配菜。快餐有米饭、面条，配菜有鸡蛋、培根</p>\n<p><img src=\"https://img-blog.csdnimg.cn/c7f9a7b4f78847e6b62a2eaee725d8c6.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<blockquote>\n<p>代码</p>\n</blockquote>\n<p>快餐抽象类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FastFood</span> </span>{\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">float</span> price;\n    <span class=\"hljs-keyword\">private</span> String Description;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">FastFood</span><span class=\"hljs-params\">()</span> </span>{\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">FastFood</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> price, String description)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.price = price;\n        Description = description;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">float</span> <span class=\"hljs-title\">getPrice</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> price;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setPrice</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> price)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.price = price;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">getDescription</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> Description;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setDescription</span><span class=\"hljs-params\">(String description)</span> </span>{\n        Description = description;\n    }\n}\n</code></div></pre>\n<p>快餐实现类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//炒饭</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FriedRice</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">FastFood</span></span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">FriedRice</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">\"炒饭\"</span>);\n    }\n}\n<span class=\"hljs-comment\">//炒面</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FriedNoodles</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">FastFood</span></span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">FriedNoodles</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> price, String description)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(<span class=\"hljs-number\">20</span>, <span class=\"hljs-string\">\"炒面\"</span>);\n    }\n}\n</code></div></pre>\n<p>装饰者抽象类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">/**\n * 装饰者本身既要继承/实现快餐类，并且要聚合被快餐类！\n * 因为鸡蛋培根都是装饰者的子类，该鸡蛋培根的子类是给快餐装饰的，所以鸡蛋培根快餐属于同一族，因此装饰者要继承快餐类，这样子鸡蛋培根就跟快餐同一族，\n * 拥有相同的属性，这样才能凑合。\n * 对于装饰者本身就是属于鸡蛋、培根，但是装饰者的字段是快餐\n *\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Garnish</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">FastFood</span></span>{\n    <span class=\"hljs-keyword\">private</span> FastFood fastFood;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> FastFood <span class=\"hljs-title\">getFastFood</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> fastFood;\n    }\n\n<span class=\"hljs-comment\">//    给子类实现，实例化为鸡蛋、培根，这样装饰者本身是鸡蛋、培根。而FastFood是本来就有的快餐，赋值给装饰者字段</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Garnish</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> price, String description, FastFood fastFood)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(price, description);\n        <span class=\"hljs-keyword\">this</span>.fastFood = fastFood;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">float</span> <span class=\"hljs-title\">cost</span><span class=\"hljs-params\">()</span></span>;\n\n}\n</code></div></pre>\n<p>装饰者的子类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//Garnish实现了FastFood所以才有价格，描述的属性，getPrice只是获取鸡蛋的价格，注意继承类，只是继承类的字段，字段的具体值由子类决定，所以说为什么这里的价格只是鸡蛋的价格。</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Egg</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Garnish</span></span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Egg</span><span class=\"hljs-params\">(FastFood fastFood)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">\"鸡蛋\"</span>, fastFood);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">float</span> <span class=\"hljs-title\">cost</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> getPrice()+ getFastFood().getPrice();\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">getDescription</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">super</span>.getDescription()+getFastFood().getDescription();\n    }\n}\n</code></div></pre>\n<p>测试类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        FastFood rice = <span class=\"hljs-keyword\">new</span> FriedRice();\n        System.out.println(rice.getDescription()+<span class=\"hljs-string\">\"  \"</span>+rice.getPrice());\n<span class=\"hljs-comment\">//        炒饭  10.0</span>\n        Egg egg = <span class=\"hljs-keyword\">new</span> Egg(rice);\n        System.out.println(egg.getDescription()+<span class=\"hljs-string\">\"   \"</span>+egg.cost());\n<span class=\"hljs-comment\">//        鸡蛋炒饭   11.0</span>\n    }\n}\n</code></div></pre>\n<p><strong>好处：</strong></p>\n<ul>\n<li>\n<p>饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任。</p>\n</li>\n<li>\n<p>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>\n</li>\n</ul>\n<h2><a id=\"34__1321\"></a>3.4 桥接模式</h2>\n<h3><a id=\"541__1323\"></a>5.4.1 概述</h3>\n<p>现在有一个需求，需要创建不同的图形，并且每个图形都有可能会有不同的颜色。我们可以利用继承的方式来设计类的关系：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/b8135ce6beda429d880509790cb65f98.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>我们可以发现有很多的类，假如我们再增加一个形状或再增加一种颜色，就需要创建更多的类。</p>\n<p>试想，在一个有多种可能会变化的维度的系统中，用继承方式会造成类爆炸，扩展起来不灵活。每次在一个维度上新增一个具体实现都要增加多个子类。为了更加灵活的设计系统，我们此时可以考虑使用桥接模式。</p>\n<p><strong>定义：</strong></p>\n<p>​	将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p>\n<h3><a id=\"342__1340\"></a>3.4.2 结构</h3>\n<p>桥接（Bridge）模式包含以下主要角色：</p>\n<ul>\n<li>抽象化（Abstraction）角色 ：定义抽象类，并包含一个对实现化对象的引用。</li>\n<li>扩展抽象化（Refined  Abstraction）角色 ：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li>\n<li>实现化（Implementor）角色 ：定义实现化角色的接口，供扩展抽象化角色调用。</li>\n<li>具体实现化（Concrete Implementor）角色 ：给出实现化角色接口的具体实现。</li>\n</ul>\n<h3><a id=\"343__1349\"></a>3.4.3 案例</h3>\n<p>【例】视频播放器</p>\n<p>需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等。该播放器包含了两个维度，适合使用桥接模式。</p>\n<p>类图如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/34cba7a4e76f4da78727d2298754e361.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>代码如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//视频文件</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">VideoFile</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">decode</span><span class=\"hljs-params\">(String fileName)</span></span>;\n}\n\n<span class=\"hljs-comment\">//avi文件</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AVIFile</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">VideoFile</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">decode</span><span class=\"hljs-params\">(String fileName)</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"avi视频文件：\"</span>+ fileName);\n    }\n}\n\n<span class=\"hljs-comment\">//rmvb文件</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">REVBBFile</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">VideoFile</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">decode</span><span class=\"hljs-params\">(String fileName)</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"rmvb文件：\"</span> + fileName);\n    }\n}\n\n<span class=\"hljs-comment\">//操作系统版本</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">OperatingSystemVersion</span> </span>{\n\n    <span class=\"hljs-keyword\">protected</span> VideoFile videoFile;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">OperatingSystemVersion</span><span class=\"hljs-params\">(VideoFile videoFile)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.videoFile = videoFile;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">play</span><span class=\"hljs-params\">(String fileName)</span></span>;\n}\n\n<span class=\"hljs-comment\">//Windows版本</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Windows</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">OperatingSystem</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Windows</span><span class=\"hljs-params\">(VideoFile videoFile)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(videoFile);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">play</span><span class=\"hljs-params\">(String fileName)</span> </span>{\n        videoFile.decode(fileName);\n    }\n}\n\n<span class=\"hljs-comment\">//mac版本</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Mac</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">OperatingSystemVersion</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Mac</span><span class=\"hljs-params\">(VideoFile videoFile)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(videoFile);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">play</span><span class=\"hljs-params\">(String fileName)</span> </span>{\n		videoFile.decode(fileName);\n    }\n}\n\n<span class=\"hljs-comment\">//测试类</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Client</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        OperatingSystem os = <span class=\"hljs-keyword\">new</span> Windows(<span class=\"hljs-keyword\">new</span> AVIFile());\n        os.play(<span class=\"hljs-string\">\"战狼3\"</span>);\n    }\n}\n</code></div></pre>\n<p><strong>好处：</strong></p>\n<ul>\n<li>\n<p>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</p>\n<p>如：如果现在还有一种视频文件类型wmv，我们只需要再定义一个类实现VideoFile接口即可，其他类不需要发生变化。</p>\n</li>\n<li>\n<p>实现细节对客户透明</p>\n</li>\n</ul>\n<h3><a id=\"344__1438\"></a>3.4.4 使用场景</h3>\n<ul>\n<li>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</li>\n<li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</li>\n<li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li>\n</ul>\n<h2><a id=\"35__1444\"></a>3.5 外观模式</h2>\n<h3><a id=\"351__1446\"></a>3.5.1 概述</h3>\n<p>有些人可能炒过股票，但其实大部分人都不太懂，这种没有足够了解证券知识的情况下做股票是很容易亏钱的，刚开始炒股肯定都会想，如果有个懂行的帮帮手就好，其实基金就是个好帮手，支付宝里就有许多的基金，它将投资者分散的资金集中起来，交由专业的经理人进行管理，投资于股票、债券、外汇等领域，而基金投资的收益归持有者所有，管理机构收取一定比例的托管管理费用。</p>\n<p><strong>定义：</strong></p>\n<p>​	又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p>\n<p>​	外观（Facade）模式是“迪米特法则”的典型应用</p>\n<p><img src=\"https://img-blog.csdnimg.cn/0aedecfb7114485c9b0d59c860499b77.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<h3><a id=\"352__1461\"></a>3.5.2 结构</h3>\n<p>外观（Facade）模式包含以下主要角色：</p>\n<ul>\n<li>外观（Facade）角色：为多个子系统对外提供一个共同的接口。</li>\n<li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li>\n</ul>\n<h3><a id=\"353__1468\"></a>3.5.3 案例</h3>\n<p>【例】智能家电控制</p>\n<p>小明的爷爷已经60岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；操作起来都比较麻烦。所以小明给爷爷买了智能音箱，可以通过语音直接控制这些智能家电的开启和关闭。类图如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d76aca27d02b4f5995cbc5506bcfd117.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>代码如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//灯类</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Light</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">on</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"打开了灯....\"</span>);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">off</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"关闭了灯....\"</span>);\n    }\n}\n\n<span class=\"hljs-comment\">//电视类</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TV</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">on</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"打开了电视....\"</span>);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">off</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"关闭了电视....\"</span>);\n    }\n}\n\n<span class=\"hljs-comment\">//控制类</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AirCondition</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">on</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"打开了空调....\"</span>);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">off</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"关闭了空调....\"</span>);\n    }\n}\n\n<span class=\"hljs-comment\">//智能音箱</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SmartAppliancesFacade</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> Light light;\n    <span class=\"hljs-keyword\">private</span> TV tv;\n    <span class=\"hljs-keyword\">private</span> AirCondition airCondition;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">SmartAppliancesFacade</span><span class=\"hljs-params\">()</span> </span>{\n        light = <span class=\"hljs-keyword\">new</span> Light();\n        tv = <span class=\"hljs-keyword\">new</span> TV();\n        airCondition = <span class=\"hljs-keyword\">new</span> AirCondition();\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">say</span><span class=\"hljs-params\">(String message)</span> </span>{\n        <span class=\"hljs-keyword\">if</span>(message.contains(<span class=\"hljs-string\">\"打开\"</span>)) {\n            on();\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(message.contains(<span class=\"hljs-string\">\"关闭\"</span>)) {\n            off();\n        } <span class=\"hljs-keyword\">else</span> {\n            System.out.println(<span class=\"hljs-string\">\"我还听不懂你说的！！！\"</span>);\n        }\n    }\n\n    <span class=\"hljs-comment\">//起床后一键开电器</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">on</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"起床了\"</span>);\n        light.on();\n        tv.on();\n        airCondition.on();\n    }\n\n    <span class=\"hljs-comment\">//睡觉一键关电器</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">off</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"睡觉了\"</span>);\n        light.off();\n        tv.off();\n        airCondition.off();\n    }\n}\n\n<span class=\"hljs-comment\">//测试类</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Client</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        <span class=\"hljs-comment\">//创建外观对象</span>\n        SmartAppliancesFacade facade = <span class=\"hljs-keyword\">new</span> SmartAppliancesFacade();\n        <span class=\"hljs-comment\">//客户端直接与外观对象进行交互</span>\n        facade.say(<span class=\"hljs-string\">\"打开家电\"</span>);\n        facade.say(<span class=\"hljs-string\">\"关闭家电\"</span>);\n    }\n}\n</code></div></pre>\n<p><strong>好处：</strong></p>\n<ul>\n<li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li>\n<li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>不符合开闭原则，修改很麻烦</li>\n</ul>\n<h3><a id=\"354__1576\"></a>3.5.4 使用场景</h3>\n<ul>\n<li>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</li>\n<li>当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。</li>\n<li>当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。</li>\n</ul>\n<h3><a id=\"355__1584\"></a>3.5.5 源码解析</h3>\n<p>使用tomcat作为web容器时，接收浏览器发送过来的请求，tomcat会将请求信息封装成ServletRequest对象，如下图①处对象。但是大家想想ServletRequest是一个接口，它还有一个子接口HttpServletRequest，而我们知道该request对象肯定是一个HttpServletRequest对象的子实现类对象，到底是哪个类的对象呢？可以通过输出request对象，我们就会发现是一个名为RequestFacade的类的对象。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/7fe45f1701074db582d0ed201b065e09.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>RequestFacade类就使用了外观模式。先看结构图：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/a6a2954b0b504f30a4275377103f9678.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>为什么在此处使用外观模式呢？</strong></p>\n<p>定义 RequestFacade 类，分别实现 ServletRequest ，同时定义私有成员变量 Request ，并且方法的实现调用 Request  的实现。然后，将 RequestFacade上转为 ServletRequest  传给 servlet 的 service 方法，这样即使在 servlet 中被下转为 RequestFacade ，也不能访问私有成员变量对象中的方法。既用了 Request ，又能防止其中方法被不合理的访问。</p>\n<h2><a id=\"36__1600\"></a>3.6 组合模式</h2>\n<h3><a id=\"361__1602\"></a>3.6.1 概述</h3>\n<p><img src=\"https://img-blog.csdnimg.cn/9989fa411d994b33832dadd593a89fab.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>​	对于这个图片肯定会非常熟悉，上图我们可以看做是一个文件系统，对于这样的结构我们称之为树形结构。在树形结构中可以通过调用某个方法来遍历整个树，当我们找到某个叶子节点后，就可以对叶子节点进行相关的操作。可以将这颗树理解成一个大的容器，容器里面包含很多的成员对象，这些成员对象即可是容器对象也可以是叶子对象。但是由于容器对象和叶子对象在功能上面的区别，使得我们在使用的过程中必须要区分容器对象和叶子对象，但是这样就会给客户带来不必要的麻烦，作为客户而已，它始终希望能够一致的对待容器对象和叶子对象。</p>\n<p><strong>定义：</strong></p>\n<p>​	又名部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p>\n<h3><a id=\"362__1613\"></a>3.6.2 结构</h3>\n<p>组合模式主要包含三种角色：</p>\n<ul>\n<li>抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。</li>\n<li>树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。</li>\n<li>叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。</li>\n</ul>\n<h3><a id=\"363__1621\"></a>3.6.3 案例实现</h3>\n<p>【例】软件菜单</p>\n<p>如下图，我们在访问别的一些管理系统时，经常可以看到类似的菜单。一个菜单可以包含菜单项（菜单项是指不再包含其他内容的菜单条目），也可以包含带有其他菜单项的菜单，因此使用组合模式描述菜单就很恰当，我们的需求是针对一个菜单，打印出其包含的所有菜单以及菜单项的名称。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d5465a9b244a4709b3575d1265517d12.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>要实现该案例，我们先画出类图：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/e797c989e5a54ffa9d08c557a90c4b06.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>代码实现：</strong></p>\n<p>不管是菜单还是菜单项，都应该继承自统一的接口，这里姑且将这个统一的接口称为菜单组件。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//菜单组件  不管是菜单还是菜单项，都应该继承该类</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MenuComponent</span> </span>{\n\n    <span class=\"hljs-keyword\">protected</span> String name;\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">int</span> level;\n\n    <span class=\"hljs-comment\">//添加菜单</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(MenuComponent menuComponent)</span></span>{\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> UnsupportedOperationException();\n    }\n\n    <span class=\"hljs-comment\">//移除菜单</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(MenuComponent menuComponent)</span></span>{\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> UnsupportedOperationException();\n    }\n\n    <span class=\"hljs-comment\">//获取指定的子菜单</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> MenuComponent <span class=\"hljs-title\">getChild</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> i)</span></span>{\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> UnsupportedOperationException();\n    }\n\n    <span class=\"hljs-comment\">//获取菜单名称</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">getName</span><span class=\"hljs-params\">()</span></span>{\n        <span class=\"hljs-keyword\">return</span> name;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">()</span></span>{\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> UnsupportedOperationException();\n    }\n}\n</code></div></pre>\n<p>这里的MenuComponent定义为抽象类，因为有一些共有的属性和行为要在该类中实现，Menu和MenuItem类就可以只覆盖自己感兴趣的方法，而不用搭理不需要或者不感兴趣的方法，举例来说，Menu类可以包含子菜单，因此需要覆盖add()、remove()、getChild()方法，但是MenuItem就不应该有这些方法。这里给出的默认实现是抛出异常，你也可以根据自己的需要改写默认实现。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Menu</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">MenuComponent</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> List&lt;MenuComponent&gt; menuComponentList;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Menu</span><span class=\"hljs-params\">(String name,<span class=\"hljs-keyword\">int</span> level)</span></span>{\n        <span class=\"hljs-keyword\">this</span>.level = level;\n        <span class=\"hljs-keyword\">this</span>.name = name;\n        menuComponentList = <span class=\"hljs-keyword\">new</span> ArrayList&lt;MenuComponent&gt;();\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(MenuComponent menuComponent)</span> </span>{\n        menuComponentList.add(menuComponent);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(MenuComponent menuComponent)</span> </span>{\n        menuComponentList.remove(menuComponent);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> MenuComponent <span class=\"hljs-title\">getChild</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> i)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> menuComponentList.get(i);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">()</span> </span>{\n\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; level; i++) {\n            System.out.print(<span class=\"hljs-string\">\"--\"</span>);\n        }\n        System.out.println(name);\n        <span class=\"hljs-keyword\">for</span> (MenuComponent menuComponent : menuComponentList) {\n            menuComponent.print();\n        }\n    }\n}\n</code></div></pre>\n<p>Menu类已经实现了除了getName方法的其他所有方法，因为Menu类具有添加菜单，移除菜单和获取子菜单的功能。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MenuItem</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">MenuComponent</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">MenuItem</span><span class=\"hljs-params\">(String name,<span class=\"hljs-keyword\">int</span> level)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.name = name;\n        <span class=\"hljs-keyword\">this</span>.level = level;\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; level; i++) {\n            System.out.print(<span class=\"hljs-string\">\"--\"</span>);\n        }\n        System.out.println(name);\n    }\n}\n</code></div></pre>\n<p>MenuItem是菜单项，不能再有子菜单，所以添加菜单，移除菜单和获取子菜单的功能并不能实现。</p>\n<h3><a id=\"364__1738\"></a>3.6.4 组合模式的分类</h3>\n<p>在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式。</p>\n<ul>\n<li>\n<p>透明组合模式</p>\n<p>透明组合模式中，抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中 <code>MenuComponent</code> 声明了 <code>add</code>、<code>remove</code> 、<code>getChild</code> 方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。</p>\n<p>透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 add()、remove() 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）</p>\n</li>\n<li>\n<p>安全组合模式</p>\n<p>在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点 <code>Menu</code> 类中声明并实现这些方法。安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/14145de2f378443184306c5c932da46c.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n</li>\n</ul>\n<h3><a id=\"365__1757\"></a>3.6.5 优点</h3>\n<ul>\n<li>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。</li>\n<li>客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。</li>\n<li>在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”。</li>\n<li>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。</li>\n</ul>\n<h3><a id=\"366__1766\"></a>3.6.6 使用场景</h3>\n<p>组合模式正是应树形结构而生，所以组合模式的使用场景就是出现树形结构的地方。比如：文件目录显示，多级目录呈现等树形结构数据的操作。</p>\n<h2><a id=\"37__1769\"></a>3.7 享元模式</h2>\n<h1><a id=\"4__1771\"></a>4. 行为型模式</h1>\n<p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p>\n<p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</p>\n<p>行为型模式分为：</p>\n<ul>\n<li>模板方法模式</li>\n<li>策略模式</li>\n<li>命令模式</li>\n<li>职责链模式</li>\n<li>状态模式</li>\n<li>观察者模式</li>\n<li>中介者模式</li>\n<li>迭代器模式</li>\n<li>访问者模式</li>\n<li>备忘录模式</li>\n<li>解释器模式</li>\n</ul>\n<p>以上 11 种行为型模式，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式。</p>\n<h2><a id=\"41__1793\"></a>4.1 模板方法模式</h2>\n<h3><a id=\"411__1795\"></a>4.1.1 概述</h3>\n<p>在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。</p>\n<p>例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。</p>\n<p><strong>定义：</strong></p>\n<p><mark>定义一个操作中的算法骨架，其实就是方法的执行顺序固定</mark>，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p>\n<h3><a id=\"412__1805\"></a>4.1.2 结构</h3>\n<p>模板方法（Template Method）模式包含以下主要角色：</p>\n<ul>\n<li>\n<p>抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。</p>\n<ul>\n<li>\n<p>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</p>\n</li>\n<li>\n<p>基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：</p>\n<ul>\n<li>\n<p>抽象方法(Abstract Method) ：一个抽象方法由抽象类声明、由其具体子类实现。</p>\n</li>\n<li>\n<p>具体方法(Concrete Method) ：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。</p>\n</li>\n<li>\n<p>钩子方法(Hook Method) ：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</p>\n<p>一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。</p>\n</li>\n</ul>\n<p>【例子】</p>\n<p>学生行为包括：先揉眼睛、看xx、闭上眼睛。但是前后一个都是必经的，所以我们不妨提取出骨架，保证执行顺序，但是具体看什么，由具体类实现具体看什么。比如看书、看电影。</p>\n<blockquote>\n<p>代码</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//学生行为抽象类</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StudentBehavior</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">look</span><span class=\"hljs-params\">()</span></span>;\n\n    <span class=\"hljs-comment\">//这里就是模板方法的算法骨架。我们把骨架放在抽象类（实体类也行，但是抽象类更符合，因为我们要去子类实现骨架中的方法）</span>\n    <span class=\"hljs-comment\">//而look则是由子类实现，子类可以不同方式实现，骨架不动。look()调用，同个类的实例方法调用，完整写法：this.look()，但可以省略的</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">process</span><span class=\"hljs-params\">()</span></span>{\n        System.out.println(<span class=\"hljs-string\">\"先揉眼睛\"</span>);\n        look();\n        System.out.println(<span class=\"hljs-string\">\"闭上眼睛\"</span>);\n    }\n}\n</code></div></pre>\n<p>具体类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StudentBook</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">StudentBehavior</span></span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">look</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"子类在看-&gt;书\"</span>);\n    }\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StudentFilm</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">StudentBehavior</span></span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">look</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"子类在看-&gt;电影\"</span>);\n    }\n}\n</code></div></pre>\n<p>测试：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        StudentBehavior studentBook = <span class=\"hljs-keyword\">new</span> StudentBook();\n        studentBook.process();\n        StudentBehavior studentFilm = <span class=\"hljs-keyword\">new</span> StudentFilm();\n        studentFilm.process();\n       <span class=\"hljs-comment\">/* 先揉眼睛\n            子类在看-&gt;书\n          闭上眼睛\n        =============\n         先揉眼睛\n            子类在看-&gt;电影\n         闭上眼睛*/</span>\n    }\n}\n</code></div></pre>\n<h3><a id=\"413__1883\"></a>4.1.3 优缺点</h3>\n<p><strong>优点：</strong></p>\n<ul>\n<li>\n<p>提高代码复用性</p>\n<p>将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。</p>\n</li>\n<li>\n<p>实现了反向控制</p>\n<p>通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。</p>\n</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li>\n<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li>\n</ul>\n<h3><a id=\"414__1902\"></a>4.1.4 适用场景</h3>\n<ul>\n<li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li>\n<li>需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。</li>\n</ul>\n<h3><a id=\"415_JDK_1907\"></a>4.1.5 JDK源码解析</h3>\n<p>InputStream类就使用了模板方法模式。在InputStream类中定义了多个 <code>read()</code> 方法，如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">InputStream</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Closeable</span> </span>{\n    <span class=\"hljs-comment\">//抽象方法，要求子类必须重写</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">read</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> IOException</span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">read</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">byte</span> b[])</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n        <span class=\"hljs-keyword\">return</span> read(b, <span class=\"hljs-number\">0</span>, b.length);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">read</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">byte</span> b[], <span class=\"hljs-keyword\">int</span> off, <span class=\"hljs-keyword\">int</span> len)</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n        <span class=\"hljs-keyword\">if</span> (b == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> NullPointerException();\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (off &lt; <span class=\"hljs-number\">0</span> || len &lt; <span class=\"hljs-number\">0</span> || len &gt; b.length - off) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IndexOutOfBoundsException();\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (len == <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n        }\n\n        <span class=\"hljs-keyword\">int</span> c = read(); <span class=\"hljs-comment\">//调用了无参的read方法，该方法是每次读取一个字节数据</span>\n        <span class=\"hljs-keyword\">if</span> (c == -<span class=\"hljs-number\">1</span>) {\n            <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;\n        }\n        b[off] = (<span class=\"hljs-keyword\">byte</span>)c;\n\n        <span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-keyword\">for</span> (; i &lt; len ; i++) {\n                c = read();\n                <span class=\"hljs-keyword\">if</span> (c == -<span class=\"hljs-number\">1</span>) {\n                    <span class=\"hljs-keyword\">break</span>;\n                }\n                b[off + i] = (<span class=\"hljs-keyword\">byte</span>)c;\n            }\n        } <span class=\"hljs-keyword\">catch</span> (IOException ee) {\n        }\n        <span class=\"hljs-keyword\">return</span> i;\n    }\n}\n</code></div></pre>\n<p>从上面代码可以看到，无参的 <code>read()</code> 方法是抽象方法，要求子类必须实现。而 <code>read(byte b[])</code> 方法调用了 <code>read(byte b[], int off, int len)</code> 方法，所以在此处重点看的方法是带三个参数的方法。</p>\n<p>在该方法中第18行、27行，可以看到调用了无参的抽象的 <code>read()</code> 方法。</p>\n<p>总结如下： 在InputStream父类中已经定义好了读取一个字节数组数据的方法是每次读取一个字节，并将其存储到数组的第一个索引位置，读取len个字节数据。具体如何读取一个字节数据呢？由子类实现。</p>\n<h2><a id=\"42__1957\"></a>4.2 策略模式</h2>\n<h3><a id=\"421__1959\"></a>4.2.1 概述</h3>\n<p>先看下面的图片，我们去旅游选择出行模式有很多种，可以骑自行车、可以坐汽车、可以坐火车、可以坐飞机。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2e43bbc948ab49e992aa7a11f112fda3.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>定义：</strong></p>\n<p>​	==该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。==策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p>\n<h3><a id=\"422__1972\"></a>4.2.2 结构</h3>\n<p>策略模式的主要角色如下：</p>\n<ul>\n<li>抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li>\n<li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。</li>\n<li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li>\n</ul>\n<p>【例子】</p>\n<blockquote>\n<p>代码</p>\n</blockquote>\n<p>移动接口</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">StrategyMove</span> </span>{    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">move</span><span class=\"hljs-params\">()</span></span>;}\n</code></div></pre>\n<p>移动实现类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StrategyRun</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">StrategyMove</span></span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">move</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"跑步\"</span>);\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StrategyWalk</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">StrategyMove</span></span>{\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">move</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"走路\"</span>);\n    }\n}\n</code></div></pre>\n<p>实现的对象（其实可以抽象化更好）又叫环境角色类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">/*\npublic abstract People implements StrategyMove{\n    @Override\n    public void move() {\n\n    }\n}\n这是反例!\n虽然我们可以理解说接口就是功能，但也不能作用在对象身上，\n因为如果新增People的子类，那就要重写父类方法，有些移动方法在其他对象其实已经写过了。\n如果新增了移动方法，那么所有的对象都要新增，维护成本极大！\n算法的变化不会影响使用算法的客户才行！而不是新增一个移动，就要新增改造对象。\n**希望的是移动方法由客户来替换而不是去改客户的代码！**\n《合成复用原则》\n*/</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">People</span> </span>{\n    StrategyMove strategyMove;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">People</span><span class=\"hljs-params\">(StrategyMove strategyMove)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.strategyMove = strategyMove;\n    }\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">move</span><span class=\"hljs-params\">()</span></span>{\n        strategyMove.move();\n    }\n}\n</code></div></pre>\n<p>测试</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        People people1 = <span class=\"hljs-keyword\">new</span> People(<span class=\"hljs-keyword\">new</span> StrategyRun());\n        people1.move();\n        People people2 = <span class=\"hljs-keyword\">new</span> People(<span class=\"hljs-keyword\">new</span> StrategyWalk());\n        people2.move();\n    }\n}\n</code></div></pre>\n<h3><a id=\"424__2053\"></a>4.2.4 优缺点</h3>\n<p><strong>1，优点：</strong></p>\n<ul>\n<li>\n<p>策略类之间可以自由切换</p>\n<p>由于策略类都实现同一个接口，所以使它们之间可以自由切换。</p>\n</li>\n<li>\n<p>易于扩展</p>\n<p>增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则“</p>\n</li>\n<li>\n<p>避免使用多重条件选择语句（if else），充分体现面向对象设计思想。</p>\n</li>\n</ul>\n<p><strong>2，缺点：</strong></p>\n<ul>\n<li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li>\n<li>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。</li>\n</ul>\n<h3><a id=\"425__2072\"></a>4.2.5 使用场景</h3>\n<ul>\n<li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</li>\n<li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。</li>\n<li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。</li>\n<li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。</li>\n<li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li>\n</ul>\n<h3><a id=\"426_JDK_2080\"></a>4.2.6 JDK源码解析</h3>\n<p><code>Comparator</code> 中的策略模式。在Arrays类中有一个 <code>sort()</code> 方法，如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Arrays</span></span>{\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sort</span><span class=\"hljs-params\">(T[] a, Comparator&lt;? <span class=\"hljs-keyword\">super</span> T&gt; c)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (c == <span class=\"hljs-keyword\">null</span>) {\n            sort(a);\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">if</span> (LegacyMergeSort.userRequested)\n                legacyMergeSort(a, c);\n            <span class=\"hljs-keyword\">else</span>\n                TimSort.sort(a, <span class=\"hljs-number\">0</span>, a.length, c, <span class=\"hljs-keyword\">null</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);\n        }\n    }\n}\n</code></div></pre>\n<p>Arrays就是一个环境角色类，这个sort方法可以传一个新策略让Arrays根据这个策略来进行排序。就比如下面的测试类。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">demo</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n\n        Integer[] data = {<span class=\"hljs-number\">12</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">1</span>};\n        <span class=\"hljs-comment\">// 实现降序排序</span>\n        Arrays.sort(data, <span class=\"hljs-keyword\">new</span> Comparator&lt;Integer&gt;() {\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(Integer o1, Integer o2)</span> </span>{\n                <span class=\"hljs-keyword\">return</span> o2 - o1;\n            }\n        });\n        System.out.println(Arrays.toString(data)); <span class=\"hljs-comment\">//[12, 5, 4, 3, 2, 2, 1]</span>\n    }\n}\n</code></div></pre>\n<p>这里我们在调用Arrays的sort方法时，第二个参数传递的是Comparator接口的子实现类对象。所以Comparator充当的是抽象策略角色，而具体的子实现类充当的是具体策略角色。环境角色类（Arrays）应该持有抽象策略的引用来调用。那么，Arrays类的sort方法到底有没有使用Comparator子实现类中的 <code>compare()</code> 方法吗？让我们继续查看TimSort类的 <code>sort()</code> 方法，代码如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TimSort</span>&lt;<span class=\"hljs-title\">T</span>&gt; </span>{\n    <span class=\"hljs-keyword\">static</span> &lt;T&gt; <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sort</span><span class=\"hljs-params\">(T[] a, <span class=\"hljs-keyword\">int</span> lo, <span class=\"hljs-keyword\">int</span> hi, Comparator&lt;? <span class=\"hljs-keyword\">super</span> T&gt; c,\n                         T[] work, <span class=\"hljs-keyword\">int</span> workBase, <span class=\"hljs-keyword\">int</span> workLen)</span> </span>{\n        <span class=\"hljs-keyword\">assert</span> c != <span class=\"hljs-keyword\">null</span> &amp;&amp; a != <span class=\"hljs-keyword\">null</span> &amp;&amp; lo &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;\n\n        <span class=\"hljs-keyword\">int</span> nRemaining  = hi - lo;\n        <span class=\"hljs-keyword\">if</span> (nRemaining &lt; <span class=\"hljs-number\">2</span>)\n            <span class=\"hljs-keyword\">return</span>;  <span class=\"hljs-comment\">// Arrays of size 0 and 1 are always sorted</span>\n\n        <span class=\"hljs-comment\">// If array is small, do a \"mini-TimSort\" with no merges</span>\n        <span class=\"hljs-keyword\">if</span> (nRemaining &lt; MIN_MERGE) {\n            <span class=\"hljs-keyword\">int</span> initRunLen = countRunAndMakeAscending(a, lo, hi, c);\n            binarySort(a, lo, hi, lo + initRunLen, c);\n            <span class=\"hljs-keyword\">return</span>;\n        }\n        ...\n    }   \n        \n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">countRunAndMakeAscending</span><span class=\"hljs-params\">(T[] a, <span class=\"hljs-keyword\">int</span> lo, <span class=\"hljs-keyword\">int</span> hi,Comparator&lt;? <span class=\"hljs-keyword\">super</span> T&gt; c)</span> </span>{\n        <span class=\"hljs-keyword\">assert</span> lo &lt; hi;\n        <span class=\"hljs-keyword\">int</span> runHi = lo + <span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-keyword\">if</span> (runHi == hi)\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n\n        <span class=\"hljs-comment\">// Find end of run, and reverse range if descending</span>\n        <span class=\"hljs-keyword\">if</span> (c.compare(a[runHi++], a[lo]) &lt; <span class=\"hljs-number\">0</span>) { <span class=\"hljs-comment\">// Descending</span>\n            <span class=\"hljs-keyword\">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class=\"hljs-number\">1</span>]) &lt; <span class=\"hljs-number\">0</span>)\n                runHi++;\n            reverseRange(a, lo, runHi);\n        } <span class=\"hljs-keyword\">else</span> {                              <span class=\"hljs-comment\">// Ascending</span>\n            <span class=\"hljs-keyword\">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class=\"hljs-number\">1</span>]) &gt;= <span class=\"hljs-number\">0</span>)\n                runHi++;\n        }\n\n        <span class=\"hljs-keyword\">return</span> runHi - lo;\n    }\n}\n</code></div></pre>\n<p>上面的代码中最终会跑到 <code>countRunAndMakeAscending()</code> 这个方法中。我们可以看见，只用了compare方法，所以在调用Arrays.sort方法只传具体compare重写方法的类对象就行，这也是Comparator接口中必须要子类实现的一个方法。</p>\n<h2><a id=\"43__2161\"></a>4.3 命令模式</h2>\n<h3><a id=\"431__2163\"></a>4.3.1 概述</h3>\n<p>日常生活中，我们出去吃饭都会遇到下面的场景。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/5086452cfc0449e4a79b2a9e2ca8d3e2.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>定义：</strong></p>\n<p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。</p>\n<h3><a id=\"432__2176\"></a>4.3.2 结构</h3>\n<p>命令模式包含以下主要角色：</p>\n<ul>\n<li>抽象命令类（Command）角色： 定义命令的接口，声明执行的方法。</li>\n<li>具体命令（Concrete  Command）角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。</li>\n<li>实现者/接收者（Receiver）角色： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。</li>\n<li>调用者/请求者（Invoker）角色： 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。</li>\n</ul>\n<h3><a id=\"433__2187\"></a>4.3.3 案例实现</h3>\n<p>将上面的案例用代码实现，那我们就需要分析命令模式的角色在该案例中由谁来充当。</p>\n<p>服务员： 就是调用者角色，由她来发起命令。</p>\n<p>资深大厨： 就是接收者角色，真正命令执行的对象。</p>\n<p>订单： 命令中包含订单。</p>\n<p>类图如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/ad057e08769a4ec4abab4d39368fbbec.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>代码如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">Command</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">execute</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//只需要定义一个统一的执行方法</span>\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">OrderCommand</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Command</span> </span>{\n\n    <span class=\"hljs-comment\">//持有接受者对象</span>\n    <span class=\"hljs-keyword\">private</span> SeniorChef receiver;\n    <span class=\"hljs-keyword\">private</span> Order order;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">OrderCommand</span><span class=\"hljs-params\">(SeniorChef receiver, Order order)</span></span>{\n        <span class=\"hljs-keyword\">this</span>.receiver = receiver;\n        <span class=\"hljs-keyword\">this</span>.order = order;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">execute</span><span class=\"hljs-params\">()</span>  </span>{\n        System.out.println(order.getDiningTable() + <span class=\"hljs-string\">\"桌的订单：\"</span>);\n        Set&lt;String&gt; keys = order.getFoodDic().keySet();\n        <span class=\"hljs-keyword\">for</span> (String key : keys) {\n            receiver.makeFood(order.getFoodDic().get(key),key);\n        }\n\n        <span class=\"hljs-keyword\">try</span> {\n            Thread.sleep(<span class=\"hljs-number\">100</span>);<span class=\"hljs-comment\">//停顿一下 模拟做饭的过程</span>\n        } <span class=\"hljs-keyword\">catch</span> (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n\n        System.out.println(order.getDiningTable() + <span class=\"hljs-string\">\"桌的饭弄好了\"</span>);\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Order</span> </span>{\n    <span class=\"hljs-comment\">// 餐桌号码</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> diningTable;\n\n    <span class=\"hljs-comment\">// 用来存储餐名并记录份数</span>\n    <span class=\"hljs-keyword\">private</span> Map&lt;String, Integer&gt; foodDic = <span class=\"hljs-keyword\">new</span> HashMap&lt;String, Integer&gt;();\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getDiningTable</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> diningTable;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setDiningTable</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> diningTable)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.diningTable = diningTable;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Map&lt;String, Integer&gt; <span class=\"hljs-title\">getFoodDic</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> foodDic;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setFoodDic</span><span class=\"hljs-params\">(String name, <span class=\"hljs-keyword\">int</span> num)</span> </span>{\n        foodDic.put(name,num);\n    }\n}\n\n<span class=\"hljs-comment\">// 资深大厨类 是命令的Receiver</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SeniorChef</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">makeFood</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> num,String foodName)</span> </span>{\n        System.out.println(num + <span class=\"hljs-string\">\"份\"</span> + foodName);\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Waitor</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> ArrayList&lt;Command&gt; commands;<span class=\"hljs-comment\">//可以持有很多的命令对象</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Waitor</span><span class=\"hljs-params\">()</span> </span>{\n        commands = <span class=\"hljs-keyword\">new</span> ArrayList();\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setCommand</span><span class=\"hljs-params\">(Command cmd)</span></span>{\n        commands.add(cmd);\n    }\n\n    <span class=\"hljs-comment\">// 发出命令 喊 订单来了，厨师开始执行</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">orderUp</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">\"美女服务员：叮咚，大厨，新订单来了.......\"</span>);\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; commands.size(); i++) {\n            Command cmd = commands.get(i);\n            <span class=\"hljs-keyword\">if</span> (cmd != <span class=\"hljs-keyword\">null</span>) {\n                cmd.execute();\n            }\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Client</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        <span class=\"hljs-comment\">//创建2个order</span>\n        Order order1 = <span class=\"hljs-keyword\">new</span> Order();\n        order1.setDiningTable(<span class=\"hljs-number\">1</span>);\n        order1.getFoodDic().put(<span class=\"hljs-string\">\"西红柿鸡蛋面\"</span>,<span class=\"hljs-number\">1</span>);\n        order1.getFoodDic().put(<span class=\"hljs-string\">\"小杯可乐\"</span>,<span class=\"hljs-number\">2</span>);\n\n        Order order2 = <span class=\"hljs-keyword\">new</span> Order();\n        order2.setDiningTable(<span class=\"hljs-number\">3</span>);\n        order2.getFoodDic().put(<span class=\"hljs-string\">\"尖椒肉丝盖饭\"</span>,<span class=\"hljs-number\">1</span>);\n        order2.getFoodDic().put(<span class=\"hljs-string\">\"小杯雪碧\"</span>,<span class=\"hljs-number\">1</span>);\n\n        <span class=\"hljs-comment\">//创建接收者</span>\n        SeniorChef receiver=<span class=\"hljs-keyword\">new</span> SeniorChef();\n        <span class=\"hljs-comment\">//将订单和接收者封装成命令对象</span>\n        OrderCommand cmd1 = <span class=\"hljs-keyword\">new</span> OrderCommand(receiver, order1);\n        OrderCommand cmd2 = <span class=\"hljs-keyword\">new</span> OrderCommand(receiver, order2);\n        <span class=\"hljs-comment\">//创建调用者 waitor</span>\n        Waitor invoker = <span class=\"hljs-keyword\">new</span> Waitor();\n        invoker.setCommand(cmd1);\n        invoker.setCommand(cmd2);\n\n        <span class=\"hljs-comment\">//将订单带到柜台 并向厨师喊 订单来了</span>\n        invoker.orderUp();\n    }\n}\n</code></div></pre>\n<h3><a id=\"434__2325\"></a>4.3.4 优缺点</h3>\n<p><strong>1，优点：</strong></p>\n<ul>\n<li>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。</li>\n<li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。</li>\n<li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</li>\n<li>方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。</li>\n</ul>\n<p><strong>2，缺点：</strong></p>\n<ul>\n<li>使用命令模式可能会导致某些系统有过多的具体命令类。</li>\n<li>系统结构更加复杂。</li>\n</ul>\n<h3><a id=\"435__2341\"></a>4.3.5 使用场景</h3>\n<ul>\n<li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li>\n<li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li>\n<li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</li>\n</ul>\n<h3><a id=\"436_JDK_2349\"></a>4.3.6 JDK源码解析</h3>\n<p>Runable是一个典型命令模式，Runnable担当命令的角色，Thread充当的是调用者，start方法就是其执行方法</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//命令接口(抽象命令角色)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">Runnable</span> </span>{\n	<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span>;\n}\n\n<span class=\"hljs-comment\">//调用者</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Thread</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Runnable</span> </span>{\n    <span class=\"hljs-keyword\">private</span> Runnable target;\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (threadStatus != <span class=\"hljs-number\">0</span>)\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalThreadStateException();\n\n        group.add(<span class=\"hljs-keyword\">this</span>);\n\n        <span class=\"hljs-keyword\">boolean</span> started = <span class=\"hljs-keyword\">false</span>;\n        <span class=\"hljs-keyword\">try</span> {\n            start0();\n            started = <span class=\"hljs-keyword\">true</span>;\n        } <span class=\"hljs-keyword\">finally</span> {\n            <span class=\"hljs-keyword\">try</span> {\n                <span class=\"hljs-keyword\">if</span> (!started) {\n                    group.threadStartFailed(<span class=\"hljs-keyword\">this</span>);\n                }\n            } <span class=\"hljs-keyword\">catch</span> (Throwable ignore) {\n            }\n        }\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">native</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">start0</span><span class=\"hljs-params\">()</span></span>;\n}\n</code></div></pre>\n<p>会调用一个native方法start0(),调用系统方法，开启一个线程。而接收者是对程序员开放的，可以自己定义接收者。</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">/**\n * jdk Runnable 命令模式\n *		TurnOffThread ： 属于具体\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TurnOffThread</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Runnable</span></span>{\n     <span class=\"hljs-keyword\">private</span> Receiver receiver;\n    \n     <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">TurnOffThread</span><span class=\"hljs-params\">(Receiver receiver)</span> </span>{\n     	<span class=\"hljs-keyword\">this</span>.receiver = receiver;\n     }\n     <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>{\n     	receiver.turnOFF();\n     }\n}\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">/**\n * 测试类\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Demo</span> </span>{\n     <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n         Receiver receiver = <span class=\"hljs-keyword\">new</span> Receiver();\n         TurnOffThread turnOffThread = <span class=\"hljs-keyword\">new</span> TurnOffThread(receiver);\n         Thread thread = <span class=\"hljs-keyword\">new</span> Thread(turnOffThread);\n         thread.start();\n     }\n}\n</code></div></pre>\n<h2><a id=\"44__2420\"></a>4.4 责任链模式</h2>\n<h3><a id=\"441__2422\"></a>4.4.1 概述</h3>\n<p>在现实生活中，常常会出现这样的事例：一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。例如，公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这增加了难度。这样的例子还有很多，如找领导出差报销、生活中的“击鼓传花”游戏等。</p>\n<p><strong>定义：</strong></p>\n<p>又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p>\n<h3><a id=\"442__2432\"></a>4.4.2 结构</h3>\n<p>职责链模式主要包含以下角色:</p>\n<ul>\n<li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li>\n<li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li>\n<li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li>\n</ul>\n<h3><a id=\"443__2442\"></a>4.4.3 案例实现</h3>\n<p>一人想要借钱，有三个老板可以提供借钱，A老板最多借50元，B老板最多借钱100元，C老板最多借钱200元。</p>\n<blockquote>\n<p>代码</p>\n</blockquote>\n<p>抽象老板类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AbstractBoss</span> </span>{\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> MONEY_50=<span class=\"hljs-number\">50</span>;\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> MONEY_100=<span class=\"hljs-number\">100</span>;\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> MONEY_200=<span class=\"hljs-number\">200</span>;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> hasMoney;\n    <span class=\"hljs-keyword\">private</span> AbstractBoss nextBoss;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">AbstractBoss</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> hasMoney)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.hasMoney = hasMoney;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getHasMoney</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> hasMoney;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setAbstractBoss</span><span class=\"hljs-params\">(AbstractBoss nextBoss)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.nextBoss = nextBoss;\n    }\n\n    <span class=\"hljs-comment\">//不允许子类重写，属于结构型模式中模板方法模式，process是骨架,抽象lend由子类实现。</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">process</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> needMoney)</span></span>{\n        <span class=\"hljs-keyword\">if</span> (needMoney&lt;=<span class=\"hljs-keyword\">this</span>.hasMoney){\n            lend(needMoney);\n        }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">null</span>!=<span class=\"hljs-keyword\">this</span>.nextBoss){\n            <span class=\"hljs-keyword\">this</span>.nextBoss.process(needMoney);\n        }\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">lend</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> needMoney)</span></span>;\n}\n</code></div></pre>\n<p>具体老板类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BossA</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractBoss</span></span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">BossA</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> hasMoney)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(hasMoney);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">lend</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> needMoney)</span> </span>{\n        System.out.print(<span class=\"hljs-string\">\"A老板借出去\"</span>+needMoney+<span class=\"hljs-string\">\"元\"</span>);\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BossB</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractBoss</span></span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">BossB</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> hasMoney)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(hasMoney);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">lend</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> needMoney)</span> </span>{\n        System.out.print(<span class=\"hljs-string\">\"B老板借出去\"</span>+needMoney+<span class=\"hljs-string\">\"元\"</span>);\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BossC</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractBoss</span></span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">BossC</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> hasMoney)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(hasMoney);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">lend</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> needMoney)</span> </span>{\n        System.out.print(<span class=\"hljs-string\">\"C老板借出去\"</span>+needMoney+<span class=\"hljs-string\">\"元\"</span>);\n    }\n}\n</code></div></pre>\n<p>测试类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        AbstractBoss bossA = <span class=\"hljs-keyword\">new</span> BossA(AbstractBoss.MONEY_50);\n        AbstractBoss bossB = <span class=\"hljs-keyword\">new</span> BossB(AbstractBoss.MONEY_100);\n        AbstractBoss bossC = <span class=\"hljs-keyword\">new</span> BossC(AbstractBoss.MONEY_200);\n\n        <span class=\"hljs-comment\">//职责链从低层向上引用！确保钱被最佳化处理</span>\n        bossA.setAbstractBoss(bossB);\n        bossB.setAbstractBoss(bossC);\n\n        bossA.process(<span class=\"hljs-number\">49</span>);System.out.println(<span class=\"hljs-string\">\"(over)\"</span>);\n        bossA.process(<span class=\"hljs-number\">99</span>);System.out.println(<span class=\"hljs-string\">\"(over)\"</span>);\n        bossA.process(<span class=\"hljs-number\">199</span>);System.out.println(<span class=\"hljs-string\">\"(over)\"</span>);\n        bossA.process(<span class=\"hljs-number\">201</span>);System.out.println(<span class=\"hljs-string\">\"(over)\"</span>);\n\n    }\n}\nA老板借出去<span class=\"hljs-number\">49</span>元(over)\nB老板借出去<span class=\"hljs-number\">99</span>元(over)\nC老板借出去<span class=\"hljs-number\">199</span>元(over)\n(over)\n</code></div></pre>\n<h2><a id=\"45__2548\"></a>4.5 观察者模式</h2>\n<h3><a id=\"451__2550\"></a>4.5.1 概述</h3>\n<p><strong>定义：</strong></p>\n<p>又被称为发布-订阅（Publish/Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p>\n<h3><a id=\"452__2558\"></a>4.5.2 结构</h3>\n<p>在观察者模式中有如下角色：</p>\n<ul>\n<li>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</li>\n<li>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</li>\n<li>Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</li>\n<li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li>\n</ul>\n<h3><a id=\"453__2567\"></a>4.5.3 案例实现</h3>\n<p>【例】微信公众号</p>\n<p>在使用微信公众号时，大家都会有这样的体验，当你关注的公众号中有新内容更新的话，它就会推送给关注公众号的微信用户端。我们使用观察者模式来模拟这样的场景，微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了程序猿这个公众号。</p>\n<p>类图如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d9bf7fee5021423b972cd645ea0d32f7.png#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>代码如下：</p>\n<p>定义抽象观察者类，里面定义一个更新的方法</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">Observer</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">update</span><span class=\"hljs-params\">(String message)</span></span>;\n}\n</code></div></pre>\n<p>定义具体观察者类，微信用户是观察者，里面实现了更新的方法</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">WeixinUser</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Observer</span> </span>{\n    <span class=\"hljs-comment\">// 微信用户名</span>\n    <span class=\"hljs-keyword\">private</span> String name;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">WeixinUser</span><span class=\"hljs-params\">(String name)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.name = name;\n    }\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">update</span><span class=\"hljs-params\">(String message)</span> </span>{\n        System.out.println(name + <span class=\"hljs-string\">\"-\"</span> + message);\n    }\n}\n</code></div></pre>\n<p>定义抽象主题类，提供了attach、detach、notify三个方法</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">Subject</span> </span>{\n    <span class=\"hljs-comment\">//增加订阅者</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">attach</span><span class=\"hljs-params\">(Observer observer)</span></span>;\n\n    <span class=\"hljs-comment\">//删除订阅者</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">detach</span><span class=\"hljs-params\">(Observer observer)</span></span>;\n    \n    <span class=\"hljs-comment\">//通知订阅者更新消息</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">notify</span><span class=\"hljs-params\">(String message)</span></span>;\n}\n\n</code></div></pre>\n<p>微信公众号是具体主题（具体被观察者），里面存储了订阅该公众号的微信用户，并实现了抽象主题中的方法</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SubscriptionSubject</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Subject</span> </span>{\n    <span class=\"hljs-comment\">//储存订阅公众号的微信用户</span>\n    <span class=\"hljs-keyword\">private</span> List&lt;Observer&gt; weixinUserlist = <span class=\"hljs-keyword\">new</span> ArrayList&lt;Observer&gt;();\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">attach</span><span class=\"hljs-params\">(Observer observer)</span> </span>{\n        weixinUserlist.add(observer);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">detach</span><span class=\"hljs-params\">(Observer observer)</span> </span>{\n        weixinUserlist.remove(observer);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">notify</span><span class=\"hljs-params\">(String message)</span> </span>{\n        <span class=\"hljs-keyword\">for</span> (Observer observer : weixinUserlist) {\n            observer.update(message);\n        }\n    }\n}\n</code></div></pre>\n<p>客户端程序</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Client</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        SubscriptionSubject mSubscriptionSubject=<span class=\"hljs-keyword\">new</span> SubscriptionSubject();\n        <span class=\"hljs-comment\">//创建微信用户</span>\n        WeixinUser user1=<span class=\"hljs-keyword\">new</span> WeixinUser(<span class=\"hljs-string\">\"孙悟空\"</span>);\n        WeixinUser user2=<span class=\"hljs-keyword\">new</span> WeixinUser(<span class=\"hljs-string\">\"猪悟能\"</span>);\n        WeixinUser user3=<span class=\"hljs-keyword\">new</span> WeixinUser(<span class=\"hljs-string\">\"沙悟净\"</span>);\n        <span class=\"hljs-comment\">//订阅公众号</span>\n        mSubscriptionSubject.attach(user1);\n        mSubscriptionSubject.attach(user2);\n        mSubscriptionSubject.attach(user3);\n        <span class=\"hljs-comment\">//公众号更新发出消息给订阅的微信用户</span>\n        mSubscriptionSubject.notify(<span class=\"hljs-string\">\"传智黑马的专栏更新了\"</span>);\n    }\n}\n\n</code></div></pre>\n<h3><a id=\"454__2668\"></a>4.5.4 使用场景</h3>\n<ul>\n<li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</li>\n<li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面时。</li>\n</ul>\n<h3><a id=\"455_JDK_2673\"></a>4.5.5 JDK实现</h3>\n<p>在 Java 中，通过 java.util.Observable 类和 java.util.Observer 接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。</p>\n<p><strong>1，Observable类</strong></p>\n<p>Observable 类是抽象目标类（被观察者），它有一个 Vector 集合成员变量，用于保存所有要通知的观察者对象，下面来介绍它最重要的 3 个方法。</p>\n<ul>\n<li>\n<p>void addObserver(Observer o) 方法：用于将新的观察者对象添加到集合中。</p>\n</li>\n<li>\n<p>void notifyObservers(Object arg) 方法：调用集合中的所有观察者对象的 update方法，通知它们数据发生改变。通常越晚加入集合的观察者越先得到通知。</p>\n</li>\n<li>\n<p>void setChange() 方法：用来设置一个 boolean 类型的内部标志，注明目标对象发生了变化。当它为true时，notifyObservers() 才会通知观察者。</p>\n</li>\n</ul>\n<p><strong>2，Observer 接口</strong></p>\n<p>Observer 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 update 方法，进行相应的工作。</p>\n<p>【例子】</p>\n<p>多个警察抓一个小偷。</p>\n<p>警察</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//实现了这个接口 只是单单说明了警察是观察者。update是回调函数。</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Police</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Observer</span> </span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">update</span><span class=\"hljs-params\">(Observable o, Object arg)</span> </span>{\n        Thief o1 = (Thief) o;\n        System.out.println(<span class=\"hljs-string\">\"成功抓获小偷：\"</span>+o1.getName());\n    }\n}\n</code></div></pre>\n<p>小偷</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-comment\">//小偷继承Observable表示是可以被观察的类。</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Thief</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Observable</span> </span>{\n    <span class=\"hljs-keyword\">private</span> String name;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">getName</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> name;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setName</span><span class=\"hljs-params\">(String name)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.name = name;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Thief</span><span class=\"hljs-params\">()</span> </span>{\n        setChanged();\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">steal</span><span class=\"hljs-params\">()</span></span>{\n        System.out.println(<span class=\"hljs-string\">\"小偷正在偷东西！\"</span>);\n        notifyObservers();<span class=\"hljs-comment\">//底层遍历了所有观察者并逐个执行其update方法。</span>\n    }\n\n}\n</code></div></pre>\n<p>测试类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        Thief thief = <span class=\"hljs-keyword\">new</span> Thief();\n        Police police = <span class=\"hljs-keyword\">new</span> Police();\n\n        thief.setName(<span class=\"hljs-string\">\"肥莫\"</span>);\n<span class=\"hljs-comment\">//        添加为小偷的观察者，才能使得警察的观察有作用，也就是update可以被调用了</span>\n        thief.addObserver(police);\n\n        thief.steal();\n    }\n}\n</code></div></pre>\n<h2><a id=\"46__2751\"></a>4.6 状态模式</h2>\n<h2><a id=\"47__2753\"></a>4.7 中介者模式</h2>\n<h2><a id=\"48__2755\"></a>4.8 迭代器模式</h2>\n<h2><a id=\"49__2757\"></a>4.9 访问者模式</h2>\n<h2><a id=\"410__2759\"></a>4.10 备忘录模式</h2>\n<h2><a id=\"411__2761\"></a>4.11 解释器模式</h2>\n',1405916999732707353),(1521826671414923266,'32131','<p>32131</p>\n',1405916999732707354),(1521834741176119298,'555555555555555','<p>555555555555555</p>\n',1405916999732707355),(1521835373488377858,'999999999999','<p>999999999999</p>\n',1405916999732707356),(1521838657267699713,'321','<p>321</p>\n',1405916999732707357),(1521839344751874050,'321321','<p>321321</p>\n',1405916999732707358);
/*!40000 ALTER TABLE `aguo_article_body` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `aguo_article_tag`
--

DROP TABLE IF EXISTS `aguo_article_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `aguo_article_tag` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `article_id` bigint NOT NULL,
  `tag_id` bigint NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  KEY `article_id` (`article_id`) USING BTREE,
  KEY `tag_id` (`tag_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1521839344743485443 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `aguo_article_tag`
--

LOCK TABLES `aguo_article_tag` WRITE;
/*!40000 ALTER TABLE `aguo_article_tag` DISABLE KEYS */;
INSERT INTO `aguo_article_tag` VALUES (1,1,7),(2,1,5),(3,1,8),(4,9,7),(5,10,7),(6,10,8),(7,10,5),(8,10,6),(1405564731321802753,1405564731300831233,5),(1405909844761800706,1405909844724051969,5),(1405916999787233281,1405916999732707330,5),(1520671265850310657,1405916999732707334,5),(1520671285072805890,1405916999732707334,5),(1520673732830838785,1405916999732707335,5),(1520673840850944002,1405916999732707336,5),(1520673840859332609,1405916999732707336,6),(1521016788927049729,1405916999732707337,5),(1521016788927049730,1405916999732707337,6),(1521016788939632641,1405916999732707337,7),(1521016788952215553,1405916999732707337,8),(1521016959748468738,1405916999732707338,6),(1521531789232214018,1405916999732707339,5),(1521532209765715970,1405916999732707340,5),(1521547800077533186,1405916999732707341,5),(1521548406687215618,1405916999732707342,6),(1521548809273266177,1405916999732707343,6),(1521549624197144578,1405916999732707344,6),(1521553654117969921,1405916999732707345,6),(1521557831279894529,1405916999732707346,6),(1521769787668455426,1405916999732707347,5),(1521773321650622465,1405916999732707348,5),(1521774019947712514,1405916999732707349,5),(1521779976173924354,1405916999732707350,5),(1521780045602238465,1405916999732707351,5),(1521822721227804673,1405916999732707352,5),(1521822769613295618,1405916999732707353,9),(1521826671406534658,1405916999732707354,5),(1521834741163536385,1405916999732707355,5),(1521835373479989249,1405916999732707356,8),(1521838657129287681,1405916999732707357,5),(1521839344667987969,1405916999732707358,5),(1521839344743485442,1405916999732707358,7);
/*!40000 ALTER TABLE `aguo_article_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `aguo_category`
--

DROP TABLE IF EXISTS `aguo_category`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `aguo_category` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `category_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `aguo_category`
--

LOCK TABLES `aguo_category` WRITE;
/*!40000 ALTER TABLE `aguo_category` DISABLE KEYS */;
INSERT INTO `aguo_category` VALUES (1,'/static/category/front.png','前端','前端是什么，大前端'),(2,'/static/category/back.png','后端','后端最牛叉'),(3,'/static/category/lift.jpg','生活','生活趣事'),(4,'/static/category/database.png','数据库','没数据库，啥也不管用'),(5,'/static/category/language.png','编程语言','好多语言，该学哪个？');
/*!40000 ALTER TABLE `aguo_category` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `aguo_comment`
--

DROP TABLE IF EXISTS `aguo_comment`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `aguo_comment` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `create_date` bigint NOT NULL,
  `article_id` bigint NOT NULL,
  `author_id` bigint NOT NULL,
  `parent_id` bigint NOT NULL,
  `to_uid` bigint NOT NULL,
  `level` varchar(1) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  KEY `article_id` (`article_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1521128821207068674 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `aguo_comment`
--

LOCK TABLES `aguo_comment` WRITE;
/*!40000 ALTER TABLE `aguo_comment` DISABLE KEYS */;
INSERT INTO `aguo_comment` VALUES (53,'写的好',123213213213,1,1,0,1,'1'),(54,'111',123123123123,1,1,53,1,'2'),(56,'222',12312,1,1,0,1,'1'),(1405204547248377858,'确实写得好',1623861846172,1,1,53,1,'2'),(1405205050975899650,'123123',1623861966270,1,1,0,0,'1'),(1405205572185280513,'3333',1623862090534,1,1,0,0,'1'),(1405206087392612353,'7777',1623862213367,1,1,0,0,'1'),(1405206147568291842,'7777',1623862227714,1,1,0,0,'1'),(1405206347246522370,'666',1623862275315,1,1,0,0,'1'),(1405208637198131202,'99999999999999999999',1623862821278,1,1,0,0,'1'),(1405209691876790274,'66666666666666666',1623863072732,1,1,1405208637198131202,1,'2'),(1520604638005846017,'123465',1651375371823,1,1,0,0,'1'),(1520604756331356161,'牛逼啊',1651375400036,1,1,0,0,'1'),(1520606192528154626,'确实写得牛逼 爱了爱了',1651375742453,1,1,1520604756331356161,1,'2'),(1520667220381212673,'牛逼',1651390292624,1405916999732707331,1,0,0,'1'),(1520677242611900418,'那肯定啊 小肥莫',1651392682110,1405916999732707331,1,1520667220381212673,1,'2'),(1520677877528829953,'牛不牛逼？',1651392833485,1405916999732707331,1,1520667220381212673,1,'2'),(1520806490265767938,'徐小牛',1651423497152,1,1,0,0,'1'),(1521016911069376514,'213',1651473665382,1405916999732707337,1,0,0,'1'),(1521128821207068673,'牛逼的饿了么UI',1651500346837,10,1,0,0,'1');
/*!40000 ALTER TABLE `aguo_comment` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `aguo_permission`
--

DROP TABLE IF EXISTS `aguo_permission`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `aguo_permission` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1521418195148636162 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `aguo_permission`
--

LOCK TABLES `aguo_permission` WRITE;
/*!40000 ALTER TABLE `aguo_permission` DISABLE KEYS */;
INSERT INTO `aguo_permission` VALUES (1,'查询权限列表','/admin/permission/permissionList','查询权限列表'),(2,'11','11','111'),(7,'1213','123','123'),(8,'删除权限','/admin/permission/add','删除权限'),(9,'好咯','/admin/permission/add','aa'),(10,'俺就就这样','qewq','aadd');
/*!40000 ALTER TABLE `aguo_permission` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `aguo_sys_log`
--

DROP TABLE IF EXISTS `aguo_sys_log`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `aguo_sys_log` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `create_date` bigint DEFAULT NULL,
  `ip` varchar(15) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  `method` varchar(100) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  `module` varchar(10) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  `nickname` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `operation` varchar(25) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  `params` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  `time` bigint DEFAULT NULL,
  `userid` bigint DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `aguo_sys_log`
--

LOCK TABLES `aguo_sys_log` WRITE;
/*!40000 ALTER TABLE `aguo_sys_log` DISABLE KEYS */;
/*!40000 ALTER TABLE `aguo_sys_log` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `aguo_sys_user`
--

DROP TABLE IF EXISTS `aguo_sys_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `aguo_sys_user` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `account` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '账号',
  `admin` bit(1) DEFAULT NULL COMMENT '是否管理员',
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '头像',
  `create_date` bigint DEFAULT NULL COMMENT '注册时间',
  `deleted` bit(1) DEFAULT NULL COMMENT '是否删除',
  `email` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '邮箱',
  `last_login` bigint DEFAULT NULL COMMENT '最后登录时间',
  `mobile_phone_number` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '手机号',
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '昵称',
  `password` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '密码',
  `salt` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '加密盐',
  `status` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '状态',
  PRIMARY KEY (`id`) USING BTREE,
  KEY `index_account_password` (`account`,`password`)
) ENGINE=InnoDB AUTO_INCREMENT=1404448588146192406 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `aguo_sys_user`
--

LOCK TABLES `aguo_sys_user` WRITE;
/*!40000 ALTER TABLE `aguo_sys_user` DISABLE KEYS */;
INSERT INTO `aguo_sys_user` VALUES (1,'admin',_binary '','http://localhost:8080http://img.aguo.pro/236f4546deae4e048a3c96bbadc755f4.png',20210622223122,_binary '\0','11',20210630223130,'12','阿果','e2f349a4f2970fa9eaf0ea369b0de24e','12','1'),(1404446129264832513,'lisi',_binary '','http://img.aguo.pro/236f4546deae4e048a3c96bbadc755f4.png',1623681025218,_binary '\0','',1623681025218,NULL,'李四','31dfe3b790ec41935f603027fd0e3919','',''),(1404448463944462338,'12213',_binary '','http://img.aguo.pro/236f4546deae4e048a3c96bbadc755f4.png',1623681581855,_binary '\0','',1623681581855,NULL,'123','b5676e0fecb7329cd2b2d264e747e472','',''),(1404448588146192386,'123',_binary '','http://img.aguo.pro/236f4546deae4e048a3c96bbadc755f4.png',1623681611474,_binary '\0','',1623681611474,NULL,'123','5aae215eca4a5d570989ec75cfd9bf69','',''),(1404448588146192399,'demoData3',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'demoData','d97b4752725c534d7d662c053e973ce5',NULL,NULL),(1404448588146192400,'demoData',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'demoData','d97b4752725c534d7d662c053e973ce5',NULL,NULL),(1404448588146192401,'demoData1',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'demoData','d97b4752725c534d7d662c053e973ce5',NULL,NULL),(1404448588146192402,'root',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'root','f6734262472833fe53487317e1f37c2c',NULL,NULL),(1404448588146192403,'aguo',_binary '','http://img.aguo.pro/236f4546deae4e048a3c96bbadc755f4.png',1651665882399,_binary '\0','',1651665882399,NULL,'阿果','cc3bbeeb74469dc5097811a8665828e7','',''),(1404448588146192404,'feimo1',_binary '','http://img.aguo.pro/236f4546deae4e048a3c96bbadc755f4.png',1651669736303,_binary '\0','',1651669736303,NULL,'肥莫1','cc3bbeeb74469dc5097811a8665828e7','',''),(1404448588146192405,'feimo2',_binary '','http://img.aguo.pro/236f4546deae4e048a3c96bbadc755f4.png',1651669775575,_binary '\0','',1651669775575,NULL,'肥莫2','cc3bbeeb74469dc5097811a8665828e7','','');
/*!40000 ALTER TABLE `aguo_sys_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `aguo_tag`
--

DROP TABLE IF EXISTS `aguo_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `aguo_tag` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `tag_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `aguo_tag`
--

LOCK TABLES `aguo_tag` WRITE;
/*!40000 ALTER TABLE `aguo_tag` DISABLE KEYS */;
INSERT INTO `aguo_tag` VALUES (5,'/static/tag/java.png','springboot'),(6,'/static/tag/java.png','spring'),(7,'/static/tag/java.png','springmvc'),(8,'/static/tag/css.png','redis'),(9,'x','设计模式');
/*!40000 ALTER TABLE `aguo_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sys_log`
--

DROP TABLE IF EXISTS `sys_log`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `sys_log` (
  `id` int NOT NULL AUTO_INCREMENT,
  `create_date` datetime DEFAULT NULL,
  `ip` varchar(15) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  `method` varchar(100) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  `module` varchar(10) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  `nickname` varchar(10) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  `operation` varchar(25) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  `params` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  `time` bigint DEFAULT NULL,
  `userid` bigint DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3018 DEFAULT CHARSET=utf8 COLLATE=utf8_bin;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sys_log`
--

LOCK TABLES `sys_log` WRITE;
/*!40000 ALTER TABLE `sys_log` DISABLE KEYS */;
INSERT INTO `sys_log` VALUES (2994,'2022-04-06 09:22:21','0:0:0:0:0:0:0:1','com.shimh.controller.ArticleController.listArticles()','文章',NULL,'获取所有文章',NULL,293,NULL),(2995,'2022-04-06 09:22:21','0:0:0:0:0:0:0:1','com.shimh.controller.ArticleController.listArchives()','文章',NULL,'获取文章归档日期',NULL,289,NULL),(2996,'2022-04-06 09:22:21','0:0:0:0:0:0:0:1','com.shimh.controller.ArticleController.listHotArticles()','文章',NULL,'获取最热文章',NULL,308,NULL),(2997,'2022-04-06 09:22:21','0:0:0:0:0:0:0:1','com.shimh.controller.TagController.listHotTags()','标签',NULL,'获取最热标签',NULL,288,NULL),(2998,'2022-04-06 09:22:26','0:0:0:0:0:0:0:1','com.shimh.controller.TagController.listCategorysDetail()','标签',NULL,'获取所有标签，详细',NULL,4,NULL),(2999,'2022-04-06 09:22:26','0:0:0:0:0:0:0:1','com.shimh.controller.CategoryController.listCategorysDetail()','文章分类',NULL,'获取所有文章分类，详细',NULL,17,NULL),(3000,'2022-04-06 09:22:27','0:0:0:0:0:0:0:1','com.shimh.controller.ArticleController.listArchives()','文章',NULL,'获取文章归档日期',NULL,3,NULL),(3001,'2022-04-06 09:22:27','0:0:0:0:0:0:0:1','com.shimh.controller.ArticleController.listArticles()','文章',NULL,'获取所有文章',NULL,5,NULL),(3002,'2022-04-06 09:22:29','0:0:0:0:0:0:0:1','com.shimh.controller.CategoryController.listCategorysDetail()','文章分类',NULL,'获取所有文章分类，详细',NULL,2,NULL),(3003,'2022-04-06 09:22:29','0:0:0:0:0:0:0:1','com.shimh.controller.TagController.listCategorysDetail()','标签',NULL,'获取所有标签，详细',NULL,2,NULL),(3004,'2022-04-06 09:22:29','0:0:0:0:0:0:0:1','com.shimh.controller.CategoryController.getCategoryDetail()','文章分类',NULL,'根据id获取详细文章分类，文章数',NULL,5,NULL),(3005,'2022-04-06 09:22:29','0:0:0:0:0:0:0:1','com.shimh.controller.ArticleController.listArticles()','文章',NULL,'获取所有文章',NULL,15,NULL),(3006,'2022-04-06 09:22:30','0:0:0:0:0:0:0:1','com.shimh.controller.TagController.listCategorysDetail()','标签',NULL,'获取所有标签，详细',NULL,2,NULL),(3007,'2022-04-06 09:22:30','0:0:0:0:0:0:0:1','com.shimh.controller.CategoryController.listCategorysDetail()','文章分类',NULL,'获取所有文章分类，详细',NULL,3,NULL),(3008,'2022-04-06 09:22:31','0:0:0:0:0:0:0:1','com.shimh.controller.ArticleController.listArchives()','文章',NULL,'获取文章归档日期',NULL,2,NULL),(3009,'2022-04-06 09:22:31','0:0:0:0:0:0:0:1','com.shimh.controller.ArticleController.listHotArticles()','文章',NULL,'获取最热文章',NULL,3,NULL),(3010,'2022-04-06 09:22:31','0:0:0:0:0:0:0:1','com.shimh.controller.TagController.listHotTags()','标签',NULL,'获取最热标签',NULL,3,NULL),(3011,'2022-04-06 09:22:31','0:0:0:0:0:0:0:1','com.shimh.controller.ArticleController.listArticles()','文章',NULL,'获取所有文章',NULL,9,NULL),(3012,'2022-04-06 09:22:33','0:0:0:0:0:0:0:1','com.shimh.controller.ArticleController.getArticleAndAddViews()','文章',NULL,'根据id获取文章，添加阅读数',NULL,36,NULL),(3013,'2022-04-06 09:22:35','0:0:0:0:0:0:0:1','com.shimh.controller.TagController.listHotTags()','标签',NULL,'获取最热标签',NULL,2,NULL),(3014,'2022-04-06 09:22:35','0:0:0:0:0:0:0:1','com.shimh.controller.ArticleController.listHotArticles()','文章',NULL,'获取最热文章',NULL,3,NULL),(3015,'2022-04-06 09:22:35','0:0:0:0:0:0:0:1','com.shimh.controller.ArticleController.listArchives()','文章',NULL,'获取文章归档日期',NULL,1,NULL),(3016,'2022-04-06 09:22:35','0:0:0:0:0:0:0:1','com.shimh.controller.ArticleController.listArticles()','文章',NULL,'获取所有文章',NULL,5,NULL),(3017,'2022-04-06 09:22:36','0:0:0:0:0:0:0:1','com.shimh.controller.ArticleController.getArticleAndAddViews()','文章',NULL,'根据id获取文章，添加阅读数',NULL,7,NULL);
/*!40000 ALTER TABLE `sys_log` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sys_user`
--

DROP TABLE IF EXISTS `sys_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `sys_user` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `account` varchar(64) DEFAULT NULL,
  `admin` bit(1) DEFAULT NULL,
  `avatar` varchar(255) DEFAULT NULL,
  `create_date` datetime DEFAULT NULL,
  `deleted` bit(1) DEFAULT NULL,
  `email` varchar(128) DEFAULT NULL,
  `last_login` datetime DEFAULT NULL,
  `mobile_phone_number` varchar(20) DEFAULT NULL,
  `nickname` varchar(255) DEFAULT NULL,
  `password` varchar(64) DEFAULT NULL,
  `salt` varchar(255) DEFAULT NULL,
  `status` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `UK_awpog86ljqwb89aqa1c5gvdrd` (`account`),
  UNIQUE KEY `UK_ahtq5ew3v0kt1n7hf1sgp7p8l` (`email`)
) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sys_user`
--

LOCK TABLES `sys_user` WRITE;
/*!40000 ALTER TABLE `sys_user` DISABLE KEYS */;
/*!40000 ALTER TABLE `sys_user` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2022-05-04 22:20:25
